<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>绮罗传香度良辰</title>
  
  
  <link href="http://sagirichan.com/atom.xml" rel="self"/>
  
  <link href="http://sagirichan.com/"/>
  <updated>2022-06-12T05:03:19.806Z</updated>
  <id>http://sagirichan.com/</id>
  
  <author>
    <name>绮罗传香</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计网复习笔记-传输层</title>
    <link href="http://sagirichan.com/2022/06/12/computer-network-note-transportLayer/"/>
    <id>http://sagirichan.com/2022/06/12/computer-network-note-transportLayer/</id>
    <published>2022-06-12T05:01:07.000Z</published>
    <updated>2022-06-12T05:03:19.806Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分解与复用"><a href="#分解与复用" class="headerlink" title="分解与复用"></a>分解与复用</h1><p>主机使用IP地址&amp;端口号将报文段导向到相应的套接字</p><p>具有不同源IP地址和&#x2F;或源端口号的IP数据报（目的IP地址和端口号相同）定向到相同的套接字</p><p>源IP地址和源端口号提供了返回地址</p><hr><h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><ul><li><p>尽力而为</p><ul><li>丢包</li><li>对应用程序交付失序</li></ul></li><li><p>无连接</p><ul><li>在UDP发送方和接收方之间无握手</li><li>每个UDP段的处理独立于其他段</li></ul></li></ul><p>常用于流媒体应用程序</p><ul><li>丢包容忍</li><li>速率敏感</li></ul><h2 id="UDP报文结构："><a href="#UDP报文结构：" class="headerlink" title="UDP报文结构："></a>UDP报文结构：</h2><table>    <tr>        <td> [16位]源端口 </td>         <td> [16位]目的端口 </td>     </tr>    <tr>        <td> [16位]长度 </td>         <td> [16位]检查和 </td>     </tr>    <tr>           <td colspan="2" align="center"> 数据 </td>        </tr></table><h3 id="UDP检查和："><a href="#UDP检查和：" class="headerlink" title="UDP检查和："></a>UDP检查和：</h3><p>对发送方的UDP报文段的所有16比特字进行<strong>求和</strong>。当求和遇见溢出的时候，进行<strong>回卷</strong>。求和结束后再进行<strong>反码</strong>运算，得到的结果放在UDP报文段中的检验和字段。</p><p><img src="https://s2.loli.net/2022/05/11/P8S9z3eQTtqn1Kl.png" alt="UDP检查和举例.png" loading="lazy"></p><hr><h1 id="rdt协议（可靠传输协议）"><a href="#rdt协议（可靠传输协议）" class="headerlink" title="rdt协议（可靠传输协议）"></a>rdt协议（可靠传输协议）</h1><p>不可靠信道需要可靠运输协议。</p><h2 id="rdt1-0"><a href="#rdt1-0" class="headerlink" title="rdt1.0"></a>rdt1.0</h2><p>rdt1.0：完全可靠信道上的可靠数据传输。</p><ul><li><p>底层信道完全可靠</p></li><li><p>发送方将数据发向底层信道</p></li><li><p>接收方从底层信道接收数据</p></li></ul><p><img src="https://s2.loli.net/2022/05/11/cB5A3jE2tIOoYL8.png" alt="rdt1.0.png" loading="lazy"></p><h2 id="rdt2-0"><a href="#rdt2-0" class="headerlink" title="rdt2.0"></a>rdt2.0</h2><p>rdt2.0：具有比特差错的信道。</p><ul><li><p>具有比特差错的底层信道</p><ul><li><p><strong>有</strong>比特差错</p></li><li><p><strong>无</strong>分组丢失</p></li></ul></li><li><p>数据出错后处理方式</p><ul><li>检错重传</li></ul></li><li><p>rdt2.0新增加机制（与rdt1.0比较）</p><ul><li><p>检错</p></li><li><p>反馈：ACK, NAK</p><ul><li><p>ACKnowledge Character</p></li><li><p>Negative Acknowledgment</p></li></ul></li><li><p>重传</p></li></ul></li></ul><h3 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h3><ul><li><p>无差错时情况：</p><p>  <img src="https://s2.loli.net/2022/05/11/VT8aovjLNJS7XuE.png" alt="rdt2.0无差错.png" loading="lazy"></p></li><li><p>有差错时情况</p><p>  <img src="https://s2.loli.net/2022/05/11/ZeXpNx23qDEJzdP.png" alt="rdt2.0有差错.png" loading="lazy"></p></li></ul><p>流程图：</p><pre class="mermaid">graph LR发送方产生数据 --> 发送数据 --> C[接收方接收并分析数据]C -.-> A((有差错)) -.返回 rdt_rcv & isNAK.-> 发送数据C --> B((无差错)) --返回 rdt_rcv & isACK--> 发送方产生数据</pre><h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><p>没有考虑ACK、NAK发生缺损的情况。</p><ul><li><p>如果ACK发生翻转，发送方会重传</p></li><li><p>如果NAK发生翻转，发送方会误以为发送成功而不重传正确数据</p></li></ul><h2 id="rdt2-1"><a href="#rdt2-1" class="headerlink" title="rdt2.1"></a>rdt2.1</h2><p>在2.0的基础上，发送方为每个发送出去的数据包添加0或1的序号，接收方只有在按顺序依次接收到0、1、0、1…号数据包时才会接受数据。</p><p>假设发送0号数据包：</p><ul><li><p>接收方成功接受数据包，返回ACK，等待1号数据包；但是ACK发生了翻转，发送方收到NAK：</p><p>  发送方重传0号数据包，接收方不接受0号数据包，将数据包丢弃，并再次返回对0号数据包的ACK</p></li><li><p>接收方接收到破损数据包，返回NAK，继续等待0号数据包；但是NAK发生了翻转，发送方收到ACK：</p><p>  发送方传输1号数据包，由于接收方在等待0号数据包，故接收到此数据包后不改变状态，继续等待0号数据包，并返回对1号数据包的ACK</p></li></ul><p>（很惭愧，我从这里开始理解不了状态机图了，也无法解释清楚协议内容。）</p><h2 id="rdt2-2"><a href="#rdt2-2" class="headerlink" title="rdt2.2"></a>rdt2.2</h2><p>rdt2.2与2.1的区别在于去掉了NAK，而在ACK分组中显式指出分组编号。</p><p>在收到非期望分组或者收到的分组发生比特差错时，均对上次正确接收的分组反馈一个ACK。</p><h2 id="rdt3-0"><a href="#rdt3-0" class="headerlink" title="rdt3.0"></a>rdt3.0</h2><p>3.0同时考虑到封包遗失与资料错误的情形，除了使用ACK机制，另外在传送端多了倒数计时器，封包送出去如果超过时间仍未收到ACK或是收到不正确编号的ACK，则再送出封包一次。</p><ul><li><p>无丢包时如图：</p><p>  <img src="https://s2.loli.net/2022/05/11/gVuf8Z6kBOEeMKa.png" alt="rdt3.0无丢包.png" loading="lazy"></p></li><li><p>分组丢失时如图：</p><p>  <img src="https://s2.loli.net/2022/05/11/iNjonQRZdkmqBGy.png" alt="rdt3.0分组丢失.png" loading="lazy"></p></li><li><p>ACK丢失时如图：</p><p>  <img src="https://s2.loli.net/2022/05/11/ZDaCXKNAqHzGgsW.png" alt="rdt3.0ACK丢失.png" loading="lazy"></p></li></ul><p>（写的是些什么寄吧，我在制造文字垃圾）</p><p><img src="https://s2.loli.net/2022/05/11/d6R8QTStiHfoaFy.png" alt="rdt3.0窗口太窄_过早重传.png" loading="lazy"></p><h2 id="协议性能"><a href="#协议性能" class="headerlink" title="协议性能"></a>协议性能</h2><h3 id="停等协议"><a href="#停等协议" class="headerlink" title="停等协议"></a>停等协议</h3><p>每发送一个分组，都要等待接收方回应。</p><p><img src="https://s2.loli.net/2022/05/11/PoWLftrKmYkwyCb.png" alt="停等协议.png" loading="lazy"></p><p>记分组长度为L，信道速率为R，则传输单个分组时间为：</p><p>$$\frac{L}{R}+RTT$$</p><p>信道利用率为：</p><p>$$\frac { \frac{L}{R} } {RTT + \frac{L}{R}}$$</p><h3 id="流水线协议"><a href="#流水线协议" class="headerlink" title="流水线协议"></a>流水线协议</h3><p>序号范围增加、发送方与接收方设置缓存。</p><p>假设每次连续传输3个分组：</p><p><img src="https://s2.loli.net/2022/05/11/e4oLcUEfMnmF1jA.png" alt="流水线协议.png" loading="lazy"></p><p>信道利用率为：</p><p>$$\frac { 3\frac{L}{R} } {RTT + \frac{L}{R}}$$</p><p>是停等协议的三倍。</p><h3 id="滑动窗口协议"><a href="#滑动窗口协议" class="headerlink" title="滑动窗口协议"></a>滑动窗口协议</h3><p>为了提高效率填满管道，在发送方等待确认时，应当有多个分组正在传送中。也就是说我们需要让多个分组处于等待确认的状态，以便在发送方等待确认的同时，信道也能保持忙碌状态。</p><ul><li><p>发送方和接收方都具有一定容量的缓冲区（即窗口），允许发送方连续发送多个帧而不需要等待应答。</p></li><li><p><strong>发送窗口</strong>就是发送端允许连续发送的帧的序号表，发送端可以不等待应答而连续发送的最大帧数称为发送窗口的尺寸</p></li><li><p><strong>接收窗口</strong>是接收方允许接收的帧的序号表，凡落在接收窗口内的帧，接收方都必须处理，落在接收窗口外的帧被丢弃。接收方每次允许接收的帧数称为接收窗口的尺寸</p></li></ul><h4 id="Go-Back-N协议"><a href="#Go-Back-N协议" class="headerlink" title="Go-Back-N协议"></a>Go-Back-N协议</h4><p>返回N协议(GO-Back-N GBN)的关键是发送方能够在收到确认之前发送多个分组，但接收方只能缓存一个分组。发送方为发送出去的分组保留副本，直到来自接收方确认达到。</p><p><img src="https://img-blog.csdn.net/20131221192020015?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHBwcmluY2U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="GBN协议" loading="lazy"></p><p><img src="https://img-blog.csdn.net/20131221192108015?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHBwcmluY2U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="GBN发送窗口" loading="lazy"></p><ul><li><p>ACK机制：</p><p>  确认ACK(n): 确认到序列号n(包含n)的分组均已被正确接收，可能收到重复ACK。</p></li><li><p>累积确认：</p><p>  发送拥有最高序列号的、已被正确接收的分组的ACK。</p><p>  接收方不需要给收到的数据分组逐个发送确认，而是可以在收到几个数据分组后对按序到达的最后一个数据分组发送确认，ACK(n)表示序号为n及之前的所有数据分组都已经成功接收</p></li></ul><p>示例：</p><p><img src="https://img-blog.csdnimg.cn/b5d578b5330e42ceb61c9744373a87bb.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAUGFyYW5vaWTimIY=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="GBN示例" loading="lazy"></p><p>解释：窗口大小为4，发送方发送数据包0，1，2，3，然后进入等待状态，其中数据包2丢失，接收方返回Ack0，1，窗口滑动继续发送包4，5，此时包2计时超时，默认数据包2没有收到，按照GBN，发送方重新发送数据包2，3，4，5。</p><p>这里可以看出数据包重复了。</p><h4 id="选择重传-SR"><a href="#选择重传-SR" class="headerlink" title="选择重传 SR"></a>选择重传 SR</h4><p>在GBN中，使用累积确认，为整个分组中最后一个得到确认的数据包发送ACK；</p><p>而在选择重传中，为每个数据包单独发布ACK。同时发送端也为每个分组单独配置计时器，当时间结束仍未收到ACK时，单独重传该分组。</p><p><img src="https://img-blog.csdnimg.cn/b76216ad9a054af79ad4f3ddadafadef.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAUGFyYW5vaWTimIY=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="选择重传示例" loading="lazy"></p><h3 id="窗口长度选择"><a href="#窗口长度选择" class="headerlink" title="窗口长度选择"></a>窗口长度选择</h3><p>窗口长度小于等于序号空间的一半。</p><hr><h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><ul><li><p>面向连接</p></li><li><p>流量控制</p></li><li><p>拥塞控制</p></li></ul><h2 id="TCP报文结构"><a href="#TCP报文结构" class="headerlink" title="TCP报文结构"></a>TCP报文结构</h2><p><img src="https://s2.loli.net/2022/06/02/135WToLye2ju4MA.png" alt="TCP报文结构.png" loading="lazy"></p><table border="1" cellspacing="0">    <tr>        <td colspan="16" align="center"> [2字节/16位]源端口 </td>         <td colspan="16" align="center" width="50%" > [16位]目的端口 </td>     </tr>    <tr>        <td colspan="32" align="center"> [32位]序号seq </td>     </tr>    <tr>          <td colspan="32" align="center"> [32位]确认号ack </td>        </tr>    <tr>        <td rowspan="2" colspan="4" align="center"> [4位]数据偏移 </td>        <td rowspan="2" colspan="6" align="center"> [6位]保留位 </td>        <td rowspan="1" colspan="6" align="center"> [6位]tcp flags </td>        <td rowspan="2" colspan="16" align="center"> 窗口 </td>    </tr>    <tr>        <td rowspan="1" colspan="1" align="center"> URG </td>        <td rowspan="1" colspan="1" align="center"> ACK </td>        <td rowspan="1" colspan="1" align="center"> PSH </td>        <td rowspan="1" colspan="1" align="center"> RST </td>        <td rowspan="1" colspan="1" align="center"> SYN </td>        <td rowspan="1" colspan="1" align="center"> FIN </td>    </tr>    <tr>        <td colspan="16" align="center"> 检验和 </td>        <td colspan="16" align="center"> 紧急指针 </td>    </tr>    <tr>        <td colspan="32" align="center"> TCP选项 </td>    </tr>    <tr>        <td colspan="32" align="center"> 应用层数据（变长） </td>    </tr></table><p>序号：对数据字节计数（并非对报文段计数）<br>URG：紧急数据（一般不用）<br>ACK：ACK序号<br>PSH：立即提交数据（一般不用）<br>RST，SYN，FIN：连接建立（建立和拆连）<br>接收窗口：接收方允许的字节数</p><h3 id="序号和确认号"><a href="#序号和确认号" class="headerlink" title="序号和确认号"></a>序号和确认号</h3><pre class="mermaid">    sequenceDiagram    participant sender as 发送方    participant reciver as 接收方    activate sender    Note left of sender: 用户键入c        sender ->> reciver: Seq=42, ACK=79, data = ‘C’    deactivate sender    activate reciver    Note right of reciver: 主机对收到的‘C’<br/>给出确认<br/>回显 ‘C’        reciver ->> sender: Seq=79, ACK=43, data = ‘C’    deactivate reciver    activate sender    Note left of sender: 主机对收到的回显‘c’<br/>给出确认        sender ->> reciver: Seq=43, ACK=80    deactivate sender</pre><ul><li><p>序号seq</p><p>  报文段中第一个数据字节在字节流中的位置编号</p></li><li><p>确认号ack</p><p>  期望从对方收到下一个字节的序号，如果一切正常，应为对方发送过来的(seq+1)</p></li></ul><h2 id="TCP往返时延的估计与超时"><a href="#TCP往返时延的估计与超时" class="headerlink" title="TCP往返时延的估计与超时"></a>TCP往返时延的估计与超时</h2><p><strong>如何设置TCP超时值？</strong></p><ul><li><p>应大于RTT</p></li><li><p>太短：过早超时，不必要重传</p></li><li><p>太长：对报文段丢失的响应太慢，效率太低</p></li></ul><p><strong>如何估计RTT？</strong></p><ul><li><p>SampleRTT</p><ul><li><p>RTT测量值</p></li><li><p>从发送报文段到接收到ACK的测量时间</p></li></ul><p>  SampleRTT会变化 –&gt; 平均最近的测量值</p></li><li><p>EstimatedRTT</p><ul><li><p>$$ EstimatedRTT &#x3D; (1-α)<em>EstimatedRTT + α</em>SampleRTT $$ 或<br>$$ EstimatedRTT &#x3D; EstimatedRTT + α*(SampleRTT-EstimatedRTT) $$</p></li><li><p>典型 α&#x3D;0.125</p></li></ul></li><li><p>TimeoutInterval</p><ul><li><p>EstimtedRTT加“安全余量”</p></li><li><p>首先估算EstimtedRTT与真实RTT之间的差值</p><p>  $$ DevRTT &#x3D; (1-β)<em>DevRTT + β</em>(|SampleRTT - EstimtedRTT|) $$</p></li><li><p>最后计算TimeoutInterval</p><ul><li><p>$$ TimeoutInterval &#x3D; μ<em>EstimtedRTT + δ</em>DevRTT $$</p></li><li><p>通常情况下，μ&#x3D;1，δ&#x3D;4，即</p><p>  $$ TimeoutInterval &#x3D; EstimtedRTT + 4*DevRTT $$</p></li></ul></li><li><p>典型地，β&#x3D;0.25</p></li></ul></li></ul><h2 id="TCP可靠数据传输"><a href="#TCP可靠数据传输" class="headerlink" title="TCP可靠数据传输"></a>TCP可靠数据传输</h2><ul><li><p>TCP在IP不可靠服务的基础上创建可靠数据传输服务</p></li><li><p>流水线发送报文段</p></li><li><p>累计确认</p></li><li><p>TCP使用单个重传计时器</p></li><li><p>重传被下列事件触发：</p><ul><li><p>超时事件</p></li><li><p>重复ACK</p></li></ul></li></ul><h3 id="TCP可靠数据传输属于滑动窗口方法"><a href="#TCP可靠数据传输属于滑动窗口方法" class="headerlink" title="TCP可靠数据传输属于滑动窗口方法"></a>TCP可靠数据传输属于滑动窗口方法</h3><ul><li><p>发送方</p><ul><li><p>收到累积ACK，窗口向右滑动</p></li><li><p>单个重传计时器，超时仅重传导致超时的报文段</p></li><li><p>快速重传：冗余ACK</p></li></ul></li><li><p>接收方</p><ul><li><p>对收到的报文段进行缓存</p></li><li><p>收到任何报文段时，均发出<strong>正确的</strong>累计确认</p><ul><li><p>即 举例：</p><p>  累计收到了1~8、11~12的报文段，则正确的累计确认为ACK&#x3D;8</p><ul><li><p>若收到4~6报文，或12~14报文，均回复ACK&#x3D;8</p></li><li><p>若收到9~10报文，则正确的累计回复为ACK&#x3D;12</p></li></ul></li></ul></li></ul></li></ul><h3 id="TCP重传情况"><a href="#TCP重传情况" class="headerlink" title="TCP重传情况"></a>TCP重传情况</h3><p><img src="https://s2.loli.net/2022/06/06/4wkRjYF8WsTGOhb.png" alt="丢失确认的情况.png" loading="lazy"></p><p><img src="https://s2.loli.net/2022/06/06/H7ZkqhEu4aA3GQY.png" alt="过早超时的情况.png" loading="lazy"></p><p><img src="https://s2.loli.net/2022/06/06/rbewyOLA6YXhP1c.png" alt="累计确认情况.png" loading="lazy"></p><h3 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h3><ul><li><p>超时间隔常常相对较长</p><ul><li>重传丢失报文段以前有长时延</li></ul></li><li><p>通过冗余ACK，检测丢失的报文段</p><ul><li><p>发送方经常一个接一个地发送报文段</p></li><li><p>如果报文段丢失，将会收到很多重复ACK</p></li></ul></li><li><p>如果发送方连续收到3个相同ACK，便可以假定被确认的报文段之后的报文段丢失了，此时即使没有达到定时器超时时间，也采取重传措施</p><ul><li>快速重传：在定时器超时之前重传</li></ul></li></ul><h2 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h2><ul><li><p>TCP接收方有1个接收缓冲区</p></li><li><p>应用进程可能从缓冲区读取数据缓慢</p></li><li><p>匹配速度服务：发送速率需要匹配接收方应用程序的提取速率</p></li></ul><p>TCP流量控制：发送方发送数据太快，导致接收方来不及接收时，需要进行流量控制</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>TCP流量控制通过<strong>接收窗口</strong>字段来实现</p><ul><li><p>接收方计算缓存区的剩余空间——即接收窗口大小</p></li><li><p>RcvWindow&#x3D; RcvBuffer-[LastByteRcvd -LastByteRead]</p></li><li><p>接收方通过TCP首部的<strong>接收窗口</strong>字段反馈给发送方</p></li><li><p>发送方根据接收窗口字段来限制发送窗口大小，以保证接收方缓存不溢出</p></li></ul><h2 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h2><p>TCP是面向连接的协议，TCP连接的建立和释放是每次TCP传输中必不可少的过程</p><p>TCP的连接传输包括三个状态</p><ul><li><p>连接建立</p></li><li><p>数据传输</p></li><li><p>连接释放</p></li></ul><h3 id="建立连接（三次握手）"><a href="#建立连接（三次握手）" class="headerlink" title="建立连接（三次握手）"></a>建立连接（三次握手）</h3><h4 id="第一次握手过程："><a href="#第一次握手过程：" class="headerlink" title="第一次握手过程："></a>第一次握手过程：</h4><pre class="mermaid">    sequenceDiagram    participant sender as 客户机    participant receiver as 服务器    Note over sender,receiver: 第一次握手：连接请求报文        sender ->> receiver: SYN=1，seq=X</pre><blockquote><p>SYN：同步序列编号<br>SEQ：序列号，表示当前数据传输字节的编号为X</p></blockquote><p>语句含义：请求建立连接</p><p>目前字节编号：X</p><p>下一次编号：X+1</p><p>SEQ&#x3D;X：身份标识</p><h4 id="第二次握手过程："><a href="#第二次握手过程：" class="headerlink" title="第二次握手过程："></a>第二次握手过程：</h4><pre class="mermaid">    sequenceDiagram    participant sender as 客户机    participant receiver as 服务器    sender ->> receiver: SYN=1，seq=X    note over sender,receiver: 第二次握手：确认报文        receiver ->> sender: SYN=1，seq=Y，ack=X+1</pre><blockquote><p>SYN：同步序列编号<br>SEQ：序列号<br>ACK：确认编号</p></blockquote><p>目前字节编号：Y</p><p>下一次编号：Y+1</p><p>SEQ&#x3D;Y：身份标识</p><h4 id="第三次握手过程"><a href="#第三次握手过程" class="headerlink" title="第三次握手过程"></a>第三次握手过程</h4><pre class="mermaid">    sequenceDiagram    participant sender as 客户机    participant receiver as 服务器    sender ->> receiver: SYN=1，seq=X    receiver ->> sender: SYN=1，ack=X+1，seq=Y    note over sender,receiver: 第三次握手：确认报文        sender ->> receiver: ack=Y+1，seq=X+1</pre><blockquote><p>SYN：同步序列编号<br>SEQ：序列号<br>ACK：确认编号</p></blockquote><h3 id="释放连接（四次挥手）"><a href="#释放连接（四次挥手）" class="headerlink" title="释放连接（四次挥手）"></a>释放连接（四次挥手）</h3><ul><li><p>第一次挥手：客户机向服务器发送FIN标识位</p></li><li><p>第二次挥手：服务器收到FIN，回复ACK，并开始等待数据传输完毕。 </p></li><li><p>第三次挥手：服务器确认所有向客户机发送的数据传输完毕，同意断开连接，发送FIN标识位 <del><a href="https://www.bilibili.com/read/cv8011528">她同意了</a></del></p></li><li><p>第四次挥手：客户机收到FIN标识位，返回ACK</p></li><li><p>第四次挥手之后：</p><ul><li><p>服务器方面：收到ACK后关闭连接</p></li><li><p>客户机方面：发出ACK后等待2MSL时间，若没有收到新的响应信号则也关闭连接</p></li></ul></li></ul><blockquote><ul><li>MSL：Maximum Segment Lifetime，报文最大生存时间。<ul><li>如果在这个时间段内，服务器没有收到ACK应答报文段，会重发FIN报文段</li><li>如果客户端收到了FIN报文段，那么2MSL的时间将会被重置。</li><li>如果在2MSL时间段内，没有收到任何数据报，客户端会进入CLOSE状态。</li></ul></li></ul></blockquote><pre class="mermaid">    sequenceDiagram    participant sender as 客户机    participant receiver as 服务器    activate sender    note left of sender: 主动方发送FIN报文<br>并置发送序号为X<br>进入FIN-WAIT-1状态        sender ->> receiver: FIN=1，seq=X，ack    deactivate sender    activate receiver    note right of receiver: 被动方发送ACK<br>并置发送序号<br>seq为Y，ack为X+1<br>服务器进入CLOSE_WAIT<br>等待关闭状态        receiver ->> sender: ACK=1，seq=Y，ack=X+1    deactivate receiver    activate receiver    note left of sender: 客户端进入FIN_WAIT_2 状态        note right of receiver: 服务器端确认所有<br>传输到客户端的数据传输完毕<br>发送[FIN,ACK]报文<br>随机生成序列号seq=Z<br>ack值不变，依然为X+1<br>服务器进入LASK_ACK<br>最后确认状态        receiver ->> sender: FIN=1，ACK=1，seq=Z，ack=X+1    deactivate receiver    activate sender    note left of sender: 客户端收到[FIN]后<br>返回ACK、seq、ack<br>seq为刚刚返回的ack<br>ack为刚刚返回的seq+1        sender ->> receiver: ACK=1，seq=X+1，ack=Z+1    deactivate sender    note right of receiver: 服务器收到ACK后关闭连接    note left of sender: 发送ACK后，客户机进入<br>TIME_WAIT时间等待状态<br>等待2MSL后关闭连接</pre><blockquote><p>注：</p><ul><li>小写ack为TCP首部中的[确认号]部分，占32位</li><li>大写ACK为TCP首部中tcp flags部分中的ACK标志位，占1位</li></ul></blockquote><p>简化版：</p><pre class="mermaid">    sequenceDiagram    participant sender as 客户机    participant receiver as 服务器    sender ->> receiver: FIN=1    receiver ->> sender: ACK=1    receiver ->> sender: FIN=1，ACK=1    sender ->> receiver: ACK=1</pre><h2 id="拥塞控制原则"><a href="#拥塞控制原则" class="headerlink" title="拥塞控制原则"></a>拥塞控制原则</h2><h3 id="拥塞控制原理"><a href="#拥塞控制原理" class="headerlink" title="拥塞控制原理"></a>拥塞控制原理</h3><ul><li><p>当大量分组进入网络，超出网络处理能力，会引起网络局部或整体性能下降，这种现象成为拥塞。不加控制的拥塞会导致整个网络瘫痪。</p></li><li><p>与流量控制不同</p><ul><li><p>流量控制是端到端的控制</p></li><li><p>拥塞控制是全局性的过程，涉及整个网络</p></li></ul></li><li><p>表现</p><ul><li><p>丢包</p></li><li><p>长时延</p></li></ul></li></ul><h3 id="拥塞控制起的作用"><a href="#拥塞控制起的作用" class="headerlink" title="拥塞控制起的作用"></a>拥塞控制起的作用</h3><p><img src="https://s2.loli.net/2022/06/06/VhzPFjCLZX6He2I.png" alt="拥塞控制起的作用.png" loading="lazy"></p><h3 id="拥塞控制的原因与开销"><a href="#拥塞控制的原因与开销" class="headerlink" title="拥塞控制的原因与开销"></a>拥塞控制的原因与开销</h3><p>参考文章：<a href="https://www.jianshu.com/p/888cb8aa16d6">TCP&#x2F;IP之拥塞控制</a></p><h4 id="情况一"><a href="#情况一" class="headerlink" title="情况一"></a>情况一</h4><p><img src="https://s2.loli.net/2022/06/07/gBTHdzvQm8l5Ct2.png" alt="拥塞原因与开销情况一.png" loading="lazy"></p><p>路由器速率有限制，故拥塞发生时，时延无限增大。</p><h4 id="情况二"><a href="#情况二" class="headerlink" title="情况二"></a>情况二</h4><p><img src="https://s2.loli.net/2022/06/06/CmFR3GNVBpWzKtj.png" alt="拥塞控制的原因与开销.png" loading="lazy"></p><ul><li><p>通常：λ<del>in</del>&#x3D;λ<del>out</del></p></li><li><p>仅当丢包时，需要“完美的”重传：λ^’^<del>in</del>&gt;λ<del>out</del></p></li><li><p>迟延的分组（而不是丢失）的重传使得λ^’^<del>in</del>比（同完美情况相比）λ<del>out</del>更大</p></li></ul><p>拥塞的“代价”:</p><ul><li><p>比额定的吞吐量做更多的工作（重传）</p></li><li><p>不必要重传：链路承载分组的多个拷贝</p></li></ul><h4 id="情况三"><a href="#情况三" class="headerlink" title="情况三"></a>情况三</h4><p><img src="https://s2.loli.net/2022/06/07/v2wFJPpz6UCW5GK.png" alt="拥塞原因与开销情况三" loading="lazy"></p><ul><li>当分组被丢失时，任何用于传输该分组的上游传输能力都被浪费</li></ul><h3 id="拥塞控制的两类方法"><a href="#拥塞控制的两类方法" class="headerlink" title="拥塞控制的两类方法"></a>拥塞控制的两类方法</h3><ul><li><p>端到端的拥塞控制</p><ul><li><p>不能从网络得到明确的反馈</p></li><li><p>从端系统根据观察到的时延和丢失现象推断出拥塞</p></li><li><p>TCP采取</p></li></ul></li><li><p>网络辅助的拥塞控制</p><ul><li><p>路由器为端系统提供反馈</p></li><li><p>一个bit指示一条链路出现拥塞</p></li><li><p>指示发送方按照一定速率发送</p></li></ul></li></ul><h3 id="案例-ATM-ABR拥塞控制"><a href="#案例-ATM-ABR拥塞控制" class="headerlink" title="案例:ATM ABR拥塞控制"></a>案例:ATM ABR拥塞控制</h3><ul><li><p>通信过程简要描述</p><ul><li><p>发送方沿（建立好连接的）路径上不断传输<strong>数据信元</strong>和<strong>管理信元</strong>，到达接收方</p></li><li><p>接收方将<strong>管理信元</strong>（内容修改调整后）研路径返回（反馈）到发送方</p></li></ul></li></ul><h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><ul><li><p>端到端控制</p></li><li><p>发送方限制传输：滑动窗口法</p></li><li><p>速率 &#x3D; $\frac{CongWin}{RTT}(Bytes&#x2F;sec)$</p></li><li><p>拥塞窗口是动态的，具有感知到网络拥塞的函数</p></li><li><p>发送方如何感知网络拥塞 ？</p><ul><li><p>丢失事件：超时或3个重复ACK</p></li><li><p>发生丢失事件后，TCP发送方降低速率（拥塞窗口）</p></li></ul></li><li><p>三个机制</p><ul><li><p>AIMD（加增倍减算法）</p></li><li><p>慢启动</p></li><li><p>超时事件后的保守机制</p></li></ul></li></ul><h3 id="TCP加减倍增-AIMD"><a href="#TCP加减倍增-AIMD" class="headerlink" title="TCP加减倍增 AIMD"></a>TCP加减倍增 AIMD</h3><ul><li>乘性减：</li></ul><p>丢包事件后，拥塞窗口值减半。</p><ul><li>加性增：</li></ul><p>如没有检测到丢包时间，每个RTT时间拥塞窗口值增加一个MSS（最大报文段长度）</p><p><img src="https://s2.loli.net/2022/06/11/GLJI49gmlTWRcdM.png" alt="AIMD.png" loading="lazy"></p><h3 id="TCP慢启动"><a href="#TCP慢启动" class="headerlink" title="TCP慢启动"></a>TCP慢启动</h3><p>概述：</p><ul><li><p>在连接开始时，拥塞窗口值 &#x3D; 1 MSS</p><ul><li><p>例如： MSS &#x3D; 500 bytes &amp; RTT &#x3D; 200 msec</p></li><li><p>初始化速率 &#x3D; 20 kbps</p></li></ul></li><li><p>可获得宽带可能 &gt;&gt; $\frac{MSS}{RTT}$</p><ul><li>希望尽快达到期待的速率</li></ul></li><li><p>当连接开始，以指数快地增加速率，直到第一个丢失事件发生</p></li></ul><p>具体：</p><ul><li><p>当连接开始的时候，速率呈指数式上升，直到第1次报文丢失事件发生为止：</p><ul><li><p>每RTT倍增拥塞窗口值</p></li><li><p>每收到ACK，增加拥塞窗口</p></li></ul></li></ul><p><img src="https://s2.loli.net/2022/06/12/jNbI5Ruqs6XiTxW.png" alt="TCP慢启动.png" loading="lazy"></p><p>总结：初始效率很低，但以指数快地增长</p><h3 id="超时后的保守机制"><a href="#超时后的保守机制" class="headerlink" title="超时后的保守机制"></a>超时后的保守机制</h3><ul><li><p><strong>基本思想</strong></p><ul><li><p>三个冗余ACK指示网络还具有某些传送报文段的能力</p></li><li><p>直接超时，则更为“严重”</p></li></ul></li><li><p>收到<ins><strong>三个冗余确认</strong></ins>后</p><ul><li><p>CongWin减半</p></li><li><p>窗口再线性增加</p></li></ul></li><li><p>但是<ins><strong>超时事件</strong></ins>以后</p><ul><li><p>CongWin值设置为1 MSS</p></li><li><p>窗口再指数增长</p></li><li><p>到达一个阈值后，再线性增长</p></li></ul></li></ul><p>如图</p><p><img src="https://s2.loli.net/2022/06/12/ITk2ZRDzJwcu5lf.png" alt="TCP拥塞控制.png" loading="lazy"></p><p>①处，慢启动<strong>达到阈值</strong>，进入拥塞避免阶段，CongWin线性增长</p><p>②处，遭遇<strong>超时事件</strong>，CongWin设为1 MSS，重新慢启动，并且将阈值设为发生事件时CongWin的一半，即12</p><p>③处，达到②中设定的阈值，开始线性增长</p><p>④处，遭遇<strong>3 ACK</strong>事件，CongWin减半，来到⑤处，并且将阈值也设为<strong>原CongWin</strong>的一半</p><p>⑤处，窗口线性增长</p><h3 id="TCP吞吐量"><a href="#TCP吞吐量" class="headerlink" title="TCP吞吐量"></a>TCP吞吐量</h3><p>TCP平均吞吐量是窗口长度和RTT的函数</p><ul><li><p>设：窗口长度为W，则$ 吞吐量 &#x3D; \frac{W}{RTT} $</p></li><li><p>当丢包发生后，窗口降为$ \frac{W}{2} $，于是吞吐量降为$ \frac{W}{2RTT} $</p></li><li><p>一个连接的平均吞吐量为$ \frac{0.75W}{RTT} $</p></li></ul><p>实际网络性能分析中TCP吞吐量是复杂函数</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分解与复用&quot;&gt;&lt;a href=&quot;#分解与复用&quot; class=&quot;headerlink&quot; title=&quot;分解与复用&quot;&gt;&lt;/a&gt;分解与复用&lt;/h1&gt;&lt;p&gt;主机使用IP地址&amp;amp;端口号将报文段导向到相应的套接字&lt;/p&gt;
&lt;p&gt;具有不同源IP地址和&amp;#x2F;或源端口号</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://sagirichan.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机网络" scheme="http://sagirichan.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="笔记" scheme="http://sagirichan.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>计网复习笔记-应用层</title>
    <link href="http://sagirichan.com/2022/05/13/computer-network-note-applicationLayer/"/>
    <id>http://sagirichan.com/2022/05/13/computer-network-note-applicationLayer/</id>
    <published>2022-05-13T12:33:05.000Z</published>
    <updated>2022-05-15T17:04:47.527Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h1><ul><li><p>在同一台主机中：两个进程使用进程间通信IPC(由操作系统定义)通信.</p></li><li><p>在不同的主机中：进程通过交换报文通信</p></li></ul><hr><h1 id="因特网运输协议服务"><a href="#因特网运输协议服务" class="headerlink" title="因特网运输协议服务"></a>因特网运输协议服务</h1><h2 id="tcp"><a href="#tcp" class="headerlink" title="tcp"></a>tcp</h2><p>面向连接: 客户机和服务器之间所需的建立</p><p>可靠传输：在发送和接收进程之间</p><p>流控制: 发送方不会淹没接收方</p><p>拥塞控制: 当网络过载时抑制发送方</p><p>并不提供: 定时，最小带宽保证</p><h2 id="udp"><a href="#udp" class="headerlink" title="udp"></a>udp</h2><p>在发送进程及接收进程之间的不可靠数据传输</p><p>不提供：建立连接建立，可靠性，流控，拥塞控制，定时或带宽保证</p><hr><h1 id="web和HTTP协议"><a href="#web和HTTP协议" class="headerlink" title="web和HTTP协议"></a>web和HTTP协议</h1><h2 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h2><ul><li><p>web的应用层协议是HTTP，超文本传输协议</p></li><li><p>Web页面由对象组成，一个基本HTML文件包含多个引用对象：图片，java小程序，视频文件等</p></li><li><p>每个对象可由URL(Uniform Resource Locator 统一资源定位符)寻址</p></li></ul><p>举例：</p><p><strong>http</strong>: &#x2F;&#x2F;<u>114.514.191.810</u>&#x2F;<em>sennpai&#x2F;suki</em><br><strong>协议</strong>    <u>主机名</u>        <em>路径</em></p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>HTTP协议运行在客户与服务器端的应用程序中。</p><ul><li><p>客户机：请求、接收、显示Web对象</p></li><li><p>服务器：Web服务器响应请求而发送对象</p></li></ul><pre class="mermaid">graph LRC[客户机] --HTTP请求--> S[服务器]S[服务器] --HTTP响应--> C[客户机]</pre><p>非持久连接与持久连接：</p><ul><li><p>非持久HTTP</p><p>  <strong>每个</strong>HTTP请求&#x2F;响应对经过一个<strong>单独TCP连接</strong>发送</p><p>  HTTP&#x2F;1.0使用非持久 </p></li><li><p>持久HTTP</p><p>  <strong>多个对象</strong>能够经过客户机和服务器之间的<strong>单个TCP连接</strong>发送</p><p>  HTTP&#x2F;1.1以默认模式使用持久连接</p></li></ul><h3 id="非持久连接"><a href="#非持久连接" class="headerlink" title="非持久连接"></a>非持久连接</h3><pre class="mermaid">graph TBA[1.HTTP客户机向HTTP服务器发起tcp连接] --> B[2.HTTP服务器接受连接并通知客户机] -->C[3.HTTP客户机发送HTTP请求报文进TCP连接套接字,向服务机要对象] -->D[4.HTTP服务器接收请求报文,形成响应报文包含请求对象,并向套接字发送报文] -->E[5.HTTP服务器关闭TCP连接] -->F[6.HTTP客户机接收包含html文件的响应报文并解析] -->G(若发现html文件中又引用了其他对象,则重复上述步骤向服务器要对象)</pre><p>响应时间估算：</p><ul><li><p>往返时间RTT的定义：从客户机到服务器发送一个小分组并返回所历经的时间.</p></li><li><p>响应时间</p><ul><li><p>建立tcp请求：RTT*1</p></li><li><p>发送HTTP请求并得到回应：RTT*1</p></li><li><p>传输文件时间</p></li></ul><p>  <img src="https://s2.loli.net/2022/05/10/wV6lM5ueNE3cxHS.png" alt="HTTP-响应时间估算.png" loading="lazy"></p><p>  总响应&#x3D; 2RTT+传输时间</p></li></ul><h3 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h3><ul><li><p>在发送响应后，保持TCP连接持续打开</p></li><li><p>后继HTTP报文通过该连接持续发送</p></li></ul><p>持久连接又可以分为无流水线与有流水线的连接</p><ul><li><p>无流水线的连接</p><ul><li><p>仅当前面的响应已经收到，客户机发出新的请求</p></li><li><p>对每个引用对象花费一个RTT</p></li></ul><p>  （半自动步枪，每次射击都要扣动扳机（这是什么奇妙的比喻×</p></li><li><p>有流水线的连接</p><ul><li><p>不必等待响应，请求接连发出</p></li><li><p>对所有引用对象花费一个RTT（略多）时间</p></li></ul><p>  （全自动步枪，不必松开扳机，可以一直扣住</p></li></ul><h3 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h3><p>分为<strong>请求报文</strong>与<strong>响应报文</strong></p><h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><p><img src="https://s2.loli.net/2022/05/10/Ut2nKwcEVqf36rT.png" alt="HTTP请求报文.png" loading="lazy"></p><ul><li><p>通用格式</p><ul><li><p>请求行：方法字段，URL字段，版本字段</p></li><li><p>首部行：一般多行</p></li><li><p>空行</p></li><li><p>实体主体：可为空</p></li></ul></li></ul><p>一个简单的例子：</p><pre><code>POST /user HTTP/1.1         //请求行Host: www.user.comContent-Type: application/x-www-form-urlencodedConnection: Keep-AliveUser-agent: Mozilla/5.0.    //以上是首部行                            //空行分割header和请求内容 name=world                  //请求体</code></pre><blockquote><p>方法类型<br>GET：最常用，请求访问网页，实体主体为空<br>POST：常用，提交表单同时请求访问网页，如使用搜索引擎，实体主体中为表单输入值<br>HEAD：少用，测试用，与GET区别在于响应中去掉请求的对象<br>PUT：很少用，向URL字段中定义的路径，上载在实体主体中文件<br>DELETE，很少用，删除在URL字段中定义的文件</p></blockquote><h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><p>响应报文与请求报文结构类似</p><ul><li><p>通用格式</p><ul><li><p>状态行：版本字段，状态码字段，短语字段</p></li><li><p>首部行：一般多行</p></li><li><p>空行</p></li><li><p>实体主体：可为空</p></li></ul></li></ul><p>一些响应码与响应短语的例子及含义</p><ul><li><p>200 OK<br>请求成功，请求的对象在这个报文后面</p></li><li><p>301 Moved Permanently<br>请求的对象已转移，新的URL在响应报文的Location:首部行中指定</p></li><li><p>400 Bad Request<br>请求报文不为服务器理解</p></li><li><p>404 Not Found<br>请求的文档没有在该服务器上发现</p></li><li><p>505 HTTP Version Not Supported</p></li></ul><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p>Cookie是一种在客户端保持HTTP状态信息的技术。</p><p>客户端访问网站时，Web服务器会查看、创建、修改Cookie资料，帮助Web站点保存访问者信息：浏览历史，购物车等。</p><p>cookie技术组成</p><ul><li><p>cookie识别码（http请求报文，http响应报文）</p></li><li><p>客户端保留cookie文件</p></li><li><p>服务器提供后端数据库</p></li></ul><p>cookie工作过程</p><p><img src="https://s2.loli.net/2022/05/10/l152vsbQLx9ESpw.png" alt="cookie.png" loading="lazy"></p><h2 id="Web缓存-代理服务器"><a href="#Web缓存-代理服务器" class="headerlink" title="Web缓存(代理服务器)"></a>Web缓存(代理服务器)</h2><ul><li><p>Web缓存器：保存最近请求过的web对象</p></li><li><p>浏览器向缓存发送所有HTTP请求</p><ul><li><p>对象在缓存中：缓存返回对象</p></li><li><p>否则缓存向起始服务器请求对象，然后向客户机返回对象</p></li></ul></li></ul><p>举例：</p><h3 id="没有缓存服务器时"><a href="#没有缓存服务器时" class="headerlink" title="没有缓存服务器时"></a>没有缓存服务器时</h3><pre class="mermaid">graph LRLAN(LAN 100Mbps)LANroute[机构路由器]A[浏览器A] --> LANrouteB[浏览器B] --> LANrouteC[浏览器C] --> LANrouteWANroute[公网路由器]LANroute -.访问链路 15Mbps.-> WANrouteWANroute --> a[起始服务器a]WANroute --> b[起始服务器b]WANroute --> c[起始服务器c]</pre><p>假定</p><ul><li><p>平均对象长度 &#x3D; 1M</p></li><li><p>来自机构的浏览器的平均请求 &#x3D; 15个&#x2F;sec</p></li><li><p>从机构路由器到任何起始服务器并返回的时延 &#x3D; 2 sec</p></li></ul><p>则</p><p>LAN端每秒发送15M请求，由于LAN信道宽度为100Mbps，访问链路信道宽度为15Mbps，故</p><ul><li><p>局域网利用率 &#x3D; 15%</p></li><li><p>访问链路利用率 &#x3D; 100%</p></li><li><p>总时延  &#x3D; LAN时延 + 访问时延 + 因特网时延 &#x3D; LAN时延 + 访问链路时延 + 2sec</p></li></ul><h3 id="有缓存服务器时"><a href="#有缓存服务器时" class="headerlink" title="有缓存服务器时"></a>有缓存服务器时</h3><pre class="mermaid">graph LRLAN(LAN 100Mbps)LANroute[机构路由器]A[浏览器A] --- LANrouteB[浏览器B] --> LANrouteC[浏览器C] --> LANrouteD((缓存服务器)) --> LANrouteWANroute[公网路由器]LANroute -.访问链路 15Mbps.-> WANrouteWANroute --> a[起始服务器a]WANroute --> b[起始服务器b]WANroute --> c[起始服务器c]</pre><p>假设命中率为0.4</p><ul><li><p>40%请求几乎立即得到满足，没有到达起始服务器的时延<br>60%请求由起始服务器满足</p></li><li><p>访问链路的利用率减少到60%</p></li></ul><p>网络平均时延大大减小</p><h2 id="条件GET"><a href="#条件GET" class="headerlink" title="条件GET"></a>条件GET</h2><p>HTTP条件Get使用的方法：</p><p>客户端向服务器发送一个包询问是否在上一次访问网站的时间后是否更改了页面</p><ul><li><p>如果服务器没有更新，不需要重新传输网页，返回304 Not Modified，客户端使用本地缓存</p></li><li><p>如果服务器对照客户端给出的时间已经更新了客户端请求的网页，则发送更新了的网页给用户。</p></li></ul><hr><h1 id="文件传输协议：FTP"><a href="#文件传输协议：FTP" class="headerlink" title="文件传输协议：FTP"></a>文件传输协议：FTP</h1><p>FTP使用双tcp连接</p><ul><li><p>第一个是控制连接，它一直持续到客户进程与服务器进程之间的会话完成为止。</p></li><li><p>另一个是数据连接，按需可以随时创建和撤消。每当一个文件传输时，就创建一个数据连接。</p></li></ul><p>控制连接被称为主连接。而数据连接被称为子连接。</p><pre class="mermaid">graph LRlocal[本地主机] --TCP控制连接 默认端口21--> remote[远程主机]remote[远程主机] --TCP数据连接 默认端口20--> local[本地主机]</pre><p>通过操作命令实现远程交互式访问。</p><hr><h1 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h1><h2 id="电子邮件系统组成"><a href="#电子邮件系统组成" class="headerlink" title="电子邮件系统组成:"></a>电子邮件系统组成:</h2><ul><li><p>用户代理</p></li><li><p>邮件服务器</p></li><li><p>简单邮件传输协议: SMTP（Simple Mail Transfer Protocol）</p></li></ul><pre class="mermaid">graph TDMSA[邮件服务器A]MSB[邮件服务器B]MSC[邮件服务器C]MSA --SMTP--> MSBMSB --SMTP---> MSCMSC --SMTP--> MSAA[用户代理] -.-> MSAB[用户代理] -.-> MSBC[用户代理] -.-> MSBMSC <-.- D[用户代理]MSC <-.- E[用户代理]MSC <-.- F[用户代理]</pre><p>Alice向Bob写信</p><ol><li>Alice<strong>使用UA写作报文</strong>并向 <a href="mailto:&#x62;&#x6f;&#98;&#x40;&#115;&#x6f;&#x6d;&#101;&#115;&#x63;&#104;&#111;&#x6f;&#108;&#46;&#x65;&#x64;&#x75;">&#x62;&#x6f;&#98;&#x40;&#115;&#x6f;&#x6d;&#101;&#115;&#x63;&#104;&#111;&#x6f;&#108;&#46;&#x65;&#x64;&#x75;</a>发送</li><li>Alice的UA向其<strong>邮件服务器</strong>发送报文；报文放置在<strong>报文队列</strong>中</li><li><strong>SMTP</strong>的客户机侧打开与Bob的邮件服务器的<strong>TCP连接</strong></li><li>SMTP通过TCP连接<strong>发送</strong>Alice的报文</li><li>Bob的邮件服务器将该报文<strong>放入Bob的邮箱</strong></li><li>Bob<strong>调用其用户代理</strong>来读报文</li></ol><pre class="mermaid">graph LRAlice === A[用户代理] --> B[邮件服务器] -.-> C[邮件服务器] --> D[用户代理] === Bob</pre><h2 id="电子邮件协议"><a href="#电子邮件协议" class="headerlink" title="电子邮件协议"></a>电子邮件协议</h2><ul><li><p>SMTP（简单邮件传输协议）：最常用的电子邮件传输协议</p></li><li><p>POP3（邮局协议）：最常用的电子邮件接收协议</p></li><li><p>IMAP4（网络邮局访问协议）：POP3的替代协议，提供邮件处理新功能</p></li></ul><p>另：HTTP协议也用于电子邮件，网页访问邮箱</p><h2 id="STMP"><a href="#STMP" class="headerlink" title="STMP"></a>STMP</h2><ul><li><p>SMTP是一个相对简单的基于文本的协议</p><ul><li><p>报文必须以7比特ASCII格式</p></li><li><p>二进值文件可通过MIME编码后再传</p></li></ul></li><li><p>SMTP服务器端使用端口号25</p></li><li><p>采用命令&#x2F;响应交互</p><ul><li><p>命令：HELO，MAIL FROM, RCPT TO, DATA, QUIT</p></li><li><p>响应：状态码及短语</p></li></ul></li><li><p>传输的三个阶段</p><p>  握手，传输，关闭</p></li></ul><h2 id="邮件报文格式"><a href="#邮件报文格式" class="headerlink" title="邮件报文格式"></a>邮件报文格式</h2><ul><li><p>首部</p><p>  头部由多个头部行构成，列出最常见的三个</p><ul><li><p>To：发给谁</p></li><li><p>From：谁发送的</p></li><li><p>Subject：邮件的主题</p></li></ul></li><li><p>空行</p></li><li><p>信体</p></li></ul><h2 id="MIME"><a href="#MIME" class="headerlink" title="MIME"></a>MIME</h2><p>多用途因特网邮件扩展不仅可以发送非英语国家字符，还可以发送其它类型的内容，例如声音、图像、图片、视频等，大大扩展了电子邮件的用途。</p><p>MIME通过添加额外的信头头部声明来实现内容的扩展。以下为一个例子：</p><p><img src="https://s2.loli.net/2022/05/10/Txz9sbuaXABdUD8.png" alt="MIME头部.png" loading="lazy"></p><pre class="mermaid">graph LR用户1 --非ASCII码--- A[MIME] --七位ASCII码--- B[SMTP] --七位ASCII码--- C[SMTP] --七位ASCII码--- D[MIME] --非ASCII码--- 用户2</pre><h2 id="邮件访问协议"><a href="#邮件访问协议" class="headerlink" title="邮件访问协议"></a>邮件访问协议</h2><p>邮件访问协议用来从邮件服务器上读取别人发来的邮件</p><pre class="mermaid">graph LR用户代理1 --SMTP--- A[邮件服务器] --SMTP--- D[邮件服务器] --邮件访问协议--- 用户代理2</pre><ul><li><p>POP3: 邮局协议 （ Post Office Protocol ）</p><p>  授权 (代理 &lt;–&gt;服务器) 并下载</p></li><li><p>IMAP4: 因特网邮件访问协议 </p><ul><li><p>更多功能</p></li><li><p>操作存储在服务器上的报文</p></li></ul></li></ul><h2 id="基于Web的电子邮件"><a href="#基于Web的电子邮件" class="headerlink" title="基于Web的电子邮件"></a>基于Web的电子邮件</h2><ul><li><p>用户代理是浏览器</p></li><li><p>使用 HTTP而不是SMTP发送到<strong>源</strong>邮件服务器</p></li><li><p>使用SMTP发送邮件到<strong>目的</strong>邮件服务器</p></li></ul><hr><h1 id="域名系统DNS"><a href="#域名系统DNS" class="headerlink" title="域名系统DNS"></a>域名系统DNS</h1><p>DNS: Domain Name System域名系统</p><p>包括DNS服务器和DNS协议</p><p>DNS完成主机名到IP地址的解析</p><ul><li><p>迭代查询</p><ul><li>客户端向本地DNS服务器发起查询:请求gaia.cs.umass.edu的IP</li><li>本地DNS向根DNS查询：.edu顶级域DNS服务器地址</li><li>根DNS回应.edu顶级域DNS服务器地址</li><li>本地DNS向.edu顶级域DNS查询.umass.edu的权威DNS服务器地址</li></ul><p>  <img src="https://s2.loli.net/2022/05/10/sMiQAPv9R25zUVa.png" alt="DNS迭代查询.png" loading="lazy"></p></li><li><p>递归查询</p><ul><li>客户端向本地DNS服务器发起查询:请求gaia.cs.umass.edu的IP</li><li>本地DNS向根DNS查询：请求gaia.cs.umass.edu的IP</li><li>根DNS向.edu顶级域DNS服务器查询：请求gaia.cs.umass.edu的IP</li><li>.edu顶级域DNS向.umass.edu的权威DNS查询：</li></ul><p>  <img src="https://s2.loli.net/2022/05/10/Ipdq7yai9YWFbgs.png" alt="DNS递归查询.png" loading="lazy"></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;进程通信&quot;&gt;&lt;a href=&quot;#进程通信&quot; class=&quot;headerlink&quot; title=&quot;进程通信&quot;&gt;&lt;/a&gt;进程通信&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在同一台主机中：两个进程使用进程间通信IPC(由操作系统定义)通信.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://sagirichan.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机网络" scheme="http://sagirichan.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="笔记" scheme="http://sagirichan.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>计网复习笔记-绪论</title>
    <link href="http://sagirichan.com/2022/05/13/computer-network-note-introduction/"/>
    <id>http://sagirichan.com/2022/05/13/computer-network-note-introduction/</id>
    <published>2022-05-13T09:27:22.000Z</published>
    <updated>2022-05-15T18:32:45.145Z</updated>
    
    <content type="html"><![CDATA[<h1 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h1><p>特征</p><ul><li><p>预留端到端资源：端系统之间通信路径上所需要的资源 (缓存，链路带宽)。建立连接。</p></li><li><p>发送方以恒定速率向接收方传送数据。</p></li><li><p>通信双方必须先建立一个专用的连接（电路），一直维持，直到通信结束。</p></li></ul><p>每个链路可有n条电路，能够支持n条同步连接。 </p><h2 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h2><p>在一条传输链路上同时建立多条连接，分别传输数据。 </p><h3 id="频分多路复用FDM"><a href="#频分多路复用FDM" class="headerlink" title="频分多路复用FDM"></a>频分多路复用FDM</h3><p>按频率划分若干频段，每个频段专用于一个连接。</p><p>带宽bandwidth：频段的宽度。如，4kHz。</p><h3 id="时分多路复用TDM"><a href="#时分多路复用TDM" class="headerlink" title="时分多路复用TDM"></a>时分多路复用TDM</h3><p>时间划分为固定区间的帧，每帧再划分为固定数量的时隙，每一个时隙专用于一个连接，用于传输数据。</p><h1 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h1><p>特征</p><ul><li><p>每个端到端数据流划分为分组，每个分组使用全部链路带宽。</p></li><li><p>将用户通信的数据划分成多个更小的等长数据段，在每个数据段的前面加上必要的控制信息作为数据段的首部，每个带有首部的数据段就构成了一个分组。</p></li><li><p>节点在转发前接收完整的分组</p></li></ul><p>分组交换的本质就是存储转发，它将所接受的分组暂时存储下来，在目的方向路由上排队，当它可以发送信息时，再将信息发送到相应的路由上，完成转发。</p><h2 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h2><p>传输<code>L</code>个比特，链路速率<code>R</code>bps，则时间为 $\frac{L}{R}$</p><p>在分组能向下一段链路传输前，整个分组必须到达路由器：存储转发</p><p>举例：</p><pre class="mermaid">graph LRsource[源] --R--> route((路由)) --R--> route2((路由)) --R--> destination[目的地]data(数据包L)</pre><p>时延：$\frac{3L}{R}$</p><ul><li><p>数据报网络：</p><ul><li><p>分组中的目的地址决定下一跳</p></li><li><p>在会话中路由可以变化</p></li></ul></li><li><p>虚电路网络：</p><ul><li><p>每个分组携带标签(虚电路ID)，标签决定下一跳</p></li><li><p>固定的路径在呼叫建立时决定，在呼叫期间保持不变</p></li></ul></li></ul><h1 id="带宽与时延"><a href="#带宽与时延" class="headerlink" title="带宽与时延"></a>带宽与时延</h1><h2 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h2><p>在模拟信号中的本义是指构成一信号的各种不同频率成分所占据的频率范围</p><p>现在“带宽”是数字信道所能传送的“最高数据率”的同义语。</p><h2 id="比特率"><a href="#比特率" class="headerlink" title="比特率"></a>比特率</h2><p>数字信道传送数字信号的速率，单位是比特每秒（bps）</p><p>“带宽”与“速率”：一条通信线路的“频带宽度”越宽，其所传输数据的“最高数据率”也越高。</p><h2 id="吞吐率"><a href="#吞吐率" class="headerlink" title="吞吐率"></a>吞吐率</h2><p>吞吐率表示在单位时间内通过某个网络（或信道、接口）的数据量。</p><p>更经常地用于对现实世界中的网络的一种测量</p><h2 id="延时delay"><a href="#延时delay" class="headerlink" title="延时delay"></a>延时delay</h2><p>把一个报文从网络一端传输到另一端所需的时间。</p><blockquote><p>延迟&#x3D; 处理＋排队＋发送＋传播</p></blockquote><p>处理时延：主机或路由器处理所收到的分组的时间。检查包首部、决定导向何处、比特差错检测等。</p><p>排队时延：分组在输入队列中排队等待处理，在输出队列中等待转发。等待输出链路空闲，与当时流量和排队规则有关</p><blockquote><p><em>排队时延补充</em></p><blockquote><p>L&#x3D; 分组长度 (比特)<br>a&#x3D; 平均分组到达速率<br>R&#x3D; 链路带宽 (bps)</p></blockquote><p><strong>流量强度 &#x3D; $\frac{La}{R}$</strong></p><p>$\frac{La}{R}$ ~ 0：平均排队时延小</p><p>$\frac{La}{R}$ &lt; 1：有平均排队时延</p><p>$\frac{La}{R}$ &gt; 1：数据到达速率超过链路处理能力，平均排队时延无穷大</p></blockquote><blockquote><p><em>分组丢失</em><br>结点的缓存<em>buffer</em>有限，当分组到达满的队列时，分组被丢弃(又称为lost)<br>丢失的分组可能由前面的节点或由源端系统重传，也可能不重传</p></blockquote><p>发送时延：也叫传输时延，将数据包从结点推出到链路中所用的时间。发送时延&#x3D;$\frac{数据长度(b)}{信道带宽(bps)}$</p><p>传播时延：电磁波在信道中需要传播一定的距离而花费的时间。信号传播距离d，传播速度s：传播时延&#x3D;$\frac{d}{s}$</p><h2 id="RTT-Round-Trip-Time"><a href="#RTT-Round-Trip-Time" class="headerlink" title="RTT (Round-Trip Time)"></a>RTT (Round-Trip Time)</h2><p>往返时延。表示从发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后便立即发送确认），总共经历的时延。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;电路交换&quot;&gt;&lt;a href=&quot;#电路交换&quot; class=&quot;headerlink&quot; title=&quot;电路交换&quot;&gt;&lt;/a&gt;电路交换&lt;/h1&gt;&lt;p&gt;特征&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;预留端到端资源：端系统之间通信路径上所需要的资源 (缓存，链路带宽)。建立连接。&lt;/p</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://sagirichan.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机网络" scheme="http://sagirichan.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="笔记" scheme="http://sagirichan.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>纱雾与Y同学</title>
    <link href="http://sagirichan.com/2022/04/30/sagiri-and-Miss-Y/"/>
    <id>http://sagirichan.com/2022/04/30/sagiri-and-Miss-Y/</id>
    <published>2022-04-30T09:34:33.000Z</published>
    <updated>2022-04-30T15:53:53.445Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这个故事的灵感来源于我——一个自闭阿宅——的一个<del>有关青春期幻想的</del>梦。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这个故事的灵感来源于我——一个自闭阿宅——的一个&lt;del&gt;有关青春期幻想的&lt;/del&gt;梦。&lt;/p&gt;
&lt;/blockquote&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>如何把博客部署在云服务器上？</title>
    <link href="http://sagirichan.com/2022/04/30/blog-on-cloud/"/>
    <id>http://sagirichan.com/2022/04/30/blog-on-cloud/</id>
    <published>2022-04-30T05:20:46.000Z</published>
    <updated>2022-05-15T19:05:30.970Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前言<br>在我的另一篇文章<a href="http://sagirichan.com/2022/01/25/my-own-website/">关于我想要拥有自己的网站这件事</a>中，我搭建了一个基于<a href="https://pages.github.com/">GitHub Pages</a>的博客网站，并且备案成功，为网站迁移做好了前期准备。</p><p>本来这篇文章我是与上面那篇合在一起写的，然而，由于网上教程的不完善<del>以及我的猪鼻</del>，我搞了好久才成功把网站部署到了服务器上，期间踩了无数稀奇古怪的坑，跟随着部署过程一起写的这篇文章也随之变得冗长臃肿，于是我认为这么屑的部署过程有必要单开一帖记录。</p></blockquote><p>参考文章：</p><p><a href="https://blog.csdn.net/TyCoding/article/details/80480541">Nginx搭建基于Hexo的Blog</a></p><p><a href="https://blog.csdn.net/shuqinkissshot/article/details/123201682">基于Hexo+Nginx+Git在云服务器上搭建个人网站</a></p><p><a href="https://blog.csdn.net/kengkeng123qwe/article/details/124471586">【hexo博客搭建】将搭建好的hexo博客部署到阿里云服务器上面(下)</a></p><h1 id="讲一讲整体思路"><a href="#讲一讲整体思路" class="headerlink" title="讲一讲整体思路"></a>讲一讲整体思路</h1><p>很多教程都有个共同的问题，就是只讲要做什么，而不讲为什么做。这就导致读者读完教程后知其然而不知其所以然，甚至对于一些粗制滥造胡乱抄袭的教程，读完以后连其所以然都不知。</p><p>所以我想在我的博客的开头简单介绍一下部署的思路，让读者（如果有的话）在后续的部署过程中能明白自己在干什么，而不是如盲人摸象一般被动地跟着教程模仿，出了问题都不知道出在哪。这对我自己来说也是重新审视知识的过程。</p><p><del>当然读者也可以直接跳过这一部分，这并不会影响部署结果。</del></p><h2 id="本地要做哪些准备？"><a href="#本地要做哪些准备？" class="headerlink" title="本地要做哪些准备？"></a>本地要做哪些准备？</h2><p>在本地配置hexo并生成<code>网站静态文件</code>，生成的静态文件将通过<code>git</code>工具推送到服务器（或github等任意我们想要部署到的地方）。</p><h2 id="云端要做些什么"><a href="#云端要做些什么" class="headerlink" title="云端要做些什么"></a>云端要做些什么</h2><p>在云端我们做了两个工作：</p><ul><li><p>部署nginx，它将帮助你把网站的静态文件变成可以访问的网站。</p></li><li><p>安装git（对于云服务器来说这一步通常已经完成了），建立一个git仓库，用来接收从本地推送的网站静态文件，并利用<code>hook</code>（钩子）工具将其转移到nginx的托管目录下。</p></li></ul><h2 id="还有别的吗"><a href="#还有别的吗" class="headerlink" title="还有别的吗"></a>还有别的吗</h2><p>建立云服务器与本地的SSH连接，这样我们在使用git向服务器推送网站静态文件时就不必每次都要输入云服务器的用户密码了，可以和向github推送代码一样直接。</p><h1 id="开始干活"><a href="#开始干活" class="headerlink" title="开始干活"></a>开始干活</h1><h2 id="本地"><a href="#本地" class="headerlink" title="本地"></a>本地</h2><p><a href="http://sagirichan.com/2022/01/25/my-own-website/">关于我想要拥有自己的网站这件事</a></p><h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><h3 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h3><p>安装nginx</p><blockquote><p>apt install nginx</p></blockquote><p>查看nginx版本</p><blockquote><p>nginx -v</p></blockquote><p>启动nginx</p><blockquote><p>service nginx start</p></blockquote><p>在浏览器输入服务器的公网IP便可以看到nginx的欢迎页面。</p><p><img src="https://s2.loli.net/2022/04/29/gmZ6RErIefAU9Wo.png" alt="welcome-to-nginx.png" loading="lazy"></p><p>为nginx创建用来存放网站静态文件的文件夹</p><blockquote><p>mkdir -p &#x2F;var&#x2F;www&#x2F;hexo<br>#教程里都写这个目录，虽然不知道是否有什么深意，但还是跟着做了<br>#-p 确保目录名称存在，不存在的就建一个。</p></blockquote><p>修改目录所有者</p><blockquote><p><code>chown -R $USER:$USER /var/www/hexo</code><br>#这里的$USER填<a href="https://zhuanlan.zhihu.com/p/105482468">用户名</a><br>#这里我使用的是腾讯云服务器ubuntu实例的默认用户名<code>ubuntu</code><br>#因此这里我是这样写的：chown -R ubuntu:ubuntu &#x2F;var&#x2F;repo&#x2F;<br>#当然也有教程是建立了一个git用户，这样更规范，也推荐使用<br>#<code>-R</code>参数表示递归处理，将指定目录下的所有文件及子目录一并处理<br>#<code>USER:USER</code>中，前一个USER是指用户名，后一个USER是指用户所属的群组</p></blockquote><p>修改目录权限</p><blockquote><p>chmod -R 755 &#x2F;var&#x2F;www&#x2F;hexo<br>#chmod 755 设置用户的权限为：<br>#1.文件所有者可读可写可执行<br>#2.与文件所有者同属一个用户组的其他用户可读可执行<br>#3.其它用户组可读可执行</p></blockquote><p>修改Nginx的<code>default</code>文件使得<code>root</code>指向刚刚创建的<code>/var/www/hexo</code>目录：</p><blockquote><p>vim &#x2F;etc&#x2F;nginx&#x2F;sites-available&#x2F;default</p></blockquote><p>在server大括号中，添加如图所示的一句话：</p><blockquote><p>root &#x2F;var&#x2F;www&#x2F;hexo;</p></blockquote><p><img src="https://s2.loli.net/2022/04/30/Rw7zbuLlJ3IOK8Z.png" alt="修改nginx的default文件.png" loading="lazy"></p><p>重启nginx服务。</p><blockquote><p>service nginx restart</p></blockquote><h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><p>建立一个git仓库目录</p><blockquote><p>mkdir &#x2F;var&#x2F;repo&#x2F; </p></blockquote><p>修改目录权限</p><blockquote><p><code>chown -R $USER:$USER /var/repo/</code><br>#这里目录所有者与上文nginx静态文件目录所有者相同，我是<code>ubuntu</code>.<br>chmod -R 755 &#x2F;var&#x2F;repo&#x2F;</p></blockquote><p>将这个仓库初始化</p><blockquote><p>cd &#x2F;var&#x2F;repo<br>git init –bare hexoblog.git<br>#参考文章：<a href="https://blog.csdn.net/sinat_34349564/article/details/52487860">git init 与git init –bare</a></p></blockquote><p>配置hook（钩子）文件</p><blockquote><p>vim &#x2F;var&#x2F;repo&#x2F;myblog.git&#x2F;hooks&#x2F;post-receive<br>#git post-receive机制：这个hook是git服务器在受到push请求时，并且接受完代码提交时触发<br>#参考：<a href="https://www.imqianduan.com/git-svn/335.html">使用git hooks(post-receive)实现简单的远程自动部署</a><br>#不会用vim可以看一看简单指令-&gt;<a href="https://www.runoob.com/linux/linux-vim.html">Linux vi&#x2F;vim</a></p></blockquote><p>打开文件后在其中输入：</p><pre><code>#!/bin/bashgit --work-tree=/var/www/hexo --git-dir=/var/repo/hexoblog.git checkout -f</code></pre><blockquote><p>参考文章：<br><a href="https://www.cnblogs.com/Jerryshome/archive/2011/12/15/2289218.html">Git系列之二 — git-dir &amp; work-tree</a><br><a href="https://blog.csdn.net/weixin_44567318/article/details/110099081">git checkout 检出命令——自由切换分支&amp;恢复文件</a></p></blockquote><p>保存后修改权限</p><blockquote><p>chmod +x &#x2F;var&#x2F;repo&#x2F;myblog.git&#x2F;hooks&#x2F;post-receive<br>#参考文章：<a href="https://blog.csdn.net/yzh_1346983557/article/details/92571987">chmod +x，赋予“可执行”权限</a></p></blockquote><h2 id="本地与云端建立SSH连接"><a href="#本地与云端建立SSH连接" class="headerlink" title="本地与云端建立SSH连接"></a>本地与云端建立SSH连接</h2><ul><li><p>如果你注册过github，那你大概率曾经生成过公钥，查看（Windows）电脑是否有<code>C/Users/Administrator/.ssh/</code>文件夹，如果有的话，文件夹下<code>id_rsa.pub</code>就是你的公钥。</p><p>  P.S. Linux系统的公钥在<code>~/.ssh/id_rsa.pub</code>文件中。</p><p>  使用</p><blockquote><p>ssh-copy-id [用户名]@[云服务器IP]</p></blockquote><p>  向云服务器传送公钥。</p><p>  举个例子，假设我的云服务IP是<code>10.10.10.10</code>，我要向服务器上<code>sagiri</code>用户传送公钥，那么我就使用</p><blockquote><p>ssh-copy-id <a href="mailto:&#115;&#x61;&#x67;&#x69;&#114;&#105;&#x40;&#x31;&#48;&#x2e;&#49;&#x30;&#46;&#x31;&#x30;&#x2e;&#x31;&#48;">&#115;&#x61;&#x67;&#x69;&#114;&#105;&#x40;&#x31;&#48;&#x2e;&#49;&#x30;&#46;&#x31;&#x30;&#x2e;&#x31;&#48;</a></p></blockquote><p>  指令。</p><p>  由于我们之前配置仓库时，<code>git仓库</code>的所有者和<code>nginx静态文件目录</code>的所有者我都填了<code>ubuntu</code>，所以这里的用户名当然也是<code>ubuntu</code>.</p><p>  这里需要输入一次用户密码。</p></li><li><p>如果电脑上没有<code>C/Users/Administrator/.ssh/</code>文件夹，那么就使用</p><blockquote><p>ssh-keygen</p></blockquote><p>  指令先生成一个公钥，然后再用</p><blockquote><p>ssh-copy-id [用户名]@[云服务器IP]<br>#命令讲解见上文</p></blockquote><p>  传送公钥。</p></li></ul><h2 id="修改hexo配置文件"><a href="#修改hexo配置文件" class="headerlink" title="修改hexo配置文件"></a>修改hexo配置文件</h2><p>回到我们的本地，打开hexo文件夹下的<code>_config.yml</code>文件进行配置</p><ul><li><p>找到<code>url</code>字段，将其配置为</p><blockquote><p>url: http:&#x2F;&#x2F;[服务器IP|服务器网址]&#x2F;</p></blockquote><p>  举例：我的服务器公网IP为<code>101.33.208.50</code>，挂载在我的服务器上的域名为<code>sagirichan.com</code>，那么这里可以填</p><blockquote><p>url: <a href="http://101.33.208.50/">http://101.33.208.50/</a></p></blockquote><p>  也可以填</p><blockquote><p>url: <a href="http://sagirichan.com/">http://sagirichan.com/</a></p></blockquote></li><li><p>找到<code>deploy</code>字段，参考下图进行配置：</p><p>  <img src="https://s2.loli.net/2022/04/30/ES9At32dGJZNsjQ.png" alt="deploy配置.png" loading="lazy"></p><p>  解释：</p><ul><li><p><code>type</code>字段是推送网页文件的方式，我们用的是git，所以这里填<code>git</code>.</p></li><li><p><code>repo</code>是代码仓库的位置，格式为</p><blockquote><p><code>仓库名称</code>: <code>仓库用户名</code>@<code>仓库位置</code></p></blockquote><p>  我使用了两个仓库，一个是我本次部署在云端的仓库，另一个是我在初学搭建网站时部署在github上的仓库。</p><p>  以云端仓库为例</p><ul><li><p><code>仓库名称</code>可以随便取，我的服务器来自腾讯云，所以我取名为<code>tencentCloud</code></p></li><li><p><code>仓库用户名</code>字段，由于部署时我设置的云端<code>git仓库</code>的所有者为<code>ubuntu</code>，所以这里也是<code>ubuntu</code>.</p></li><li><p><code>仓库位置</code>字段，即是之前部署时设置的仓库位置。</p></li></ul><p>  github仓库格式同理<del>而且搭建网站的教程百分之九十九都会讲这个的</del></p></li><li><p>对于deploy字段，除了展示的关键词，还有<code>branch</code>、<code>message</code>等关键词可供选择<del>但是我嫌麻烦就没有继续深入研究了</del>。</p><p>  <img src="https://s2.loli.net/2022/05/01/URreFvp7zLquGbX.png" alt="deploy补充.png" loading="lazy"></p></li></ul></li></ul><h1 id="万事俱备"><a href="#万事俱备" class="headerlink" title="万事俱备"></a>万事俱备</h1><p>在hexo文件夹下打开终端（vscode、power shell、git bash等等任意终端），输入<code>hexo三连</code>：</p><blockquote><p>hexo clean<br>hexo g<br>hexo d<br>#g是generation，生成网页文件<br>#d是deploy，发布网站。实际上deploy命令是将网页文件推送到远程仓库中。参考<a href="https://hexo.io/zh-cn/docs/one-command-deployment#%E8%BF%99%E4%B8%80%E5%88%87%E6%98%AF%E5%A6%82%E4%BD%95%E5%8F%91%E7%94%9F%E7%9A%84%EF%BC%9F">这一切是如何发生的？</a>。</p></blockquote><p>或者也可以简化为两连：</p><blockquote><p>hexo clean<br>hexo g -d</p></blockquote><p>如果终端支持的话，还可以写进一行：</p><blockquote><p>hexo clean &amp;&amp; hexo g -d</p></blockquote><p>然后在浏览器地址栏中输入云服务器的公网IP或者绑定的域名（如果有的话），我们就可以访问到自己的网站啦。</p><p><img src="https://s2.loli.net/2022/05/01/fBLxY8jW3vz2lRi.png" alt="网站首页.png" loading="lazy"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;前言&lt;br&gt;在我的另一篇文章&lt;a href=&quot;http://sagirichan.com/2022/01/25/my-own-website/&quot;&gt;关于我想要拥有自己的网站这件事&lt;/a&gt;中，我搭建了一个基于&lt;a href=&quot;https://pages</summary>
      
    
    
    
    
    <category term="hexo" scheme="http://sagirichan.com/tags/hexo/"/>
    
    <category term="nginx" scheme="http://sagirichan.com/tags/nginx/"/>
    
    <category term="git" scheme="http://sagirichan.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>git-learning</title>
    <link href="http://sagirichan.com/2022/04/24/git-learning/"/>
    <id>http://sagirichan.com/2022/04/24/git-learning/</id>
    <published>2022-04-24T12:50:24.000Z</published>
    <updated>2022-05-15T15:50:49.214Z</updated>
    
    <content type="html"><![CDATA[<ul><li>git stash提示xx文件: needs merge</li></ul><p>使用<code>git add .</code></p><ul><li>vscode解决冲突</li></ul><p><code>Current Change</code>是新代码，<code>Incoming Change</code>是旧代码。</p><ul><li>error: The following untracked working tree files would be overwritten by merge:</li></ul><p><code>git clean -d -fx</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;git stash提示xx文件: needs merge&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用&lt;code&gt;git add .&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;vscode解决冲突&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Current Change&lt;/cod</summary>
      
    
    
    
    
    <category term="git" scheme="http://sagirichan.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Powerdesigner安装、破解、汉化</title>
    <link href="http://sagirichan.com/2022/03/20/powerdesigner-guide/"/>
    <id>http://sagirichan.com/2022/03/20/powerdesigner-guide/</id>
    <published>2022-03-20T11:20:59.000Z</published>
    <updated>2022-05-15T15:45:36.202Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>参考链接：<br>  <a href="https://www.cnblogs.com/huangting/p/12654057.html">PowerDesigner 安装+汉化+破解+使用过程</a><br>  <a href="https://zhuanlan.zhihu.com/p/179260147">PowerDesigner安装教程</a></p></blockquote><h1 id="Powerdesigner-安装"><a href="#Powerdesigner-安装" class="headerlink" title="Powerdesigner 安装"></a>Powerdesigner 安装</h1><h2 id="Powerdesigener-工具包下载"><a href="#Powerdesigener-工具包下载" class="headerlink" title="Powerdesigener 工具包下载"></a>Powerdesigener 工具包下载</h2><p>下载链接：<a href="https://pan.baidu.com/s/1qznLBQvkjiCKcmHBnsSRZg">https://pan.baidu.com/s/1qznLBQvkjiCKcmHBnsSRZg</a><br>提取码：jdt5</p><h2 id="Powerdesigener-安装"><a href="#Powerdesigener-安装" class="headerlink" title="Powerdesigener 安装"></a>Powerdesigener 安装</h2><ul><li>点击安装文件进入安装界面。</li></ul><p><img src="https://s2.loli.net/2022/03/20/DE7pWmSOFNgGqJi.png" alt="点击安装文件.png" loading="lazy"></p><p><img src="https://s2.loli.net/2022/03/20/EuvMrHRBO2fjg3p.png" alt="安装界面.png" loading="lazy"></p><ul><li>选择方框中选项（默认选项）</li></ul><p><img src="https://s2.loli.net/2022/03/20/Grn2Dg5BYM9tRiq.png" alt="licenceType.png" loading="lazy"></p><ul><li>选择国家或地区。</li></ul><p><img src="https://s2.loli.net/2022/03/20/s8kl32mDCIgynjL.png" alt="location.png" loading="lazy"></p><ul><li>同意软件使用许可证。</li></ul><p><img src="https://s2.loli.net/2022/03/20/QwUD62pZuiTq4xk.png" alt="IAgree.png" loading="lazy"></p><ul><li>选择安装位置</li></ul><p><img src="https://s2.loli.net/2022/03/20/86vdjUotm2uROEQ.png" alt="选择安装位置.png" loading="lazy"></p><ul><li>选择插件，这里保持默认设置，直接next就行。</li></ul><p><img src="https://s2.loli.net/2022/03/20/zn43ZON8WrVMF6C.png" alt="features.png" loading="lazy"></p><ul><li>这里全选。</li></ul><p><img src="https://s2.loli.net/2022/03/20/DFneVpXOAcgdxrb.png" alt="profiles.png" loading="lazy"></p><ul><li>记住文件路径，next。</li></ul><p><img src="https://s2.loli.net/2022/03/20/s9NXednp5oMhiHF.png" alt="programfolders.png" loading="lazy"></p><ul><li>检查一下自己的设置，没有问题就next。</li></ul><p><img src="https://s2.loli.net/2022/03/20/sMaJm5coHYEB3wN.png" alt="check.png" loading="lazy"></p><ul><li>等待安装</li></ul><p><img src="https://s2.loli.net/2022/03/20/bCBI5cZMTUdki3f.png" alt="installing.png" loading="lazy"></p><ul><li>安装完成</li></ul><p><img src="https://s2.loli.net/2022/03/20/pUME2GJ6TgZYjOt.png" alt="installed.png" loading="lazy"></p><h2 id="Powerdesigener-破解"><a href="#Powerdesigener-破解" class="headerlink" title="Powerdesigener 破解"></a>Powerdesigener 破解</h2><ul><li>在破解软件文件夹中找到pdflm 16.dll。</li></ul><p><img src="https://s2.loli.net/2022/03/20/bWL9yjuiaqfJnlt.png" alt="破解dll.png" loading="lazy"></p><p>将其覆盖到Powerdesigner的安装目录中</p><p><img src="https://s2.loli.net/2022/03/20/YKnRMyNdPC31aQX.png" alt="覆盖破解文件.png" loading="lazy"></p><h2 id="Powerdesigener-汉化"><a href="#Powerdesigener-汉化" class="headerlink" title="Powerdesigener 汉化"></a>Powerdesigener 汉化</h2><ul><li>打开汉化包文件夹</li></ul><p><img src="https://s2.loli.net/2022/03/20/RhvwzC5HkeAnIjr.png" alt="汉化文件.png" loading="lazy"></p><ul><li>全选并覆盖到Powerdesigner安装目录中</li></ul><p><img src="https://s2.loli.net/2022/03/20/14zZnBmMjCqJNat.png" alt="全选.png" loading="lazy"></p><p><img src="https://s2.loli.net/2022/03/20/p5TI6hOmM7ZwkSi.png" alt="覆盖汉化文件.png" loading="lazy"></p><hr><hr><p>点击PdShell16.exe即可启动软件，如果不能启动，则使用pdlegacyshell16.exe文件。</p><p><img src="https://s2.loli.net/2022/03/20/OzuANBIX1CbWeM9.png" alt="启动文件.png" loading="lazy"></p><p>为了方便，也可以在桌面上创建一个快捷方式</p><p><img src="https://s2.loli.net/2022/03/20/Bk4m7lcUSXfrb3p.png" alt="快捷方式.png" loading="lazy"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;参考链接：&lt;br&gt;  &lt;a href=&quot;https://www.cnblogs.com/huangting/p/12654057.html&quot;&gt;PowerDesigner 安装+汉化+破解+使用过程&lt;/a&gt;&lt;br&gt;  &lt;a href=&quot;https:/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>navicat v15破解版安装手册</title>
    <link href="http://sagirichan.com/2022/03/12/navicat-install-guide/"/>
    <id>http://sagirichan.com/2022/03/12/navicat-install-guide/</id>
    <published>2022-03-12T08:53:30.000Z</published>
    <updated>2022-05-15T15:46:04.783Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>参考链接：<a href="https://cloud.tencent.com/developer/article/1804255">Navicat Premium 15安装教程(完整激活版)</a></p></blockquote><h1 id="navicat下载"><a href="#navicat下载" class="headerlink" title="navicat下载"></a>navicat下载</h1><hr><ul><li><strong>navicat官网地址：<a href="https://navicat.com.cn/">https://navicat.com.cn/</a>，我们主张在力所能及的情况下支持正版。</strong></li></ul><hr><p>Navicat Premium 15与Navicat Premium 15注册机下载链接：<a href="https://pan.baidu.com/s/1DL9_UYY3agUHPn3mjoOViQ#list/path=%2F">https://pan.baidu.com/s/1DL9_UYY3agUHPn3mjoOViQ#list&#x2F;path&#x3D;%2F</a><br>提取码：0d8b</p><h1 id="navicat安装"><a href="#navicat安装" class="headerlink" title="navicat安装"></a>navicat安装</h1><ul><li>直接点击下载下来的<code>navicat150_premium_cs_x64.exe</code>文件，进入安装界面。点击<code>下一步</code>开始安装。</li></ul><p><img src="https://s2.loli.net/2022/03/12/fCXF4wtq1K7zvhU.png" alt="安装.png" loading="lazy"></p><ul><li>选择<code>我同意</code>、<code>下一步</code>。</li></ul><p><img src="https://s2.loli.net/2022/03/12/yF2zf74sMkUcwBj.png" alt="同意许可证.png" loading="lazy"></p><ul><li>自定义安装目录。</li></ul><p><img src="https://s2.loli.net/2022/03/12/zjya9TIB7VpSuDC.png" alt="安装位置.png" loading="lazy"></p><ul><li>一路点击<code>下一步</code>，直到出现“准备安装”界面，点击<code>安装</code>，等待安装完毕。</li></ul><p><img src="https://s2.loli.net/2022/03/12/rbOgUCEyZ26VNme.png" alt="快捷方式 .png" loading="lazy"></p><p><img src="https://s2.loli.net/2022/03/12/jryncoDfxYCZlS1.png" alt="创建桌面图标.png" loading="lazy"></p><p><img src="https://s2.loli.net/2022/03/12/MrNUkVaJeEOlv8w.png" alt="准备安装.png" loading="lazy"></p><p><img src="https://s2.loli.net/2022/03/12/azhtEeIixZJMXUP.png" alt="等待安装.png" loading="lazy"></p><p><img src="https://s2.loli.net/2022/03/12/QoDcbxaeAhR4BTs.png" alt="安装完成.png" loading="lazy"></p><h1 id="navicat破解"><a href="#navicat破解" class="headerlink" title="navicat破解"></a>navicat破解</h1><blockquote><p>使用注册机时建议退出杀毒软件，并且不要打开navicat。</p></blockquote><ul><li>双击注册机文件<code>Navicat Keygen Patch v5.6.0 DFoX.exe</code>运行。</li></ul><p><img src="https://s2.loli.net/2022/03/12/XmQMKJUOwoahx5b.png" alt="双击注册机文件.png" loading="lazy"></p><p><img src="https://s2.loli.net/2022/03/12/bLYw7kj96Gxidyf.png" alt="注册机.png" loading="lazy"></p><ul><li>在<code>1) Patch</code>栏选择<code>Backup</code>、<code>Host</code>、<code>Navicat v15</code>三个选项（默认也是这三个选项）并且点击<code>Patch</code>，找到在navicat安装目录下的<code>navicat.exe</code>文件。</li></ul><p><img src="https://s2.loli.net/2022/03/12/NYBtFOoZClLxX3v.png" alt="1_patch.png" loading="lazy"></p><p><img src="https://s2.loli.net/2022/03/12/23fRWTI5hcjJCxp.png" alt="patch到exe文件.png" loading="lazy"></p><p>出现下图即说明patch成功。</p><p><img src="https://s2.loli.net/2022/03/12/OJA5EZ6Kp7TCmP1.png" alt="patch成功.png" loading="lazy"></p><ul><li>在<code>2) License. Product and Language</code>中，<code>License</code>选择<code>Enterprise</code>，<code>Produce</code>选择<code>Premium</code>，<code>Languages</code>选择<code>Simplified Chinese</code>。<br>在<code>3)Resale License</code>中，<code>Resale Versions</code>选择<code>Site license</code>。<br>P.S. 以上都是默认设置。</li></ul><p><img src="https://s2.loli.net/2022/03/12/BI5hnswedxMPtaC.png" alt="2_3_.png" loading="lazy"></p><ul><li>在<code>4) Keygen / Offline Activation</code>中点击第一行右侧<code>Generate</code>按钮，在左边<code>Serial Keygen</code>栏便会生成一个许可证密钥，点击<code>Copy</code>复制。</li></ul><p><img src="https://s2.loli.net/2022/03/12/UJejSGQ9dTWa1kx.png" alt="4_keygen.png" loading="lazy"></p><ul><li>打开navicat软件，点击<code>注册</code>。</li></ul><p><img src="https://s2.loli.net/2022/03/12/p3UymZG8bjMCfAa.png" alt="点击注册.png" loading="lazy"></p><ul><li>在左侧粘贴许可证密钥，并且点击<code>激活</code>。</li></ul><p><img src="https://s2.loli.net/2022/03/12/iSnPNYxwRktUWH8.png" alt="粘贴许可证密钥.png" loading="lazy"></p><ul><li>提示激活服务器不可使用，选择手动激活。</li></ul><p><img src="https://s2.loli.net/2022/03/12/kgXuRPyIsSJAfic.png" alt="手动激活.png" loading="lazy"></p><p>产生一个请求码。</p><p><img src="https://s2.loli.net/2022/03/12/2M6PmLgu3wBS49j.png" alt="生成请求码.png" loading="lazy"></p><ul><li>将请求码填入<code>Request Code</code>中，并点击左下方<code>Activation Code</code>中的<code>Generate</code>按钮，注册机便会自动生成一个激活码并填入navicat的注册码框中。</li></ul><p><img src="https://s2.loli.net/2022/03/12/SkMTE1vjYKel7mt.png" alt="填入激活码.png" loading="lazy"></p><p>点击激活，激活成功。</p><p><img src="https://s2.loli.net/2022/03/12/E9ykxcVtsXrGWmB.png" alt="激活成功.png" loading="lazy"></p><p>如图。</p><p><img src="https://s2.loli.net/2022/03/12/2kVfx7N8ULpPTob.png" alt="激活成功2.png" loading="lazy"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;参考链接：&lt;a href=&quot;https://cloud.tencent.com/developer/article/1804255&quot;&gt;Navicat Premium 15安装教程(完整激活版)&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 i</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MySQL安装与配置（免安装版）</title>
    <link href="http://sagirichan.com/2022/03/02/MySQL-guide/"/>
    <id>http://sagirichan.com/2022/03/02/MySQL-guide/</id>
    <published>2022-03-02T06:03:43.000Z</published>
    <updated>2022-05-15T15:44:29.650Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>参考链接：<a href="https://www.cnblogs.com/winton-nfs/p/11524007.html">MySQL的安装与配置——详细教程</a></p></blockquote><h1 id="MySQL下载"><a href="#MySQL下载" class="headerlink" title="MySQL下载"></a>MySQL下载</h1><ul><li>在浏览器地址栏中输入<code>mysql.com</code>，点击回车，进入MySQL官网首页。</li></ul><p><img src="https://s2.loli.net/2022/02/28/yJNsq2behBYl5fE.png" alt="mysql官网首页.png" loading="lazy"></p><ul><li>将页面拉到最底部，寻找到<code>Downloads</code>下的<code>MySQL Community Server</code>链接，点击，进入下载页面。</li></ul><p><img src="https://s2.loli.net/2022/02/28/gFxf2ZnVzbTPGmS.png" alt="首页底部2.png" loading="lazy"></p><ul><li>操作系统选择Microsoft Windows。</li></ul><p><img src="https://s2.loli.net/2022/02/28/cJN4PXuhCMfRQ1r.png" alt="选择操作系统.png" loading="lazy"></p><ul><li>在下方选择免安装版，点击Download按钮。</li></ul><p><img src="https://s2.loli.net/2022/02/28/TPZIJkLRSY6mqlc.png" alt="选择免安装版2.png" loading="lazy"></p><ul><li>选择No thanks，当然有兴趣的话也可以使用已有的或者注册一个Oracle账户登录，笔者这里不再添足。</li></ul><p><img src="https://s2.loli.net/2022/02/28/vPiyMrnu9OYqlf5.png" alt="nothanks2.png" loading="lazy"></p><p>保存路径避免出现中文。</p><p><img src="https://s2.loli.net/2022/02/28/4prCNBZdT1i6QPI.png" alt="保存.png" loading="lazy"></p><p>下载完成后解压。</p><p><img src="https://s2.loli.net/2022/02/28/amuCRAFybBWOdPc.png" alt="解压.png" loading="lazy"></p><h1 id="MySQL安装与配置"><a href="#MySQL安装与配置" class="headerlink" title="MySQL安装与配置"></a>MySQL安装与配置</h1><h2 id="MySQL安装"><a href="#MySQL安装" class="headerlink" title="MySQL安装"></a>MySQL安装</h2><ul><li>使用<code>win+R</code>快捷键打开<code>运行</code>并输入<code>cmd</code>。</li></ul><p><img src="https://s2.loli.net/2022/02/28/Fz4oksUQiXOAvNm.png" alt="cmd.png" loading="lazy"></p><ul><li>使用<code>Ctrl+shift+Enter</code>快捷键，以管理员模式运行cmd。</li></ul><p><img src="https://s2.loli.net/2022/02/28/OfYh7BE6AvQqr21.png" alt="是否允许管理员模式.png" loading="lazy"></p><p>选择<code>是</code>即可。</p><p><img src="https://s2.loli.net/2022/02/28/bP4XHmfpDWM8cuU.png" alt="管理员cmd.png" loading="lazy"></p><ul><li>进入解压后的文件夹中的<code>bin</code>目录下。</li></ul><p><img src="https://s2.loli.net/2022/03/02/oBM1OKrj49JZPnF.png" alt="bin目录.png" loading="lazy"></p><p><img src="https://s2.loli.net/2022/03/02/xUG9ty8B5laibfr.png" alt="进入bin.png" loading="lazy"></p><ul><li>安装MySQL服务：<code>mysqld --install</code></li></ul><p><img src="https://s2.loli.net/2022/03/02/ORdBmnq3VSkiIhr.png" alt="安装MySQL服务.png" loading="lazy"></p><p>安装成功后会出现如图所示的提示<code>Service successfully installed.</code></p><ul><li>使用<code>mysqld --initialize --console</code>初始化MySQL</li></ul><p><img src="https://s2.loli.net/2022/03/02/CFLsbU7yvXfNJ3w.png" alt="初始化MySQL.png" loading="lazy"></p><p>最后一行给出了本次初始化生成的随机密码：<code>-hdJ-+c%#75_</code></p><ul><li>使用<code>net start mysql</code>启动服务</li></ul><p><img src="https://s2.loli.net/2022/03/02/Zhg1U8FGj2K6Lw9.png" alt="启动服务.png" loading="lazy"></p><ul><li>使用<code>mysql -u root -p</code>登录</li></ul><p><img src="https://s2.loli.net/2022/03/02/FLRCTbPd7mZpYvy.png" alt="登录MySQL.png" loading="lazy"></p><p>出现如上图提示则登录成功。</p><ul><li>使用指令<code>alter user &#39;root&#39;@&#39;localhost&#39; identified by &#39;xxxx&#39;;</code>修改密码。<br>上述指令中<code>xxxx</code>部分即为要修改的密码。</li></ul><p><img src="https://s2.loli.net/2022/03/02/vpRAEgGhFjqtr8S.png" alt="修改密码.png" loading="lazy"></p><ul><li>使用<code>exit</code>退出，然后重新登陆验证密码。</li></ul><p><img src="https://s2.loli.net/2022/03/02/DxZjBUy6SzsfTr2.png" alt="验证密码.png" loading="lazy"></p><h2 id="设置全局变量"><a href="#设置全局变量" class="headerlink" title="设置全局变量"></a>设置全局变量</h2><ul><li>我的电脑-右击-属性-高级系统设置-环境变量。<br>在系统变量中新建一个mysql变量，变量值为mysql安装路径。</li></ul><p><img src="https://s2.loli.net/2022/03/02/QB6F2gIU48TJEbM.png" alt="系统变量MySQL.png" loading="lazy"></p><ul><li>将该变量添加到PATH中。</li></ul><p><img src="https://s2.loli.net/2022/03/02/QTeC7KM3I6juU1z.png" alt="PATH变量.png" loading="lazy"></p><ul><li>这样，我们就可以在打开cmd后，直接登录MySQL。</li></ul><p><img src="https://s2.loli.net/2022/03/02/Shiy8wF3JQBsd76.png" alt="直接登录.png" loading="lazy"></p><hr><p>以上便是免安装版MySQL的使用指南。</p><hr><p>2022.4.8补充：</p><p>重装MySQL时报错<code>The service already exists!</code>，使用<code>mysqld -remove MySQL</code>移除MySQL服务即可。</p><p>卸载MySQL步骤：</p><ul><li><p><code>net stop mysql</code>（要在管理员模式下）</p></li><li><p>删除注册表</p></li><li><p>删除安装文件夹</p></li><li><p>删除C:\ProgramData或C:\Program Files (x86)下MySQL文件（如果有的话</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;参考链接：&lt;a href=&quot;https://www.cnblogs.com/winton-nfs/p/11524007.html&quot;&gt;MySQL的安装与配置——详细教程&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;MySQL下载&quot;&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>我的sagiri机器人</title>
    <link href="http://sagirichan.com/2022/01/27/my-sagiri-bot/"/>
    <id>http://sagirichan.com/2022/01/27/my-sagiri-bot/</id>
    <published>2022-01-27T15:53:47.000Z</published>
    <updated>2022-04-30T15:37:14.006Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>虽然本站域名叫sagiri，本文标题提到的的QQ机器人也叫sagiri，但是实际上这个机器人并不是笔者开发的，出现这种巧合单纯只是因为笔者与这个机器人的作者都喜欢sagiri<del>为什么有一种被NTR的感觉</del>。</p></blockquote><p>在另一篇博文<a href="https://ireinasan.github.io/2022/01/27/my-own-QQbot/">关于我想拥有自己的QQ机器人，及我的失败经历</a>中，我展现了我从兴致高昂地试图跟着<a href="https://docs.bot.elpsy.cn/">云游的教程</a>搭建机器人、到屡败屡战顽强不屈、最终心态大崩决定放弃的失败经历。</p><p>雄关漫道真如铁，而今迈步从头越。笔者并不是一个轻言放弃的人<del>主要还是放假太闲了</del>！在遭受了这样惨痛的失败后，依然痛定思痛，继续探索搭建QQ机器人的方法。</p><p>很幸运的是，我在GitHub上找到了这样一个利用python开发的mirai机器人：</p><p><a href="https://github.com/SAGIRI-kawaii/sagiri-bot">sagiri-bot</a></p><p>虽然我运行el-bot失败了，但是我能够成功使用mcl启动mirai-console，这让我更换机器人框架的成本大大降低。</p><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>sagiri是一个完善的、可以直接运行的QQ机器人，和el-bot一样，都是基于mirai框架；只不过el-bot用js&#x2F;ts开发，而sagiri用python开发。</p><p>故事的开始，起源于我失败的el-bot搭建经历（见上文链接）。彼时的笔者心灰意冷，并觉得云游的项目实在是太坑了，进而决定放弃通过javascrip开发mirai机器人，转而投向更热门的python方向。于是我在GitHub上搜索<code>mirai python</code>，很快发现了本文要讲述的项目。</p><h1 id="部署于本地"><a href="#部署于本地" class="headerlink" title="部署于本地"></a>部署于本地</h1><p>处于方便管理等因素，我选择的项目文件夹结构为</p><p>luka-sagiri-mirai<br>├── mcl<br>├── sagiri-bot</p><p>其中luka-sagiri-mirai为整个项目的目录，mcl为mirai框架启动目录，sagiri-bot为我克隆sagiri机器人的目录。</p><p>跟随着<a href="https://sagiri-kawaii.github.io/sagiri-bot/deployment/">官方文档</a>：</p><h2 id="启动mcl"><a href="#启动mcl" class="headerlink" title="启动mcl"></a>启动mcl</h2><p>在mcl目录中，配置好<code>mirai-api-http-v2</code>。</p><p>配置<code>mcl\config\net.mamoe.mirai-api-http\setting.yml</code>文件如下：</p><pre><code>adapters:- http- wsdebug: falseenableVerify: trueverifyKey: liuyan # 可以自己设定, 后续会用到singleMode: falsecacheSize: 4096 # 可选, 缓存大小, 默认4096. 缓存过小会导致引用回复与撤回消息失败adapterSettings:## 详情看 http adapter 使用说明 配置http:    host: localhost    port: 8080 # 端口可选，后续会用到    cors: [*]## 详情看 websocket adapter 使用说明 配置ws:    host: localhost    port: 8080 # 端口同上    reservedSyncId: -1 # 确保为 -1, 否则 WebsocketAdapt</code></pre><p>启动mcl。</p><h2 id="启动bot"><a href="#启动bot" class="headerlink" title="启动bot"></a>启动bot</h2><p>在主目录中</p><pre><code>git clone https://github.com/SAGIRI-kawaii/sagiri-bot.git sagiri-botcd sagiri-bot</code></pre><p>配置python环境<code>pip install -i https://pypi.doubanio.com/simple/ -r .\requirements.txt</code></p><p>PS. 原指令为<code>pip install -r requirements.txt</code>，而上面的指令是我在<a href="https://jq.qq.com/?_wv=1027&k=b9w1cThz">QQ群</a>中问问题时一位群友告诉我的，这里感谢群友。</p><p>PSS. 我在这一步遇到了不大不小的麻烦。我之前试图跑过<code>python-mirai</code>项目，安装了<code>graia-application-mirai</code>包（虽然最后并没有跑起来），所以在这一步，这个包让我配置的环境出了问题。后来我删除了<code>graia-application-mirai</code>包，解决问题。</p><p>在sagiri-bot文件夹下找到<code>configdemo.yaml</code>并修改如下：</p><pre><code># 必要数据及设置bot_qq: 2775446955 #bot QQhost_qq: 2937818202 #主人QQmirai_host: http://localhost:8080 #本地端口，可任意选择，但要与mcl\config\net.mamoe.mirai-api-http\setting.yml中的保持一致verify_key: liuyandb_link: sqlite+aiosqlite:///sagiribot.db #数据库链接，见项目README。web_manager_api: trueweb_manager_auto_boot: trueproxy: proxy# 路径相关image_path:setu: setusetu18: setu18 #R18real: real #三次元real_highq: real_highq #高质量三次元wallpaper: wallpaper #壁纸sketch: sketch #线稿# 功能相关functions:tencent:    secret_id: secret_id    secret_key: secret_keysaucenao_api_key: saucenao_api_keywolfram_alpha_key: wolfram_alpha_keyshadiao_app_name: shadiao_app_name# 日志相关log_related:error_retention: 14common_retention: 7# 数据相关data_related:lolicon_image_cache: true #缓存lolicon api获得图片network_data_cache: true #缓存lolicon api获取jsonautomatic_update: false #自动更新data_retention: true #退群后数据处理# 数据库相关database_related:mysql:    pool_size: 40    max_overflow: 60</code></pre><p>将<code>configdemo.yaml</code>文件更名为<code>config.yaml</code>。</p><p>注：需自行安装数据库。<a href="https://www.jianshu.com/p/424a8b143bbb">SQLite快速入门教程</a></p><p>在sagiri-bot目录下运行一次bot：<code>python main.py</code>。bot应会自动退出。</p><p>寻找<code>alembic.ini</code>文件，打开，将<code>sqlalchemy.url</code>项更换为<code>configdemo.yaml</code>中的<code>db_link</code>项。以我为例：</p><blockquote><p>sqlalchemy.url &#x3D; sqlite:&#x2F;&#x2F;&#x2F;sagiribot.db</p></blockquote><p>再次启动，成功。</p><p><img src="https://s2.loli.net/2022/01/28/wx9lFVDXnmGCyLa.png" alt="9.png" loading="lazy"></p><p>以上。</p><p>附<a href="https://sagiri-kawaii.github.io/sagiri-bot/">sagiri机器人使用文档</a>。</p><blockquote><p>bot的events代码位置：<code>sagiri_bot\handler\required_module\mirai_event\mirai_events.py</code></p></blockquote><h1 id="部署至云端"><a href="#部署至云端" class="headerlink" title="部署至云端"></a>部署至云端</h1><p>作为一个机器人，需要全天候24小时为群友服务，那么只部署在本地自然是不行的，如果我关了电脑，那机器人也将随之下线。所以我决定将机器人部署至云端。</p><p>在云端部署机器人，需要在云端复刻本地端的环境、代码、操作过程。写到这里感慨还好我记录了在本地部署机器人的步骤，否则在云端部署机器人又要麻烦半天。即使如此，由于云服务器的控制台没有图形界面，我在部署过程中依然遭遇了许多困难。</p><h2 id="向云服务器传输文件"><a href="#向云服务器传输文件" class="headerlink" title="向云服务器传输文件"></a>向云服务器传输文件</h2><p>我使用<a href="https://winscp.net/eng/docs/lang:chs">WinScp</a>来传输文件。参考文章</p><p><a href="https://cloud.tencent.com/document/product/1207/53134#.E7.99.BB.E5.BD.95-winscp">Windows 系统通过 WinSCP 上传文件到 Linux 轻量应用服务器</a></p><blockquote><p>省流：<br>        默认用户名root<br>        ubuntu实例默认ubuntu<br>        密码忘了直接重置</p></blockquote><p><a href="https://blog.csdn.net/qq_42755868/article/details/109321089">WinScp远程下载报错：无法创建文件夹 系统错误。代码：5。 拒绝访问。问题解决（亲测有效）</a></p><blockquote><p>省流：<br>        高级-环境-STFP-STFP服务器：<code>sudo usr/lib/openssh/sftp-server</code><br>        高级-环境-shell-Shell：<code>sudo -i</code></p></blockquote><p><a href="https://blog.csdn.net/bbat2008/article/details/6891381">winscp：无法初始化SFTP协议。主机是SFTP服务器吗？</a></p><blockquote><p>省流：<br>        登录界面把文件协议改为SCP</p></blockquote><h2 id="使用VNC-viewer对云服务器进行远程操作"><a href="#使用VNC-viewer对云服务器进行远程操作" class="headerlink" title="使用VNC viewer对云服务器进行远程操作"></a>使用<a href="https://www.realvnc.com/en/connect/download/viewer/">VNC viewer</a>对云服务器进行远程操作</h2><p>参考文章：</p><p><a href="https://dalewushuang.blog.csdn.net/article/details/94554206">本地Windows远程连接阿里云服务器图形界面（使用vnc viewer）</a></p><p><a href="https://blog.csdn.net/weixin_39278265/article/details/118641412">阿里云服务器Ubuntu 18.04安装图形界面（ubuntu-desktop）（以及解决困扰我多天的vnc viewer界面灰屏的问题！震惊我自己）</a></p><blockquote><p>省流：<br>        这个过程有点繁琐，省不了流</p></blockquote><hr><blockquote><p>关于VNC viewer无法粘贴的问题：<br>命令行上没有好的解决方法；文件方面可以用WinScp配合VNC viewer，在远程服务器上和本地“共享”某个文件，来回粘贴代码。</p></blockquote><hr><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>部署过程在文档中写得很详细：<a href="https://sagiri-kawaii.github.io/sagiri-bot/deployment/linux/">sagiri-bot在Linux环境中的部署</a></p><p>按照文档一步一步做就可以了！</p><p>部署成功截图：</p><p><img src="https://s2.loli.net/2022/04/26/sy5mu3qc1P9Y7eH.png" alt="部署成功.png" loading="lazy"></p><p><img src="https://s2.loli.net/2022/04/26/ztyLbu4orHBaQFd.png" alt="云服务器状态.png" loading="lazy"></p><p>我觉得很不错嘛！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;虽然本站域名叫sagiri，本文标题提到的的QQ机器人也叫sagiri，但是实际上这个机器人并不是笔者开发的，出现这种巧合单纯只是因为笔者与这个机器人的作者都喜欢sagiri&lt;del&gt;为什么有一种被NTR的感觉&lt;/del&gt;。&lt;/p&gt;
&lt;/block</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>关于我想拥有自己的QQ机器人，及我的失败经历</title>
    <link href="http://sagirichan.com/2022/01/27/my-own-QQbot/"/>
    <id>http://sagirichan.com/2022/01/27/my-own-QQbot/</id>
    <published>2022-01-27T15:47:50.000Z</published>
    <updated>2022-01-27T17:37:10.025Z</updated>
    
    <content type="html"><![CDATA[<h1 id="源起"><a href="#源起" class="headerlink" title="源起"></a>源起</h1><p>QQ机器人，嘛，最早接触到这个东西是在公主连结的游戏群里，正经的机器人是为了提供排刀报刀等会战相关服务，但是似乎群友们总是更喜欢色图功能（</p><p>在<a href="https://www.yunyoujun.cn/">云游君</a>的群里有一个可爱的机器人小云，她会贴心地回应群友的关键词、自动转发云游的博客、自动盗群友的图转发到所有群等<del>可惜没有色图功能</del>。</p><p>寒假，在家，百无聊赖！而且觉得我已经大三了，应该做点有趣的事情，我定下了如下目标：</p><ul><li>拥有自己的机器人</li><li>拥有自己的网站</li><li>把自己的机器人挂到一个云服务器上</li></ul><p>这三件事情我想做很久了，本来其实做网站是最简单的，但是由于我是第一次购买域名，我的实名信息刚提交上去还在审核，所以就先试着做机器人吧！</p><p>这是我的第一篇博客，而且在可预见的未来不会有很多人看到，所以这篇博文主要是记录自己的心路历程，行文会比较啰嗦<del>大部分内容在自嗨</del></p><h1 id="开始行动！"><a href="#开始行动！" class="headerlink" title="开始行动！"></a>开始行动！</h1><p>既然是云游的机器人引发了我的热情，那么当然要继续薅羊毛，所以我在云游的网站上找到了两篇与机器人有关的博客:</p><ul><li><a href="https://www.yunyoujun.cn/mirai-ts/">mirai-ts</a></li><li><a href="https://docs.bot.elpsy.cn/">el-bot</a></li></ul><p>嗯。。。第二篇看起来似乎开箱即用。。。</p><p>进去看看！</p><h1 id="mirai"><a href="#mirai" class="headerlink" title="mirai"></a>mirai</h1><blockquote><p><a href="https://github.com/mamoe/mirai">mirai</a> 是一个在全平台下运行，提供 QQ Android 协议支持的高效率机器人库</p><p>这个项目的名字来源于</p><p>京都动画作品《境界的彼方》的栗山未来(Kuriyama mirai)</p><p>CRYPTON以初音未来为代表的创作与活动(Magical mirai)</p><p>图标以及形象由画师DazeCake绘制</p></blockquote><p>以上内容摘自mirai的GitHub README部分。</p><p>要使用云游的机器人，我们首先需要安装mirai。</p><h2 id="mcl"><a href="#mcl" class="headerlink" title="mcl"></a>mcl</h2><p>mcl，mirai-console-loader，顾名思义，能够帮你load mirai-console，而mirai-console就是方便我们使用mirai框架的工具。</p><p>然而按照网上的教程安装mcl却不成功，于是我去了mcl的GitHub页面，又找到了一个mcl-installer工具。</p><blockquote><p>如果读者希望通过手动方式启动mcl，那么在本文的<code>el-bot</code>大标题下有相关内容可供参考。</p></blockquote><p>真是一环套一环啊~</p><h2 id="mcl-installer"><a href="#mcl-installer" class="headerlink" title="mcl installer"></a>mcl installer</h2><p>mcl-installer需要rust环境和调用cargo，绝绝子，继续装rust环境。</p><p><a href="https://www.rust-lang.org/zh-CN/tools/install">安装 Rust</a></p><p>网上教程很多，这里不再添足。</p><p>好，rust环境配好了，查看一下：</p><p><img src="https://s2.loli.net/2022/01/26/8EUkgoAG3X6D9Z2.png" alt="2.png" loading="lazy"></p><p>接下来，按照<a href="https://github.com/iTXTech/mcl-installer/releases">官方文档</a>的提示，使用mcl-installer一键启动mcl：</p><pre><code>$ git clone https://github.com/iTXTech/mcl-installer.git$ cd mcl-installer# native-tls =&gt; 使用系统的 OpenSSL，rustls =&gt; 使用 rustls。# --release 用于构建优化过的二进制文件，如需要进行调试请去除该参数。$ cargo build --features native-tls --release$ cd target/release$ strip mcl-installer # strip 可减小可执行文件大小$ upx --best --lzma mcl-installer # 使用 upx 压缩可进一步缩小可执行文件大小</code></pre><p>其实在进行到</p><blockquote><p>cargo build –features native-tls –release</p></blockquote><p>这一步就可以了。此时在文件夹下产生了一个mcl可执行文件，使用<code>./mcl</code>命令运行：</p><p><img src="https://s2.loli.net/2022/01/26/fXGZjc1YVS7n4AD.png" alt="3.png" loading="lazy"></p><p>mcl启动成功。<del>怎么感觉一键安装一点都不快捷</del>‘</p><h2 id="登录QQ"><a href="#登录QQ" class="headerlink" title="登录QQ"></a>登录QQ</h2><p>在启动了mcl的窗口，运行<code>login 账号 密码</code>：</p><p><img src="https://s2.loli.net/2022/01/26/hTIY1NBuAiS25qe.png" alt="5.png" loading="lazy"></p><p>报错并弹出如下提示框。</p><p><img src="https://s2.loli.net/2022/01/26/Da8xj7fZwEnYRgu.png" alt="4.png" loading="lazy"></p><p>我的QQ开了设备锁，要验证一下。</p><p>好，登录成功，验证一下。</p><p><img src="https://s2.loli.net/2022/01/26/crHKb1kV4awMAtz.png" alt="6.png" loading="lazy"></p><p><img src="https://s2.loli.net/2022/01/26/Iwu8Dr7OVaAgPWz.png" alt="7.png" loading="lazy"></p><p>向bot发送消息，bot接收到。</p><h1 id="el-bot"><a href="#el-bot" class="headerlink" title="el-bot"></a>el-bot</h1><p>终于结束了mirai的安装与配置，可以使用el-bot啦！</p><blockquote><p>这里出了点小状况，由于在安装mcl时，<strong>手动安装</strong>、<strong>使用mcl-installer安装</strong>后的文件夹会不同，而云游的配置文件中默认采用手动安装的目录情况，所以为了后续更好地使用云游的项目，<strong>我采用手动安装的方式，重新安装并启动了mcl</strong>，而本次登录环节出了点小问题，需要使用滑块验证。我采用的解决方法及其具体过程为：</p><ul><li>登录过程中mcl会弹出一个url和一个ticket输入框</li><li>在手机上使用<a href="https://github.com/mzdluo123/TxCaptchaHelper/releases">滑动验证助手</a>，填入url并验证后，滑动验证助手会返回一个ticket</li><li>将ticket粘贴回mcl弹出的输入框中，并关闭弹窗</li></ul></blockquote><h2 id="克隆el-bot"><a href="#克隆el-bot" class="headerlink" title="克隆el-bot"></a>克隆el-bot</h2><pre><code>git clone https://github.com/ElpsyCN/el-bot-template your-el-botcd your-el-bot#这里的your-el-bot就是用来放置项目的文件夹</code></pre><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><pre><code>npm install</code></pre><h2 id="启动mirai"><a href="#启动mirai" class="headerlink" title="启动mirai"></a>启动mirai</h2><p>把前面的mcl启动器文件夹复制到your-el-bot文件夹下，并启动mirai。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="配置mirai-api-http"><a href="#配置mirai-api-http" class="headerlink" title="配置mirai-api-http"></a>配置mirai-api-http</h3><p>下载<a href="https://github.com/project-mirai/mirai-api-http/releases">mirai-api-http Releases</a>jar包，放置在<code>your-el-bot/mcl/plugins</code>文件夹中</p><p>配置文件：<code>mcl/config/net.mamoe.mirai-api-http/setting.yml</code></p><pre><code>cors:- &quot;*&quot;host: 0.0.0.0port: 4859authKey: el-psy-congrooenableWebsocket: true#云游建议修改authKey，虽然我并不明白他的意思</code></pre><h3 id="配置bot"><a href="#配置bot" class="headerlink" title="配置bot"></a>配置bot</h3><pre><code>// el/index.jsmodule.exports = &#123;// 你登录的 QQ 号qq: 12345679,&#125;;</code></pre><blockquote><p>此外，在<code>package.json</code>中，<code>mcl.folder</code>字段默认值为<code>mcl</code>，即我的mirai启动器文件夹，这也是我在<code>el-bot</code>小节中提到的重新安装启动mcl的原因。</p></blockquote><h3 id="启动bot"><a href="#启动bot" class="headerlink" title="启动bot"></a>启动bot</h3><p>一直在报错如下：</p><p><img src="https://s2.loli.net/2022/01/27/RvhxMUZQC45pDIG.jpg" alt="1.jpg" loading="lazy"></p><p>百思不得其解，我搜了各种问题，试了各种方法，最后去群里问云游，源赖氏这个项目自己有问题。</p><p>于是云游连夜升级了项目。</p><p><img src="https://s2.loli.net/2022/01/27/yAaXTfxOVoWFLpE.png" alt="8.png" loading="lazy"></p><p>五点半还在commit项目，感谢云游强大的肝脏。</p><p>好，重新开始！</p><p>略过前述步骤，再次来到启动bot环节，启动：</p><p>依然启动失败。</p><hr><h1 id="放弃"><a href="#放弃" class="headerlink" title="放弃"></a>放弃</h1><p>经过一整天的失败，我决定放弃使用云游的el-bot，转向别的mirai机器人，我也将<a href="https://ireinasan.github.io/2022/01/27/my-sagiri-bot/">另起一篇博客</a>，重新讲述我与我的QQ机器人的故事。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;源起&quot;&gt;&lt;a href=&quot;#源起&quot; class=&quot;headerlink&quot; title=&quot;源起&quot;&gt;&lt;/a&gt;源起&lt;/h1&gt;&lt;p&gt;QQ机器人，嘛，最早接触到这个东西是在公主连结的游戏群里，正经的机器人是为了提供排刀报刀等会战相关服务，但是似乎群友们总是更喜欢色图功能（&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>关于我想要拥有自己的网站这件事</title>
    <link href="http://sagirichan.com/2022/01/25/my-own-website/"/>
    <id>http://sagirichan.com/2022/01/25/my-own-website/</id>
    <published>2022-01-25T12:41:15.000Z</published>
    <updated>2022-05-13T12:02:50.432Z</updated>
    
    <content type="html"><![CDATA[<h1 id="源起"><a href="#源起" class="headerlink" title="源起"></a>源起</h1><p>个人网站，或者叫个人博客，似乎是每个程序员都要有的酷酷的东西（</p><p>大三的时候，我报名了一个比赛，为了完成我的组内分工任务，我拥有了自己的一台云服务器，当然，是学生云。</p><p>寒假是比赛的准备时间，说是准备时间，其实也没什么好准备的，我领到的任务就一句话：在云服务器上部署算法，并实现简单交互。</p><p>就这样，我买了我的腾讯学生云服务器。</p><p>本来我真没想别的东西，但是搜服务器使用教程的时候，总是能看见“使用服务器建站”之类的字眼。。。</p><p>建站？嗯，以普遍理性而言，确实是服务器的好用处。</p><p><del>比赛？什么比赛？</del></p><p>由于这个站在未来可预见的时间内都不会有太多人会访问，所以我的文章主要是留给自己看的，基本是自嗨，十分啰里啰唆。</p><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>今天建一个个人网站应该是非常简单的事情，只要善于使用搜索工具，掌握一些基本的编程知识（甚至都可以不需要），那么每个人都可以拥有自己的站点，自己的一方小天地。</p><p>这里介绍一下我使用的建站教程<a href="https://www.yunyoujun.cn/share/how-to-build-your-site/">教你如何从零开始搭建一个属于自己的网站</a>，这位博主非常可爱，如果大家不认识他，不知道大家记不记得<a href="https://ac.yunyoujun.cn/#/">便携小空调</a>？没错，就是他做的！</p><p>云游的教程非常细致，但是像他所说的，不免有从盘古开天辟地开始讲的感觉，所以在此我去芜存菁（自我感觉hh），保留了对我来说简练精干的部分。</p><h1 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h1><p>我已经有了GitHub账号，所以可以跳过云游教程的一长串内容，直接开始hexo！</p><h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><p>打开Windows powershell（之所以使用它是因为它的语法和Linux相仿，我比较熟悉），输入<code>npm install hexo-cli -g</code></p><blockquote><p>install 自然是安装。</p><p>hexo-cli 则是 hexo 的终端工具，可以帮助你生成一些模版文件，之后再用到。</p><p>-g 代表的是全局安装。也就是在任何地方都可以使用，否则会只能在安装的目录下使用。</p><p>–摘自云游博客</p></blockquote><h2 id="建立网页文件"><a href="#建立网页文件" class="headerlink" title="建立网页文件"></a>建立网页文件</h2><p>进入用来放置网页文件的文件夹，右键，Git Bash Here</p><p>在git终端输入<code>hexo init 之前建好的仓库名</code>，在我这里即</p><p><code>hexo init ireinasan.github.io</code></p><p><del>好，经典连不上GitHub</del><br><del>重试</del></p><p>上一步完成，继续。</p><blockquote><p>cd ireinasan.github.io</p><p>npm install</p><p>hexo s</p></blockquote><p>最后一个命令打开了本地的网页服务器，此时在浏览器地址栏中输入<code>localhost:4000</code>便可查看本地博客。</p><p><img src="https://s2.loli.net/2022/01/24/WBP6qcMr8A4UfvT.png" alt="localhost:4000" title="localhost:4000" loading="lazy"></p><h2 id="使用hexo主题"><a href="#使用hexo主题" class="headerlink" title="使用hexo主题"></a>使用hexo主题</h2><p>hexo的默认主题非常丑，所以我们要换一个漂亮的主体！下面学习如何使用别人开发的hexo主题。</p><p>依然是<del>薅云游的羊毛</del>以云游的教程为例。</p><h3 id="下载hexo主题"><a href="#下载hexo主题" class="headerlink" title="下载hexo主题"></a>下载hexo主题</h3><p>在配置hexo主题时，我们可以使用宇宙第一IDE——</p><p><img src="https://s2.loli.net/2022/01/24/9b1haEJ2WOlDZVK.png" alt="正是在下" title="正是在下" loading="lazy"></p><p>（主要是为了方便修改配置文件）</p><p>在使用hexo初始化好的<code>ireinasan.github.io</code>文件夹中<code>git clone https://github.com/YunYouJun/hexo-theme-yun themes/yun</code>.</p><h3 id="编辑hexo配置"><a href="#编辑hexo配置" class="headerlink" title="编辑hexo配置"></a>编辑hexo配置</h3><p>仍然是在这个文件夹中，右击使用vscode打开，找到<code>_config.yml</code>文件并打开。</p><p>找到<code>theme</code>，将冒号右侧的<code>landscape</code>改成<code>yun</code>。</p><blockquote><p>由于我的主题使用了 pug 和 stylus，而 Hexo 自带的一般是 ejs 与 stylus，所以你可能还需要输入以下命令安装渲染器。</p><p>npm install hexo-render-pug hexo-renderer-stylus<br>#如果出问题，可以换 yarn 安装试试。</p></blockquote><p>完成上一步以后，再次<code>hexo s</code>，并在<code>localhost:4000</code>中查看效果。如果一切顺利，我们就已经用上了云游的主题。</p><h3 id="自定义主题配置"><a href="#自定义主题配置" class="headerlink" title="自定义主题配置"></a>自定义主题配置</h3><p>。。。</p><p>云游教程里随意带过的一段文字，却是我建站到现在花费时间最长的内容。这里直接放上云游的主题文档吧：<a href="https://yun.yunyoujun.cn/guide/">云游主题帮助文档</a>。</p><p>简单说几个要点：</p><ul><li><p>在博客文件夹（也就是我的ireinasan.github.io文件夹）底下建立一个<code>source/_data/yun.yml</code>文件，然后在这个yml文件中自定义自己的配置，不要动别的配置，以方便后续升级主题。</p></li><li><p>进入帮助文档以后随便扫一扫<code>使用指南</code>中的内容，帮助不是很大，重点都在第二个大标题<code>主题配置</code>中。</p></li><li><p><code>页面配置</code>中也有一些可看的东西，比如点击头像的about页面等（这个地方一度让我感到非常困扰）。</p></li></ul><h1 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h1><h2 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h2><p>右上角<code>+</code>-&gt;<code>New repository</code>新建仓库</p><p><img src="https://s2.loli.net/2022/01/24/mobtwd43l6C9c1q.png" alt="新建仓库" title="new repository" loading="lazy"></p><p>仓库名称格式为：</p><p><code>用户名.github.io</code></p><p>Create repository.</p><h2 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h2><p>在博客文件夹下：</p><blockquote><p>hexo clean #清除缓存<br>hexo g #generate简写为g</p></blockquote><p>此时文件夹目录下出现一个public目录，里边就是我的站点的静态文件。</p><h2 id="与远程仓库建立关联"><a href="#与远程仓库建立关联" class="headerlink" title="与远程仓库建立关联"></a>与远程仓库建立关联</h2><blockquote><p>git init<br>git checkout -b hexo #创建一个分支 </p></blockquote><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>hexo有三种部署方法，云游详细介绍的、以及我采用的是<a href="https://hexo.io/zh-cn/docs/one-command-deployment">一键部署</a>。</p><p>安装<code>hexo-deployer-git</code>插件</p><blockquote><p>npm install hexo-deployer-git</p></blockquote><p>在<code>ireinasan.github.io/_config.yml</code>中配置：</p><pre><code>deploy:  type: git  repo: git@github.com:Ireinasan/ireinasan.github.io.git   # 自己的仓库地址，由于上一条type是git类型，所以此处填写的是SSH的地址    branch: master # 默认使用 master 分支  message: Update Hexo Static Content # 你可以自定义此次部署更新的说明</code></pre><p>然后在地址栏输入<code>ireinasan.github.io/</code>就可以看到我的网站啦！</p><p>一键部署会将<code>生成静态文件</code>步骤中产生的public文件夹中的内容（即网页静态文件）推送到我们的GitHub仓库中，<strong>而不是我们的网站源代码</strong>。因此，如果有需要，应再建一个专门存储代码的仓库。</p><h1 id="绑定个人域名"><a href="#绑定个人域名" class="headerlink" title="绑定个人域名"></a>绑定个人域名</h1><p>这里云游的教程比较简略，我又搜了一些补充内容。</p><ul><li>在腾讯云的控制台为域名添加解析</li></ul><p><img src="https://s2.loli.net/2022/01/25/LS5B3T6yJAxnXIM.png" alt="建立解析.png" loading="lazy"></p><p>IPv4地址为ping出的<code>ireinasan.github.io</code>服务器IP</p><ul><li>在GitHub的<code>ireinasan.github.io</code>仓库，<code>Settings</code>-<code>Pages</code>-<code>Custom domain</code>中填入域名<code>sagirichan.com</code>，<code>Save</code></li></ul><p><em>这一步要等一会，因为域名解析需要时间。</em></p><p>完成后，仓库中会自动生成一个CNAME文件，文件里边就是我们要绑定的域名<code>sairichan.com</code></p><p>如果觉得有必要，也可以在本地文件夹中<code>ireinasan.github.io\source</code>路径下建一个同样的CNAME文件。</p><p><del>如果按照我的步骤出了什么问题还是自行百度⑧，每个人的问题都不一样</del></p><h1 id="网站备案"><a href="#网站备案" class="headerlink" title="网站备案"></a>网站备案</h1><p>绑定域名后，我使用的仍然是GitHub的服务器，而由于GitHub在国内访问不是很稳定，所以连带着我的网站访问也不是很稳定。于是我决定尝试把我的网站部署到自己的服务器上。</p><p>然鹅，原本以为万事俱备，只欠东风的网站备案，居然真的就像诸葛亮借东风那样麻烦2333</p><p><del>我不保证这一部分能写下去</del></p><p>由于我是在腾讯云上买的域名，所以我就直接在腾讯云上进行网站备案。</p><p>搜索网站备案、进入备案主页、阅读注意事项<del>其实并没有</del>，开始备案。</p><h2 id="验证备案类型"><a href="#验证备案类型" class="headerlink" title="验证备案类型"></a>验证备案类型</h2><p>由于我是首次备案，所以我来到了<code>首次备案</code>页面（废话文学），草草扫描了一下注意事项，下一步：<code>验证备案类型</code> 。</p><p>填写<code>主办单位信息</code>。<code>备案省份</code>（划重点，要考）、<code>主办单位性质</code>，由于我的主办单位性质是个人，所以我接下来要上传身份证的正反两面。</p><p><del>愣着干嘛，拍照片啊</del></p><p>填入我购买的域名、我购买的云服务器的公网IP。</p><p>立即验证！</p><p>网站弹出了一个<del>严重警告</del>温馨提示！</p><p><img src="https://s2.loli.net/2022/01/24/2nA1vwH9JWf7ROK.png" alt="温馨提示" title="温馨提示" loading="lazy"></p><p>网站提示我们，要再次核对<code>备案省份</code>、主办单位信息。</p><p>如果你觉得自己填写的信息没有问题，进入下一步。</p><h2 id="备案小程序"><a href="#备案小程序" class="headerlink" title="备案小程序"></a>备案小程序</h2><p>在上一步的<code>温馨提示</code>中，点击下一步，会弹出一个警告书，不用多看，继续下一步，在备案小程序中进行网站负责人身份验证。</p><p><img src="https://s2.loli.net/2022/01/24/AlnSMQ7N4zW8XvL.jpg" alt="小程序截图" title="tencentVideoCheck" loading="lazy"></p><p>继续拍照。。。</p><p>在第三步，上传视频核身中，小程序会获取你的地理位置，你的地理位置需要与上一步 <strong><code>验证备案类型</code></strong> 中填写的备案省份相符。</p><p><strong>在我的第一次尝试中，就由于我人在江苏而备案主体省份填写了湖南，导致信息不符，无法采集视频核身，而警告有告诉我们，备案省份无法更改，所以。。。我只能放弃本次备案，重新开始。</strong></p><p><img src="https://s2.loli.net/2022/01/24/5O2NYvfk4ViqIHD.jpg" alt="呜，苦露西" title="呜，苦露西" loading="lazy"></p><p>好，我放弃了本次备案，重新开始了我的备案之路，并且在第二次备案中顺利地完成了备案小程序的视频身份核验，进入下一步，主体信息。</p><h2 id="主体信息"><a href="#主体信息" class="headerlink" title="主体信息"></a>主体信息</h2><p>主体信息第一条就是江苏，果然是无法更改的。</p><p><img src="https://s2.loli.net/2022/01/24/rqGypFfIkz9lmD1.png" alt="主体信息" title="主体信息" loading="lazy"></p><p>填写个人信息ing…</p><p>通信地址原来也是根据身份证地址定好的，没法改成我的大学地址。。。</p><p>验证手机号，填写邮箱。下一步，<code>网站信息</code>。</p><h2 id="网站信息"><a href="#网站信息" class="headerlink" title="网站信息"></a>网站信息</h2><p>填写网站名称，取一个好听或自己喜欢的名称。</p><p>我的网站名称来源于我很喜欢的一部小说《宰执天下》<del>是主角穿越后第一炮的章节名</del>。</p><p>云资源，我购买的服务器类型及公网IP。</p><p>域名，我购买的域名。</p><p>备注，随便写一写。</p><p>网站负责人信息，在上一步<code>主体信息</code>中已经填过了，这里可以不用再麻烦一遍。</p><p>备案信息填写完成在望，我已经开始开香槟了。</p><blockquote><p>网站补充材料，网站备案信息真实性责任告知书、网站备案信息真实性承诺书、网站负责人承诺视频，简单！</p></blockquote><p><code>网站备案信息真实性责任告知书</code>下载链接————下载————上传。</p><p>emmm，怎么只能上传图片格式的？百度一下。</p><p>哦，源赖氏，要把这份PDF文件打印出来，亲笔签字，然后再拍照片or扫描，再传上去，<code>网站备案信息真实性承诺书</code>也一样。</p><p>可我家里没有打印机啊。。。这大半夜的，外边打印店都关门了。</p><p>好吧，只能等第二天了。</p><p>还是看看第三个吧，<code>网站负责人承诺视频</code>，点开，又是扫码进入小程序，行吧。</p><p>面对屏幕读文字，上传。</p><p>返回网页端，我留了个心眼，看了一下我的视频效果。。。果然又有问题了。</p><blockquote><p>我真是个铸币，我在备案的时候，公主连结正在打公会战，我把模拟器开着放后台，同时备案。结果上传承诺视频的时候，模拟器的声音没关，被录进去了，视频里全是会战界面的BGM，根本听不清说话，这要传上去那审核铁定不通过。</p></blockquote><p>没办法，关了模拟器声音，重录吧，这次行了。</p><p>保存备案草稿，上床睡觉，明天最后练一次科目三，后天要考试了。</p><hr><p>第二天————</p><p>练科目三累死了，早上六点半就起床，中午午饭也是在外边解决的。</p><p>回家到小区门口，找了个打印店，打印了两份补充材料，借了打印店的笔填好，拍照，传给电脑。回家，打开电脑，上传照片，完成！保存当前网站！</p><blockquote><p>域名 sagirichan.com 实名认证时间为 2022-01-23 00:09:44 ，距离现在未满 72 小时，无法备案，请您在 2022-01-26 00:09:44 之后再进行备案</p></blockquote><p><img src="https://s2.loli.net/2022/01/24/YXCwJOjIzEyniNq.jpg" alt="tnnd" title="tnnd" loading="lazy"></p><hr><p>ただいま~</p><p>科目三考完了，通过力~我的网站也可以继续备案了。登录腾讯云，网站备案——保存当前网站—— <del>上传补充材料，由于我没有要补充的材料，所以跳过这一步</del> ——提交审核！</p><h2 id="静等审核通知！"><a href="#静等审核通知！" class="headerlink" title="静等审核通知！"></a>静等审核通知！</h2><hr><p>腾讯初审把我驳回了，主要三个问题，一个是我身份证拍的照片背景不一样（实际上只是相机白平衡出了问题，手机背大锅）；第二个是域名没有备案不许访问，所以我之前私自给GitHub Page绑定了个人域名，要删除解析记录（悲）；第三个是网站负责人承诺视频，我没有手持承诺书，我说啊，拍视频的时候又没有提示我要手持承诺书，现在以这个理由驳回来了，这不是搞我心态吗？</p><p>总之吧，我按照要求一一解决了，希望第二次申请能给我通过。</p><hr><p>腾讯初审速度很快，一个多小时就好了；提交工信部终审也很快，嘿嘿，成功在望！</p><hr><p>2022.2.22，今天普京把军队开进了乌克兰东部的两个州，工信部把我的网站sagirichan.com审核通过了。而此时距离我提交申请已经过去了将近一个月😭</p><p>不管怎么说，我的网站备案是下来了，总算可以部署到我自己的服务器上啦。</p><h1 id="部署到自己的服务器上"><a href="#部署到自己的服务器上" class="headerlink" title="部署到自己的服务器上"></a>部署到自己的服务器上</h1><p>这个坑太大了，见我的另一篇文章：</p><p><a href="http://101.33.208.50/2022/04/30/blog-on-cloud/">如何把博客部署在云服务器上？</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;源起&quot;&gt;&lt;a href=&quot;#源起&quot; class=&quot;headerlink&quot; title=&quot;源起&quot;&gt;&lt;/a&gt;源起&lt;/h1&gt;&lt;p&gt;个人网站，或者叫个人博客，似乎是每个程序员都要有的酷酷的东西（&lt;/p&gt;
&lt;p&gt;大三的时候，我报名了一个比赛，为了完成我的组内分工任务，我拥有</summary>
      
    
    
    
    
  </entry>
  
</feed>
