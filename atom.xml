<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>绮罗传香度良辰</title>
  
  
  <link href="http://sagirichan.com/atom.xml" rel="self"/>
  
  <link href="http://sagirichan.com/"/>
  <updated>2022-06-12T19:02:36.097Z</updated>
  <id>http://sagirichan.com/</id>
  
  <author>
    <name>绮罗传香</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计网复习笔记-链路层</title>
    <link href="http://sagirichan.com/2022/06/13/computer-network-note-linkLayer/"/>
    <id>http://sagirichan.com/2022/06/13/computer-network-note-linkLayer/</id>
    <published>2022-06-12T18:49:43.000Z</published>
    <updated>2022-06-12T19:02:36.097Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>数据链路层经一条链路，将数据从一个节点传输到相邻节点</p><p>节点：主机和路由器</p><p>链路：连接通信路径中相邻节点的路径</p><h2 id="链路层服务"><a href="#链路层服务" class="headerlink" title="链路层服务"></a>链路层服务</h2><ul><li><p>将数据报封装进帧</p></li><li><p>帧首部的MAC地址标识源、目的地</p></li><li><p>相邻节点的可靠交付</p></li><li><p>流量控制</p></li><li><p>差错检测</p></li><li><p>纠错</p></li></ul><h1 id="差错检测和纠错"><a href="#差错检测和纠错" class="headerlink" title="差错检测和纠错"></a>差错检测和纠错</h1><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><ul><li><p>发送方：信息数据+冗余数据</p></li><li><p>接收方：检查信息数据和冗余数据的关系，发现差错</p></li></ul><h2 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h2><p>设置奇偶校验位</p><ul><li><p>1的数量为奇数，奇偶校验位设为1</p></li><li><p>1的数量为偶数，奇偶校验位设为0</p></li></ul><h2 id="检查和"><a href="#检查和" class="headerlink" title="检查和"></a>检查和</h2><ul><li><p>发送方计算检查和：求和、回卷、求反（运输层UDP部分）</p></li><li><p>接收方重新计算检查和，与字段值进行对比</p></li></ul><h2 id="循环冗余码校验-CRC"><a href="#循环冗余码校验-CRC" class="headerlink" title="循环冗余码校验 CRC"></a>循环冗余码校验 CRC</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><table><thead><tr><th>信息位 K位</th><th>校验位 R位</th></tr></thead></table><p>数据发送、接受方约定一个<strong>除数</strong></p><p><strong>K个信息位和R个校验位</strong>作为<strong>被除数</strong>，添加校验位后需保证除法的余数为0</p><p>收到数据后，进行除法检查余数是否为0</p><p>若余数非0说明出错，进行重传或纠错</p><h4 id="本部分中的二进制除法"><a href="#本部分中的二进制除法" class="headerlink" title="本部分中的二进制除法"></a>本部分中的二进制除法</h4><p>举例：</p><p>生成多项式为$ G(x) &#x3D; x^3 + x^2 + 1 $，即除数为1101。信息码为101001，求CRC码。</p><p>如图。</p><p><img src="https://s2.loli.net/2022/06/12/ZWXHef7MQKroGaD.png" alt="CRC码计算方法.png" loading="lazy"></p><ol><li>首先确定余数位数：余数位数 &#x3D; 除数位数-1 &#x3D; 校验码位数 &#x3D; 3</li></ol><p>由于对校验码的要求是：(信息码+校验码)为除数的整数倍</p><p>故在计算时应在信息码后补[<strong>余数位数</strong>]个0，即3个0</p><ol start="2"><li><p>二进制除法，以1、0作为商的每一位</p></li><li><p>对被除数和除数每一位做异或运算（相同为0，不同为1）</p></li><li><p>直至补完3个0，得到校验位</p></li></ol><p>将信息码与校验码拼接得到CRC码</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p><img src="https://s2.loli.net/2022/06/12/OaSUfYjXrhvcgZw.png" alt="CRC生成（批注）.png" loading="lazy"></p><ol><li><p>确定信息码长度K、<em>生成多项式</em>的最高次幂R，CRC位数为N&#x3D;K+R&#x3D;9</p><p> 仍以上文举的例子为例，信息码&#x3D;101001，位数为6；<em>生成多项式</em>&#x3D;x^3^+x^2^+1，最高次幂为3，CRC位数为6+3&#x3D;9</p></li><li><p>移位。信息码左移R位，低位补0（或者理解为，在信息码后补R个0）</p></li><li><p>相除。用2中补完0的数作为被除数，除生成多项式，取余数，生成CRC码。</p></li></ol><h3 id="检错和纠错"><a href="#检错和纠错" class="headerlink" title="检错和纠错"></a>检错和纠错</h3><p>上文生成的CRC为101001001，与1101进行除法，若余数为000，代表没有出错；若余数为010，十进制值为2，代表第2位或第9位出错</p><p><img src="https://s2.loli.net/2022/06/12/xGnfaA8Pt5wDLjE.png" alt="CRC检错.png" loading="lazy"></p><p>对于3位余数，可以表示2^3^-1&#x3D;7位错位（000表示没有出错）</p><p>如果出错的位数没有超过余数所能表示的范围，则出错位之间就算一一对应的关系，CRC码可能纠错。</p><h1 id="多路访问协议"><a href="#多路访问协议" class="headerlink" title="多路访问协议"></a>多路访问协议</h1><p>碰撞：单一广播信道，节点的两个或更多并行传输，产生<strong>干扰</strong>，如果节点同时接收两个或更多信号，则称发生了<strong>碰撞</strong></p><p>决定节点怎样共享信道的分布式算法</p><p>必须使用信道本身，不用外信道来协调</p><h2 id="理想的多路访问协议"><a href="#理想的多路访问协议" class="headerlink" title="理想的多路访问协议"></a>理想的多路访问协议</h2><ol><li><p>当一个节点要传输，它能够以速率R发送</p></li><li><p>当M个节点要传输，每个能以平均速率 $\frac{R}{M}$ 发送</p></li><li><p>全分散</p><ul><li><p>无特殊节点来协调传输</p></li><li><p>无同步时钟、时隙</p></li></ul></li><li><p>简单</p></li></ol><h2 id="MAC协议分类"><a href="#MAC协议分类" class="headerlink" title="MAC协议分类"></a>MAC协议分类</h2><p>三大类：</p><ul><li><p>信道划分</p><ul><li><p>将信道划分为较小的”段“（时隙，频率，编码）</p></li><li><p>为节点分配一部分专用</p></li></ul></li><li><p>随机访问</p><ul><li><p>不划分信道，允许碰撞</p></li><li><p>从”碰撞“恢复</p></li></ul></li><li><p>轮流协议</p><ul><li>节点轮流，有更多信息要发送的能够轮流较长的时间</li></ul></li></ul><h2 id="信道划分协议"><a href="#信道划分协议" class="headerlink" title="信道划分协议"></a>信道划分协议</h2><h3 id="时分多路复用：TDMA"><a href="#时分多路复用：TDMA" class="headerlink" title="时分多路复用：TDMA"></a>时分多路复用：TDMA</h3><ul><li><p>循环访问信道</p></li><li><p>每个站点在每个循环中获得固定长度时隙（长度&#x3D;分组传输时间）</p></li><li><p>不使用的时隙空闲</p></li></ul><p>举例：</p><table><thead><tr><th>1</th><th></th><th>3</th><th>4</th><th></th><th></th><th>1</th><th></th><th>3</th><th>4</th><th></th><th></th></tr></thead></table><p>如图，6个站点的的LAN，划分出6段时隙；时隙1、3、4有分组，而2、5、6空闲</p><h3 id="频分多路复用：FDMA"><a href="#频分多路复用：FDMA" class="headerlink" title="频分多路复用：FDMA"></a>频分多路复用：FDMA</h3><ul><li><p>信道频谱划分为频带</p></li><li><p>每个站点分配固定的频带</p></li><li><p>频带中未使用的传输空间空闲</p></li></ul><p>举例：</p><p><img src="https://s2.loli.net/2022/06/12/HVwby3lIQiX91Kk.png" alt="FDMA.png" loading="lazy"></p><p>6个站点的LAN，划分出6道频带；频带1、3、4有分组使用，2、5、6空闲</p><h2 id="随机访问协议"><a href="#随机访问协议" class="headerlink" title="随机访问协议"></a>随机访问协议</h2><ul><li><p>当站点有分组要发送</p><ul><li><p>以信道全部速率R传输</p></li><li><p>节点间无优先权协调</p></li></ul></li><li><p>两个或更多传输节点——碰撞</p></li><li><p><strong>随机访问MAC协议</strong>定义了</p><ul><li><p>如何检测碰撞</p></li><li><p>如何从碰撞中恢复</p></li></ul></li></ul><h3 id="时隙ALOHA"><a href="#时隙ALOHA" class="headerlink" title="时隙ALOHA"></a>时隙ALOHA</h3><ol><li><p>假定</p><ul><li><p>所有帧有相同长度</p></li><li><p>时间划分为等长时隙，每个时隙能够传输1个帧</p></li><li><p>节点仅在时隙开始时开始传输帧</p></li><li><p>节点是同步的</p></li></ul></li><li><p>操作</p><ul><li><p>当节点获得新帧，将在下一个时隙中传输</p></li><li><p>无碰撞，节点能够在下一个时隙中发送新帧</p></li><li><p>如果碰撞，节点在每个后续时隙中以概率p重传帧</p></li></ul><p> <img src="https://s2.loli.net/2022/06/13/iv1dsj8r4PcWzTV.png" alt="时隙ALOHA.png" loading="lazy"></p><p> 如上图所示，c表示碰撞，S表示成功发送帧，E表示空闲时隙</p><p> 在第一个C时隙，节点1、2、3同时传输帧，发生碰撞</p><p> 在第二个C时隙，节点1、2同时传输帧，发生碰撞</p><p> 紧接着下一个时隙，节点2成功发送帧</p><p> 以此类推，不再重复描述</p></li><li><p>优点</p><ul><li><p>单个活跃节点能够连续地以信道的全速传输</p></li><li><p>高速分散：仅节点中的时隙需要同步</p></li><li><p>简单</p></li></ul></li><li><p>缺点</p><ul><li><p>碰撞浪费时隙</p></li><li><p>有空闲时隙</p></li><li><p>节点可能能够以小于传输分组的时间检测到碰撞</p></li><li><p>时钟同步</p></li></ul></li><li><p>效率</p><ul><li><p>定义：节点发送成功的时隙与总时隙的长度比值</p></li><li><p>假定N个节点，每个时隙以概率p发送。对于节点一，在某一个时隙中发送成功的概率为 $p(1-p)^{N-1}$</p></li><li><p>任何节点发送成功的概率为 $Np(1-p)^{N-1}$</p></li><li><p>对N节点为使效率最大化，求p，使 $Np(1-p)^{N-1}$ 最大化</p><p>  当N趋近无穷大，取 $Np(1-p)^{N-1}$ 极限，得到 $\frac{1}{e}&#x3D;0.37$</p></li></ul><p> 信道用于有用传输的时间是 37%</p></li></ol><h3 id="非时隙ALOHA"><a href="#非时隙ALOHA" class="headerlink" title="非时隙ALOHA"></a>非时隙ALOHA</h3><ul><li><p>无同步要求</p></li><li><p>当帧到达立即传输</p></li><li><p>碰撞概率增加：在t<del>0</del>发送与在[t<del>0</del>-1, t<del>0</del>+1]的其他帧碰撞</p></li></ul><p><img src="https://s2.loli.net/2022/06/13/dW1ilIBK2yRFUSe.png" alt="ALOHA.png" loading="lazy"></p><p>纯ALOHA的效率仅为时隙ALOHA效率的一半</p><h3 id="CSMA（载波侦听多路访问）"><a href="#CSMA（载波侦听多路访问）" class="headerlink" title="CSMA（载波侦听多路访问）"></a>CSMA（载波侦听多路访问）</h3><ul><li><p>CSMA：在传输前侦听</p><ul><li><p>如果侦听到信道空闲，传输整个帧</p></li><li><p>如果侦听到信道忙，推迟传输</p></li></ul><p>  <em>不要打断他人说话</em></p></li><li><p>CSMA碰撞</p><ul><li><p>碰撞依然会出现：传播时延导致两个节点也许不能听到其他节点传输</p></li><li><p>整个分组传输时间被浪费</p></li><li><p>举例与传播试验</p></li></ul></li></ul><h3 id="CSMA-x2F-CD"><a href="#CSMA-x2F-CD" class="headerlink" title="CSMA&#x2F;CD"></a>CSMA&#x2F;CD</h3><ol><li><p>载波侦听：如同在CSMA</p><ul><li><p>发生碰撞后，在短时间内<strong>检测到碰撞</strong></p></li><li><p>终止碰撞的传输，减少信道浪费</p></li></ul></li><li><p>碰撞检测</p><ul><li><p>在有线的LAN中容易：测量信号强度，比较传输的和接收的信号</p></li><li><p>在无线LAN中困难：无线节点为了节省能源，Frame发送完毕后就会关闭而没有载波</p></li></ul></li></ol><p><em>礼貌的交谈着</em></p><h2 id="”轮流“MAC协议"><a href="#”轮流“MAC协议" class="headerlink" title="”轮流“MAC协议"></a>”轮流“MAC协议</h2><p>信道划分MAC协议：</p><ul><li><p>在高负载时高效、公平地共享信道</p></li><li><p>低负载时低有效：信道访问中延时，有空闲时隙</p></li></ul><p>随机访问MAC协议：</p><ul><li><p>低负载时有效：单个节点能够全面利用信道</p></li><li><p>高负载：碰撞开销</p></li></ul><p>”轮流“协议：</p><ul><li>兼有各方优点</li></ul><h3 id="轮询协议"><a href="#轮询协议" class="headerlink" title="轮询协议"></a>轮询协议</h3><ul><li><p>主节点”邀请“从节点依次传输</p></li><li><p>关注问题：</p><ul><li><p>轮询开销</p></li><li><p>轮询延迟</p></li><li><p>单点故障（主节点）</p></li></ul></li></ul><h3 id="令牌协议"><a href="#令牌协议" class="headerlink" title="令牌协议"></a>令牌协议</h3><ul><li><p>控制令牌从一个节点顺序地传递到下一个</p></li><li><p>令牌报文</p></li><li><p>关注问题：</p><ul><li><p>令牌开销</p></li><li><p>时延</p></li><li><p>单点故障（令牌）</p></li></ul></li></ul><h1 id="链路层编址"><a href="#链路层编址" class="headerlink" title="链路层编址"></a>链路层编址</h1><ul><li><p>IP地址：</p><ul><li><p>网络层地址</p></li><li><p>用于使数据包到达目的IP子网</p></li></ul></li><li><p>MAC（或LAN或物理或以太网）地址</p><ul><li><p>用于使数据包从一个接口到达另一个物理连接的接口（同一个网络内）</p></li><li><p>48 bit MAC地址（对多数LAN）烧在了适配器ROM中</p></li></ul></li></ul><h2 id="ARP：地址解析协议"><a href="#ARP：地址解析协议" class="headerlink" title="ARP：地址解析协议"></a>ARP：地址解析协议</h2><p>问题：已知B的IP地址，怎样决定B的MAC地址？</p><ul><li><p>LAN上的每个IP节点（主机、路由器）都有ARP表</p></li><li><p>ARP表：对某些LAN节点的IP&#x2F;MAC地址映射</p><p>  &lt;IP地址; MAC地址; TTL&gt;</p><ul><li>TTL(寿命)：地址映射将被忘记的时间长度（通常为20分钟）</li></ul></li></ul><h3 id="ARP协议：相同的LAN（网络）"><a href="#ARP协议：相同的LAN（网络）" class="headerlink" title="ARP协议：相同的LAN（网络）"></a>ARP协议：相同的LAN（网络）</h3><ul><li><p>A要向B发送数据报，并且B的MAC地址不再A的ARP表中</p></li><li><p>A<strong>广播</strong>ARP请求分组，包含B的IP地址：</p><ul><li><p>目的地MAC地址&#x3D;FF-FF-FF-FF-FF-FF</p></li><li><p>在LAN上的所有机器接收ARP请求</p></li></ul></li><li><p>B接收ARP分组，用它的MAC地址回答A：帧发送到A的MAC地址（单播）</p></li><li><p>A在它的ARP表中缓存IP到MAC的地址对，直到信息超时。</p><ul><li>软状态：信息超时除非被更新</li></ul></li></ul><p>ARP即插即用：节点创建它们的ARP表无需网络管理员干预</p><h3 id="选路到另一个ARP"><a href="#选路到另一个ARP" class="headerlink" title="选路到另一个ARP"></a>选路到另一个ARP</h3><p>目的：从A到B经R发送数据报。</p><p>A直到B的IP地址</p><p><img src="https://s2.loli.net/2022/06/13/GdxAgawmz3To7cj.png" alt="选路到另一个LAN.png" loading="lazy"></p><p>在路由器R中有两个ARP表，每张表对应一个IP网络（LAN）</p><ol><li><p>A生成具有 <em>源A&amp;目的地B</em> 的数据报</p></li><li><p>A使用ARP从111.111.111.110（R的IP地址）获取R的MAC地址</p></li><li><p>A生成以R的MAC地址作为目的地的链路层帧，帧包含 <em>A-to-B</em> 数据报</p></li><li><p>A的适配器发送帧</p></li><li><p>R的适配器接收帧</p></li><li><p>R从以太网帧取出IP数据报，看到它的目的地是B</p></li><li><p>R使用ARP取得B的MAC地址</p></li><li><p>R生成包含 <em>A-to-B</em> 数据报的帧向B发送</p></li></ol><h1 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h1><ul><li><p>共享式以太网</p><ul><li><p>网络中所有主机的收发都依赖于同一套物理介质，即共享介质</p></li><li><p>同一时刻只能有一台主机在发送，各主机通过遵守CSMA&#x2F;CD规则来保证网络的正常通讯</p></li></ul></li><li><p>交换式以太网</p><ul><li><p>扩展了网络带宽</p></li><li><p>分割了网络冲突域，使得网络冲突被限制在最小的范围内</p></li><li><p>交换机更智能，提供更多功能</p></li></ul></li></ul><h2 id="以太网帧结构"><a href="#以太网帧结构" class="headerlink" title="以太网帧结构"></a>以太网帧结构</h2><p>发送适配器在<strong>以太网帧</strong>（或其他网络层协议分组）中封装IP数据报</p><p><img src="https://s2.loli.net/2022/06/13/aUJRXQN4c7t5efM.gif" alt="以太网帧结构.gif" loading="lazy"></p><ol><li><p>前导码：格式为10101010……，共7字节</p></li><li><p>帧开始定界符：10101011，1字节</p><ul><li>用于同步发送方、接收方时钟速率</li></ul></li><li><p>目的地址、源地址：分别为6字节。当网卡接收到一个数据帧，会检查该帧的目的地址是否与自己匹配，若不匹配，丢弃。</p></li><li><p>类型：指示较高层次协议，2字节。大部分为IP协议。</p></li><li><p>CRC：帧检测字段，4字节。见本文”差错检测“小节</p></li></ol><h2 id="以太网使用CSMA-x2F-CD协议"><a href="#以太网使用CSMA-x2F-CD协议" class="headerlink" title="以太网使用CSMA&#x2F;CD协议"></a>以太网使用CSMA&#x2F;CD协议</h2><ul><li><p>载波侦听：先听再说</p><ul><li>适配器在发送前监听总线是否空闲，若空闲则发送数据</li></ul></li><li><p>冲突检测：边说边听</p><ul><li>数据在发送的同时保持对总线的监听，发现冲突则停止发送</li></ul></li><li><p>随机延迟后重发</p><ul><li>冲突发生后拟采用指数回退方法等待一段随机事件后，再进行监听和发送</li></ul></li></ul><h3 id="指数回退方法"><a href="#指数回退方法" class="headerlink" title="指数回退方法"></a>指数回退方法</h3><ul><li><p>目标：估计当前负载，适应重传尝试</p><ul><li>负载较重：随机等待将更长</li></ul></li><li><p>首次碰撞：从{0,1}中选择K；时延是 $ K • (512bit传输时间) $</p></li><li><p>第二次碰撞后：从{0,1,2,3}中选择K</p></li><li><p>N次碰撞后，从{0,1,…2^N-1}中选择K</p></li></ul><h2 id="曼彻斯特编码（以太网编码技术之一）"><a href="#曼彻斯特编码（以太网编码技术之一）" class="headerlink" title="曼彻斯特编码（以太网编码技术之一）"></a>曼彻斯特编码（以太网编码技术之一）</h2><ul><li><p>用于10 Base T</p></li><li><p>每个比特具有一个跃迁</p></li><li><p>允许发送和接收节点中的时钟互相同步</p><ul><li>节点之间的集中式、全局时钟没有必要</li></ul></li><li><p>位于物理层</p></li></ul><h1 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h1><p>为数据帧从一个端口到另一个任意端口的转发提供了低时延、低开销的通路</p><p>工作在链路层</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><pre class="mermaid">graph BT1(集线器)2(集线器)A --- 1B --- 1C --- 1D --- 2E --- 2F --- 21 --- 交换机2 --- 交换机</pre><p>交换表：</p><table><thead><tr><th>地址</th><th>接口</th></tr></thead><tbody><tr><td>A</td><td>1</td></tr><tr><td>B</td><td>1</td></tr><tr><td>E</td><td>2</td></tr></tbody></table><p>假定C向D发送帧：</p><ol><li><p>交换机从C接收帧</p><ul><li><p>注意到C位于接口1，将C添加入交换表中：</p><table><thead><tr><th>地址</th><th>接口</th></tr></thead><tbody><tr><td>A</td><td>1</td></tr><tr><td>B</td><td>1</td></tr><tr><td>E</td><td>2</td></tr><tr><td>C</td><td>1</td></tr></tbody></table></li><li><p>D不在表中，交换机将向接口2和3转发帧</p></li></ul></li><li><p>D接收帧</p></li></ol><p>假定D回答C的帧</p><ol start="3"><li><p>交换机从D接收帧</p><ul><li><p>注意到D位于接口2，加入交换表中</p><table><thead><tr><th>地址</th><th>接口</th></tr></thead><tbody><tr><td>A</td><td>1</td></tr><tr><td>B</td><td>1</td></tr><tr><td>E</td><td>2</td></tr><tr><td>C</td><td>1</td></tr><tr><td>D</td><td>2</td></tr></tbody></table></li><li><p>因为C在表中，所以直接向接口1转发帧</p></li></ul></li><li><p>C接收帧</p></li></ol><h2 id="流量隔离"><a href="#流量隔离" class="headerlink" title="流量隔离"></a>流量隔离</h2><p>交换机安装将子网分割成LAN段</p><pre class="mermaid">graph BTsubgraph 碰撞域1    1(集线器)    A --- 1    B --- 1    C --- 1endsubgraph 碰撞域2    2(集线器)    D --- 2    E --- 2    F --- 2end1 --- 交换机2 --- 交换机</pre><p>交换机过滤分组：</p><ul><li><p>相同LAN段的帧通常不再其他LAN段上转发</p></li><li><p>段成为分离的碰撞域</p></li></ul><h2 id="交换机vs路由器"><a href="#交换机vs路由器" class="headerlink" title="交换机vs路由器"></a>交换机vs路由器</h2><ul><li><p>路由器位于网络层，检查网络层首部；交换机位于链路层</p></li><li><p>路由器维护选路表，实现选路算法</p></li><li><p>交换机维护交换机表，实现过滤、学习算法</p></li></ul><h1 id="PPP"><a href="#PPP" class="headerlink" title="PPP"></a>PPP</h1><h2 id="点对点链路层控制"><a href="#点对点链路层控制" class="headerlink" title="点对点链路层控制"></a>点对点链路层控制</h2><p>一个发送方、一个接收方、一段链路</p><p>比广播链路容易处理</p><p>无媒体访问控制；不需要明确的MAC编址</p><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>PPP协议是在点对点链路上运行的数据链路层协议</p><p>支持用户认证，是广域网接入使用最广泛的协议</p><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p><img src="https://s2.loli.net/2022/06/13/8XnezjQuigMvDwF.png" alt="PPP协议.png" loading="lazy"></p><ol><li><p>标志字段：0x7E(01111110)，1字节。位于开始和结尾，标志PPP数据帧的开始和结束</p></li><li><p>地址字段：FF(11111111)，1字节。用于指定对方的数据链路层地址，但由于PPP是点对点协议，故此字节无意义，填充为0xFF</p></li><li><p>控制字段：固定值0x03，1字节</p></li><li><p>协议字段：指定上层协议（IP等），2字节</p></li><li><p>数据字段：最长不超过1500字节</p></li><li><p>FSC：校验字段，2字节</p></li></ol><h3 id="字节填充"><a href="#字节填充" class="headerlink" title="字节填充"></a>字节填充</h3><p>PPP帧的标志字段为&lt;01111110&gt;，若在数据字段出现该字节会出错。解决方法为字节填充</p><p>当数据字段出现&lt;01111110&gt;字节时：</p><ul><li><p>发送方：重复填充该字节，即将其变为两连续字节：&lt;01111110&gt;&lt;01111110&gt;</p></li><li><p>接受方：</p><ul><li><p>重复&lt;01111110&gt;&lt;01111110&gt;：丢弃第一个字节，继续数据接收</p></li><li><p>单个&lt;01111110&gt;：标志字节</p></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;数据链路层经一条链路，将数据从一个节点传输到相邻节点&lt;/p&gt;
&lt;p&gt;节点：主机和路由器&lt;/p&gt;
&lt;p&gt;链路：连接通信路径中相邻节点的路径&lt;/</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://sagirichan.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机网络" scheme="http://sagirichan.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="笔记" scheme="http://sagirichan.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>计网复习笔记-网络层</title>
    <link href="http://sagirichan.com/2022/06/13/computer-network-note-networkLayer/"/>
    <id>http://sagirichan.com/2022/06/13/computer-network-note-networkLayer/</id>
    <published>2022-06-12T18:48:11.000Z</published>
    <updated>2022-06-12T18:57:04.261Z</updated>
    
    <content type="html"><![CDATA[<h1 id="虚电路与数据报"><a href="#虚电路与数据报" class="headerlink" title="虚电路与数据报"></a>虚电路与数据报</h1><p>网络层提供服务有两大类：</p><ul><li><p>无连接的网络服务（数据报服务）</p></li><li><p>面向连接的网络服务（虚电路服务）</p></li></ul><h2 id="虚电路"><a href="#虚电路" class="headerlink" title="虚电路"></a>虚电路</h2><ul><li><p>需建立连接</p></li><li><p>由VC号来标识</p></li><li><p>连接状态需要维持，路径上的交换节点都参与</p></li><li><p>涉及资源预留问题</p></li></ul><h3 id="VC号与转发表"><a href="#VC号与转发表" class="headerlink" title="VC号与转发表"></a>VC号与转发表</h3><p>VC号为局部的而非全网的，简化虚电路的连接建立。</p><p>转发表示例：</p><table><thead><tr><th>入接口</th><th>入VC号</th><th>出接口</th><th>出VC号</th></tr></thead><tbody><tr><td>1</td><td>12</td><td>2</td><td>22</td></tr><tr><td>2</td><td>63</td><td>1</td><td>18</td></tr><tr><td>3</td><td>7</td><td>2</td><td>17</td></tr><tr><td>1</td><td>97</td><td>3</td><td>87</td></tr></tbody></table><h3 id="虚电路的三个阶段"><a href="#虚电路的三个阶段" class="headerlink" title="虚电路的三个阶段"></a>虚电路的三个阶段</h3><ul><li><p>虚电路建立</p></li><li><p>数据传输</p></li><li><p>虚电路拆除</p></li></ul><h2 id="数据报网络"><a href="#数据报网络" class="headerlink" title="数据报网络"></a>数据报网络</h2><ul><li><p>在网络层无呼叫建立</p></li><li><p>路由器：没有端到端连接的状态</p><ul><li>无网络级“连接”的概念</li></ul></li><li><p>分组使用目的主机地址转发</p><ul><li>在相同的<strong>源和目的对</strong>可能采用不同的路径</li></ul></li></ul><h3 id="最长前缀匹配"><a href="#最长前缀匹配" class="headerlink" title="最长前缀匹配"></a>最长前缀匹配</h3><p>当路由器收到一个IP数据包时，它会将数据包的目的IP地址与自己本地路由表中的所有路由表进行逐位（Bit-By-Bit）对比，直到找到匹配度最长的条目，这就是最长前缀匹配机制。</p><p>举例：</p><p>存在以下转发表</p><table><thead><tr><th>前缀匹配</th><th>链路接口</th></tr></thead><tbody><tr><td>11001000 00010111 00010</td><td>0</td></tr><tr><td>11001000 00010111 00011000</td><td>1</td></tr><tr><td>11001000 00010111 00011</td><td>2</td></tr><tr><td>otherwise</td><td>3</td></tr></tbody></table><p>① 目的地址 11001000 00010111 00011 哪个接口？（0）<br>② 目的地址 11001000 00010111 00011000 10101010 哪个接口？（1）</p><h1 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h1><p>不可靠的、尽力而为的、无连接分组交付系统</p><h2 id="IP数据报格式"><a href="#IP数据报格式" class="headerlink" title="IP数据报格式"></a>IP数据报格式</h2><p><img src="https://s2.loli.net/2022/06/12/jslcdBaDtHyzW6k.gif" alt="IP数据报格式.gif" loading="lazy"></p><table border="1" cellspacing="0">    <tr>        <td colspan="4" align="center"> [4位]版本 </td>         <td colspan="4" align="center"> [4位]首部长度 </td>        <td colspan="8" align="center"> [8位]服务类型 </td>        <td colspan="16" align="center" width="50%" > [16位]总长度 </td>    </tr>    <tr>        <td colspan="16" align="center"> [16位]标识 </td>        <td colspan="3" align="center"> [3位]标志 </td>        <td colspan="13" align="center"> [13位]片偏移 </td>    </tr>    <tr>        <td colspan="8" align="center"> [8位]生存时间 </td>        <td colspan="8" align="center"> [8位]协议 </td>        <td colspan="16" align="center"> [16位]首部检验和 </td>    </tr>    <tr>        <td colspan="32" align="center"> 源地址 </td>    </tr>    <tr>        <td colspan="32" align="center"> 目的地址 </td>    </tr>    <tr>        <td colspan="32" align="center"> ---- 可选字段（长度可变）---- || ---- 填充 ---- </td>    </tr>    <tr>        <td colspan="32" align="center"> 数据部分 </td>    </tr></table><ul><li><p>版本：4位。表示IP协议版本</p></li><li><p>首部长度：4位。可表示的最大十进制数值为15。单位为【32位字长】（4字节）即：该字段数值为<strong>1</strong>时，表示首部长度为<strong>32位（4字节）</strong>；又由该字段最大值为1111，首部长度最大为60位。</p><p>  当IP首部长度不是32的整数倍时，用结尾的填充部分填充至整数倍。</p></li><li><p>服务类型：8位。只有在使用区分服务时，该字段才起作用</p></li><li><p>总长度：16位。首部+数据的长度之和，单位为字节。故首部+数据总长度最大值为2^16^-1&#x3D;65535字节</p></li><li><p>标识：16位。</p><ul><li><p>IP协议在存储器中维持一个计数器，每产生一个数据包，计数器就+1，并将值赋给标识字段。</p></li><li><p>当数据包的长度超过网络的MTU而必须分片时，这个标识字段的值就被复制到所有分片中</p></li><li><p>拥有相同标识字段值的分片会被重组呈原来的数据报。</p></li></ul></li><li><p>标志：3位。</p><ul><li><p>第一位未使用，值为0</p></li><li><p>第二位称为DF（不分片），表示是否允许分片：</p><ul><li><p>取值为0时，表示允许分片</p></li><li><p>取值为1时，表示不允许分片</p></li></ul></li><li><p>第三位称为MF（更多分片），表示是否还有分片正在传输。设为0时表示没有更多分片需要发送。</p></li></ul></li><li><p>片偏移：13位。当报文被分片后，该字段标记该分片在原报文中的相对位置。片偏移单位为【8字节】。</p></li><li><p>生存时间（TTL）：8位。表示数据包在网络中的寿命，由发出数据包的源主机设置，目的是防止无法交付的数据报无限制地在网络中传输，从而消耗网络资源。</p><p>  路由器在转发数据报之前，先把TTL值-1，若TTL值减少到0，则丢弃这个数据报，不再转发。</p><p>  TLL最大值为255（2^8^-1），若把TTL初始值设为1，则表明这个数据包只能在本局域网中传送。</p></li><li><p>协议：8位。表示数据部分使用的协议（TCP：6；UDP：17；ICMP：1……）</p></li><li><p>首部检验和：16位。校验数据报的首部。</p></li><li><p>源地址：32位。</p></li><li><p>目的地址：32位。</p></li></ul><h2 id="IP-分片和重新组装"><a href="#IP-分片和重新组装" class="headerlink" title="IP 分片和重新组装"></a>IP 分片和重新组装</h2><ul><li><p>网络链路有MTU（最大传输长度）-最大可能都链路级帧</p></li><li><p>在网络中，大IP数据报被分割（分段）</p><ul><li><p>一个数据报变为几个数据报</p></li><li><p>仅在最后目的地“重新装配”</p></li><li><p>IP首部比特用于标识\排序相关段</p></li></ul></li></ul><p>举例：</p><p>MTU &#x3D; 1500字节；下方为一个4000字节的数据报</p><table><thead><tr><th>长度</th><th>ID</th><th>MF位</th><th>偏移</th></tr></thead><tbody><tr><td>4000</td><td>X</td><td>0</td><td>0</td></tr></tbody></table><p>分片后产生以下三个数据报：</p><table><thead><tr><th>长度</th><th>ID</th><th>MF位</th><th>偏移</th></tr></thead><tbody><tr><td>1500</td><td>X</td><td>1</td><td>0</td></tr></tbody></table><table><thead><tr><th>长度</th><th>ID</th><th>MF位</th><th>偏移</th></tr></thead><tbody><tr><td>1500</td><td>X</td><td>1</td><td>185</td></tr></tbody></table><table><thead><tr><th>长度</th><th>ID</th><th>MF位</th><th>偏移</th></tr></thead><tbody><tr><td>1040</td><td>X</td><td>0</td><td>370</td></tr></tbody></table><p>长度&#x3D;数据段1480+首部20&#x3D;1500（字节）</p><p>偏移&#x3D;$\frac{1480}{8}&#x3D;185$</p><h2 id="IP地址表示方式：点分十进制法"><a href="#IP地址表示方式：点分十进制法" class="headerlink" title="IP地址表示方式：点分十进制法"></a>IP地址表示方式：点分十进制法</h2><p>每<strong>8位</strong>一组，用十进制表示，并利用点号分割各部分，可以表示为从<code>0.0.0.0</code>到<code>255.255.255.255</code></p><p>IP地址结构：</p><p>两级IP：{ &lt;网络号&gt; + &lt;主机号&gt; }</p><p>三级IP：{ &lt;网络号&gt; + &lt;子网号&gt; + &lt;主机号&gt; }</p><p>如图：</p><p><img src="https://s2.loli.net/2022/05/09/x7BGkZOAhSz82TD.png" alt="IP地址结构.png" loading="lazy"></p><ul><li><p>ABCDE五类网络：</p><p>  以IP地址结构为W.X.Y.Z来说明：</p><ul><li><p>A类：</p><ul><li><p>网络ID占用一个字节W，W第一位固定为0，剩余7位可用， 又因为IP地址中0.与127.要保留，故可用的7位取值范围为二进制的000 0001到111 1110，即十进制的1-126，即它可以提供126个A类的网络ID。</p></li><li><p>主机ID共占用X、Y、Z字节（24位），此24位可以支持（2^24^）-2&#x3D;16777214台主机。</p></li></ul></li><li><p>B类：</p><ul><li><p>网络ID占用两个字节W、X。W前两位固定为10，后六位范围为00 0000~11 1111；故整个W的范围为128(1000 0000)到191(1011 1111)，X的范围为0到255，故它可提供(191-128+1)*256&#x3D;16384个B类的网络。</p><p>  又∵128.0.0.0与191.255.0.0为保留位，故实际上可提供的网络ID为16384-2&#x3D;16382个。</p></li><li><p>主机ID共占用Y、Z两个字节，因此每个网络可支持（2^16^）-2 &#x3D; 65534台主机</p></li></ul></li><li><p>C类：</p><ul><li><p>其网络ID占用三个字节W、X、Y。W前三位固定为110，故其范围为192(1100 0000)到223(1101 1111)，它可以提供（223-192+1）* 256*256&#x3D;2097152个C类的网络。（保留位同上，不再复述）</p></li><li><p>主机ID只占用一个字节Z，因此每个网络可支持（2^8^）-2&#x3D;254台主机</p></li></ul></li><li><p>D类：它是组播(multicast，或译为多播)所使用多组ID（group id），这个组内包含着多台主机。W前四位固定为1110，范围为224到239</p></li><li><p>E类：它保留给未来使用或供实验用途，W前四位固定为1111，范围为240到254</p></li></ul><p>  地址范围（包括网络地址本身，广播地址，私有地址等）</p><p>  A类：1.0.0.0      ~  127.255.255.255</p><p>  B类：128.0.0.0  ~  191.255.255.255</p><p>  C类：192.0.0.0  ~  223.255.255.255</p><p>  D类：224.0.0.0  ~  239.255.255.255</p><p>  E类：240.0.0.0  ~  247.255.255.255</p></li></ul><h2 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h2><p>子网掩码用二进制标识，也是一个32位的数字，对应IP地址网络标识部分的位（网络号 + 子网号）全部为1，对应IP地址主机标识的部分都为0。</p><p>子网掩码不能单独使用，必须结合IP地址，它屏蔽IP地址的一部分以区别网络标识和主机标识，并说明该IP地址是局域网还是远程网。</p><p>10001101    00001110  01001000  00011000  IP：141.14.72.24</p><p>11111111    11111111  11000000  00000000  掩码：255.255.292.0</p><p>以IP逐位并掩码：</p><p>10001101    00001110  01000000  00000000  网络地址：141.14.64.0</p><h2 id="无类型域间选路-Classless-InterDomain-Routing-CIDR"><a href="#无类型域间选路-Classless-InterDomain-Routing-CIDR" class="headerlink" title="无类型域间选路 (Classless InterDomain Routing) CIDR"></a>无类型域间选路 (Classless InterDomain Routing) CIDR</h2><p>若子网号连续，则可以用斜号+数字表示网络部分的长度。</p><p>某地址块为200.23.16.0&#x2F;23，则其</p><p>子网掩码为：255.255.254.0(<br>    <strong>11111111.11111111.1111111</strong>0.0000)</p><p>网络地址为：200.23.16.0 (主机比特全0)(<br><strong>11001000.00010111.0001000</strong>0.00000000)</p><p>可用主机地址为：200.23.16.1~200.23.17.254(<br><strong>11001000.00010111.0001000</strong>0.00000001 ~<br><strong>11001000.00010111.0001000</strong>1.11111110)</p><p>广播地址为：200.23.17.255 (主机比特全1) (<br><strong>11001000.00010111.0001000</strong>1.11111111)</p><h2 id="子网掩码应用"><a href="#子网掩码应用" class="headerlink" title="子网掩码应用"></a>子网掩码应用</h2><h3 id="一"><a href="#一" class="headerlink" title="一"></a>一</h3><p>某A类网络20.0.0.0的子网掩码为255.224.0.0，请确定可以划分的子网个数，写出每个子网的子网号。</p><blockquote><p>解析：A类网络子网掩码默认为255.0.0.0，所以多出来的224就是子网号，也就是11100000。前三位全是1，所以子网号占据前三位，共有2^3^&#x3D;8个子网个数</p></blockquote><p>解答：A类网络的默认子网掩码为255.0.0.0，根据题意，第二个字节的子网掩码为224，即11100000，可知该网络使用第二个字节的前三个比特进行了子网划分，因此划分的子网数为2^3^&#x3D;8</p><p>8个子网号分别为：</p><p>20.<strong>000</strong>00000.0.0 即 20.<strong>0</strong>.0.0<br>20.<strong>001</strong>00000.0.0 即 20.<strong>32</strong>.0.0<br>20.<strong>010</strong>00000.0.0 即 20.<strong>64</strong>.0.0<br>20.<strong>011</strong>00000.0.0 即 20.<strong>96</strong>.0.0<br>20.<strong>100</strong>00000.0.0 即 20.<strong>128</strong>.0.0<br>20.<strong>101</strong>00000.0.0 即 20.<strong>160</strong>.0.0<br>20.<strong>110</strong>00000.0.0 即 20.<strong>192</strong>.0.0<br>20.<strong>111</strong>00000.0.0 即 20.<strong>224</strong>.0.0</p><h3 id="二"><a href="#二" class="headerlink" title="二"></a>二</h3><p>将某c类网200.161.30.0划分为4个子网，请计算出每个子网的有效的主机IP地址范围和对应的子网掩码。</p><blockquote><p>解析：C类网络占据三个字节，默认子网掩码为255.255.255.0。划分子网需要在最后一个字节上添加掩码，由于要划分为4个子网，故使用2位掩码，剩余6位为主机IP使用范围。</p></blockquote><p>解答：解析见上方</p><p>子网掩码为255.255.255.<strong>11</strong>000000 即 255.255.255.192</p><p>两位掩码提供了4个子网IP容量，分别是：</p><p>200.161.30.<strong>00</strong>000000 即 200.161.30.<strong>0</strong><br>200.161.30.<strong>01</strong>000000 即 200.161.30.<strong>64</strong><br>200.161.30.<strong>10</strong>000000 即 200.161.30.<strong>128</strong><br>200.161.30.<strong>11</strong>000000 即 200.161.30.<strong>192</strong></p><p>每个子网内的有效主机IP范围分别是：</p><p><code>子网IP</code>+000001 ~ <code>子网IP</code>+111110</p><h3 id="三"><a href="#三" class="headerlink" title="三"></a>三</h3><p>某公司申请到的网络地址为192.3.2.0，现要划分给5个子公司，最大的一个子公司有28台计算机，每个子公司在一个子网中，则<br>(1) 子网掩码应是多少？<br>(2) 5个子公司的网络地址分别是什么？</p><blockquote><p>解析：由第一个字节为192判断出该地址为c类地址。由于要5个子网，2^2^&lt;5&lt;2^3^，故应使用3位子网掩码，提供8个子网IP容量。<br>剩下5位可以提供2^5^-2&#x3D;30个IP地址，足够供应28台机器。。</p></blockquote><p>解答：192.3.2.0为C类地址，默认子网掩码为255.255.255.0。要划分子网，应在最后一个字节处添加掩码。</p><p>由于要划分为5个子网，故使用3位掩码</p><p>即255.255.255.11100000，即255.255.255.224</p><p>5个子公司的网络地址可以在以下8个IP中选择：</p><p>192.3.2.<strong>000</strong>00000 即 192.3.2.<strong>0</strong><br>192.3.2.<strong>001</strong>00000 即 192.3.2.<strong>32</strong><br>192.3.2.<strong>010</strong>00000 即 192.3.2.<strong>64</strong><br>192.3.2.<strong>011</strong>00000 即 192.3.2.<strong>96</strong><br>192.3.2.<strong>100</strong>00000 即 192.3.2.<strong>128</strong><br>192.3.2.<strong>101</strong>00000 即 192.3.2.<strong>160</strong><br>192.3.2.<strong>110</strong>00000 即 192.3.2.<strong>192</strong><br>192.3.2.<strong>111</strong>00000 即 192.3.2.<strong>224</strong></p><h3 id="四"><a href="#四" class="headerlink" title="四"></a>四</h3><p>某单位申请了一段IP地址：200.23.16.0&#x2F;23。单位内由4个部门(A,B,C,D)组成，每个部门的主机数量分别是：200(A), 100(B), 50(C), 40(D)。试将单位的总地址块200.23.16.0&#x2F;23划分为4个子网分配各4个部门。</p><ol><li>写出每个子网（地址块）</li><li>每个子网的网络前缀？子网掩码？</li><li>每个子网的广播地址？主机可用地址范围？</li></ol><p>注：200.23.16.0&#x2F;23的二进制表示<br><ins><strong>11001000  00010111  0001000</strong></ins>0  00000000 </p><blockquote><p>解析：2^8^-2 &gt; 200 &gt; 2^7^-2 &gt; 100 &gt; 2^6^-2 &gt; 50&gt;40 &gt; 2^5^-2<br>故A公司至少使用8位主机IP，B公司至少使用7位，C&#x2F;D至少使用6位<br>即A可以使用子网网络前缀&#x2F;24，B可以使用&#x2F;25，C&#x2F;D可以使用&#x2F;26</p></blockquote><p>解答：（解析略，见上文）</p><p>故存在以下方法划分子网：</p><p>A：<strong>11001000  00010111  0001000</strong><code>0</code>  00000000<br>子网网络前缀&#x2F;24 子网掩码255.255.255.0<br>子网广播地址200.23.16.255 主机可用地址范围：200.23.16.00000001~200.23.16.11111110<br>B：<strong>11001000  00010111  0001000</strong><code>1  0</code>0000000 子网网络前缀&#x2F;25 略<br>C：<strong>11001000  00010111  0001000</strong><code>1  10</code>000000 子网网络前缀&#x2F;26 略<br>D：<strong>11001000  00010111  0001000</strong><code>1  11</code>000000 子网网络前缀&#x2F;26 略</p><h2 id="私有地址"><a href="#私有地址" class="headerlink" title="私有地址"></a>私有地址</h2><p>在互联王中不使用，仅在局域网中使用的IP地址</p><ul><li><p>10.X.X.X A类</p></li><li><p>172.16.0.0~172.31.255.255 B类</p></li><li><p>192.168.X.X C类</p></li></ul><h2 id="NAT技术"><a href="#NAT技术" class="headerlink" title="NAT技术"></a>NAT技术</h2><p>所有数据报离开本地网络具有相同的单一源地址：NAT IP地址；拥有不同的源端口号</p><p>示例：</p><p>存在NAT转换表</p><table><thead><tr><th>LAN侧地址（内网地址）</th><th>WAN侧地址（公网地址）</th></tr></thead><tbody><tr><td>10.0.0.1 : 3345</td><td>138.76.29.7 : 5001</td></tr><tr><td>……</td><td>……</td></tr></tbody></table><p>存在NAT结构：</p><pre class="mermaid">graph LR    subgraph NAT        LAN(LAN 10.0.0.4) --> WAN(WAN 138.76.29.7)    end    1(主机一 10.0.0.1) --> LAN    2(主机二 10.0.0.2) --> LAN    3(主机三 10.0.0.3) --> LAN    WAN --> 公网</pre><p>主机一与外网交流过程：</p><p>① 主机10.0.0.1发送数据报到128.119.40.186:80</p><p>② NAT路由器将数据报源地址从10.0.0.1:3345改变到138.76.29.7:5001，更新表</p><p>[目的地处理数据报…]</p><p>③ 回答返回到目的地址138.76.29.7:5001</p><p>④ NAT将数据报目的地址从138.76.29.7:5001改变到138.76.29.7:5001</p><h2 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h2><p>IP网络尽力而为，不可靠，ICMP通过差错报文和询问报文来辅助IP网络的功能</p><h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><p>懒得写</p><h1 id="选路算法"><a href="#选路算法" class="headerlink" title="选路算法"></a>选路算法</h1><p>选路协议：决定从源到目的地通过网络的“好的路径”（路由器序列）</p><h2 id="链路状态选路算法"><a href="#链路状态选路算法" class="headerlink" title="链路状态选路算法"></a>链路状态选路算法</h2><h3 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h3><ul><li><p>所有节点知道网络拓扑、链路费用</p><ul><li><p>经“链路状态广播”完成</p></li><li><p>所有节点具有相同信息</p></li></ul></li><li><p>从一个节点到所有其他节点计算最低费用路径</p><ul><li>给出对这些节点的转发表</li></ul></li><li><p>迭代：k次迭代后，得知k个目的地的最低费用路径</p></li></ul><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li><p>D(v)：从源到目的地v，沿着最低费用路径的费用</p></li><li><p>c(x,y)：从节点x到y的链路费用；若xy不相邻，则c(x,y) &#x3D; ∞</p></li><li><p>p(v)：从源到v沿最低费用路径，v的前一个节点</p></li><li><p>N’：一个节点集合，如果从源节点到v的最低费用路径已知，则v在N’中</p></li></ul><h3 id="具体算法"><a href="#具体算法" class="headerlink" title="具体算法"></a>具体算法</h3><h4 id="初始化："><a href="#初始化：" class="headerlink" title="初始化："></a>初始化：</h4><ol><li><p>N’&#x3D;{u} （u为源节点）</p></li><li><p>对所有节点v：</p></li></ol><p>if v临近u:<br>    D(v)&#x3D;c(u,v)<br>else:<br>    D(v) &#x3D; ∞</p><h4 id="算法开始："><a href="#算法开始：" class="headerlink" title="算法开始："></a>算法开始：</h4><ol><li><p>找出不在N’中，且D(w)最小的w</p></li><li><p>将w加入N’中</p></li><li><p>对于所有v临近w并且不在N’中，更新D(v)：<br> D(v) &#x3D; min( D(v), D(w)+c(w,v) )<br> &#x2F;*到v的新费用或是到v的老费用，或是到w加上从w到v的已知最短路费用*&#x2F;</p></li><li><p>重复1~3，直到所有点都在N’中</p></li></ol><h3 id="算法复杂性："><a href="#算法复杂性：" class="headerlink" title="算法复杂性："></a>算法复杂性：</h3><p>对于n个节点</p><p>每次迭代：需要检查所有不在N中的节点</p><h2 id="距离矢量算法"><a href="#距离矢量算法" class="headerlink" title="距离矢量算法"></a>距离矢量算法</h2><h3 id="动态规划算法"><a href="#动态规划算法" class="headerlink" title="动态规划算法"></a>动态规划算法</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><ul><li><p>d<del>x</del>(y)：从x到y最低费用路径的费用</p></li><li><p>方程：d<del>x</del>(y) &#x3D; min<del>v</del>{ c(x,v) + d<del>v</del>(y) }</p><p>  v表示x的邻居，min<del>v</del>{}表示对x的所有邻居遍历</p></li></ul><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><p>对于每个节点x</p><ol><li><p>在每个节点建立自己的距离向量表并初始化</p></li><li><p>每个节点将自己维护的距离向量表向其邻居节点转发</p></li><li><p>每个节点收到邻居节点发送的距离向量表以后，基于新的信息采用方程来更新自己的距离向量表</p></li><li><p>当自己的距离向量表发生变化时，将新的距离向量表发送给自己的邻居节点，如果与以前的向量表相同则不向其邻居节点转发，知道每个节点的距离向量表达到稳定为止</p></li></ol><p>应用举例：</p><p><img src="https://s2.loli.net/2022/06/12/otcE3bJYAkvuV9Q.png" alt="距离矢量算法举例.png" loading="lazy"></p><p>要求d<del>u</del>(z)，显然已知d<del>v</del>(z)&#x3D;5，d<del>x</del>(z)&#x3D;3，d<del>w</del>(z)&#x3D;3</p><p>则d<del>u</del>(z) &#x3D; min{<br>    c(u,v) + d<del>v</del>(z),<br>    c(u,x) + d<del>x</del>(z),<br>    c(u,w) + d<del>w</del>(z)<br>} &#x3D; min{<br>    2 + 5,<br>    1 + 3,<br>    5 + 3<br>} &#x3D; 4</p><h4 id="迭代、异步"><a href="#迭代、异步" class="headerlink" title="迭代、异步"></a>迭代、异步</h4><p>每次本地迭代由下列引起：</p><ul><li><p>本地链路费用改变</p></li><li><p>DV从邻居更新报文</p></li></ul><p>如果DV变化，通知邻居</p><h1 id="互联网中选路"><a href="#互联网中选路" class="headerlink" title="互联网中选路"></a>互联网中选路</h1><h2 id="“距离”的定义"><a href="#“距离”的定义" class="headerlink" title="“距离”的定义"></a>“距离”的定义</h2><ul><li><p>从一路由器到直接连接的网络的距离定义为1</p></li><li><p>从一个路由器到非直接连接的网络的距离定义为所经过的路由器数+1</p></li><li><p>RIP协议中的“距离”也称为“跳数”，因为每经过一个路由器，跳数就+1</p></li><li><p>RIP认为一个好的路由就是经过的路由器数目少，即“距离短”</p></li><li><p>RIP允许一条路径最多只能包含15个路由器，“距离”的最大值为16时认为不可达</p></li></ul><h2 id="RIP协议的三个要点"><a href="#RIP协议的三个要点" class="headerlink" title="RIP协议的三个要点"></a>RIP协议的三个要点</h2><ul><li><p>仅和相邻路由器交换信息</p></li><li><p>交换的信息是当前本路由器所知道的全部信息</p></li><li><p>按固定的时间间隔交换路由信息</p></li></ul><h2 id="路由表的建立"><a href="#路由表的建立" class="headerlink" title="路由表的建立"></a>路由表的建立</h2><ul><li><p>路由器在刚刚开始工作时，只知道到之间连接的网络的距离（该距离定义为1）</p></li><li><p>之后，每一个路由器也之和相邻的路由器交换并更新路由信息</p></li><li><p>经过若干次更新后，所有路由器最终都会知道本自治系统中任何一个网络的最短距离和下一跳路由器的地址</p></li></ul><h2 id="距离向量算法"><a href="#距离向量算法" class="headerlink" title="距离向量算法"></a>距离向量算法</h2><p>收到邻居的路由器表，将所有“距离”字段+1</p><ol><li><p>若收到的项目不在路由器表中，加入</p></li><li><p>若收到的项目距离小于路由器表中的记录，更新</p></li></ol><p>若三分钟没有收到相邻路由器的更新，将该邻居设为16，不可到达。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;虚电路与数据报&quot;&gt;&lt;a href=&quot;#虚电路与数据报&quot; class=&quot;headerlink&quot; title=&quot;虚电路与数据报&quot;&gt;&lt;/a&gt;虚电路与数据报&lt;/h1&gt;&lt;p&gt;网络层提供服务有两大类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;无连接的网络服务（数据报服务）&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://sagirichan.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机网络" scheme="http://sagirichan.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="笔记" scheme="http://sagirichan.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>计网复习笔记-传输层</title>
    <link href="http://sagirichan.com/2022/06/12/computer-network-note-transportLayer/"/>
    <id>http://sagirichan.com/2022/06/12/computer-network-note-transportLayer/</id>
    <published>2022-06-12T05:01:07.000Z</published>
    <updated>2022-06-12T19:04:49.626Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分解与复用"><a href="#分解与复用" class="headerlink" title="分解与复用"></a>分解与复用</h1><p>主机使用IP地址&amp;端口号将报文段导向到相应的套接字</p><p>具有不同源IP地址和&#x2F;或源端口号的IP数据报（目的IP地址和端口号相同）定向到相同的套接字</p><p>源IP地址和源端口号提供了返回地址</p><hr><h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><ul><li><p>尽力而为</p><ul><li>丢包</li><li>对应用程序交付失序</li></ul></li><li><p>无连接</p><ul><li>在UDP发送方和接收方之间无握手</li><li>每个UDP段的处理独立于其他段</li></ul></li></ul><p>常用于流媒体应用程序</p><ul><li>丢包容忍</li><li>速率敏感</li></ul><h2 id="UDP报文结构："><a href="#UDP报文结构：" class="headerlink" title="UDP报文结构："></a>UDP报文结构：</h2><table>    <tr>        <td> [16位]源端口 </td>         <td> [16位]目的端口 </td>     </tr>    <tr>        <td> [16位]长度 </td>         <td> [16位]检查和 </td>     </tr>    <tr>           <td colspan="2" align="center"> 数据 </td>        </tr></table><h3 id="UDP检查和："><a href="#UDP检查和：" class="headerlink" title="UDP检查和："></a>UDP检查和：</h3><p>对发送方的UDP报文段的所有16比特字进行<strong>求和</strong>。当求和遇见溢出的时候，进行<strong>回卷</strong>。求和结束后再进行<strong>反码</strong>运算，得到的结果放在UDP报文段中的检验和字段。</p><p><img src="https://s2.loli.net/2022/05/11/P8S9z3eQTtqn1Kl.png" alt="UDP检查和举例.png" loading="lazy"></p><hr><h1 id="rdt协议（可靠传输协议）"><a href="#rdt协议（可靠传输协议）" class="headerlink" title="rdt协议（可靠传输协议）"></a>rdt协议（可靠传输协议）</h1><p>不可靠信道需要可靠运输协议。</p><h2 id="rdt1-0"><a href="#rdt1-0" class="headerlink" title="rdt1.0"></a>rdt1.0</h2><p>rdt1.0：完全可靠信道上的可靠数据传输。</p><ul><li><p>底层信道完全可靠</p></li><li><p>发送方将数据发向底层信道</p></li><li><p>接收方从底层信道接收数据</p></li></ul><p><img src="https://s2.loli.net/2022/05/11/cB5A3jE2tIOoYL8.png" alt="rdt1.0.png" loading="lazy"></p><h2 id="rdt2-0"><a href="#rdt2-0" class="headerlink" title="rdt2.0"></a>rdt2.0</h2><p>rdt2.0：具有比特差错的信道。</p><ul><li><p>具有比特差错的底层信道</p><ul><li><p><strong>有</strong>比特差错</p></li><li><p><strong>无</strong>分组丢失</p></li></ul></li><li><p>数据出错后处理方式</p><ul><li>检错重传</li></ul></li><li><p>rdt2.0新增加机制（与rdt1.0比较）</p><ul><li><p>检错</p></li><li><p>反馈：ACK, NAK</p><ul><li><p>ACKnowledge Character</p></li><li><p>Negative Acknowledgment</p></li></ul></li><li><p>重传</p></li></ul></li></ul><h3 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h3><ul><li><p>无差错时情况：</p><p>  <img src="https://s2.loli.net/2022/05/11/VT8aovjLNJS7XuE.png" alt="rdt2.0无差错.png" loading="lazy"></p></li><li><p>有差错时情况</p><p>  <img src="https://s2.loli.net/2022/05/11/ZeXpNx23qDEJzdP.png" alt="rdt2.0有差错.png" loading="lazy"></p></li></ul><p>流程图：</p><pre class="mermaid">graph LR发送方产生数据 --> 发送数据 --> C[接收方接收并分析数据]C -.-> A((有差错)) -.返回 rdt_rcv & isNAK.-> 发送数据C --> B((无差错)) --返回 rdt_rcv & isACK--> 发送方产生数据</pre><h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><p>没有考虑ACK、NAK发生缺损的情况。</p><ul><li><p>如果ACK发生翻转，发送方会重传</p></li><li><p>如果NAK发生翻转，发送方会误以为发送成功而不重传正确数据</p></li></ul><h2 id="rdt2-1"><a href="#rdt2-1" class="headerlink" title="rdt2.1"></a>rdt2.1</h2><p>在2.0的基础上，发送方为每个发送出去的数据包添加0或1的序号，接收方只有在按顺序依次接收到0、1、0、1…号数据包时才会接受数据。</p><p>假设发送0号数据包：</p><ul><li><p>接收方成功接受数据包，返回ACK，等待1号数据包；但是ACK发生了翻转，发送方收到NAK：</p><p>  发送方重传0号数据包，接收方不接受0号数据包，将数据包丢弃，并再次返回对0号数据包的ACK</p></li><li><p>接收方接收到破损数据包，返回NAK，继续等待0号数据包；但是NAK发生了翻转，发送方收到ACK：</p><p>  发送方传输1号数据包，由于接收方在等待0号数据包，故接收到此数据包后不改变状态，继续等待0号数据包，并返回对1号数据包的ACK</p></li></ul><p>（很惭愧，我从这里开始理解不了状态机图了，也无法解释清楚协议内容。）</p><h2 id="rdt2-2"><a href="#rdt2-2" class="headerlink" title="rdt2.2"></a>rdt2.2</h2><p>rdt2.2与2.1的区别在于去掉了NAK，而在ACK分组中显式指出分组编号。</p><p>在收到非期望分组或者收到的分组发生比特差错时，均对上次正确接收的分组反馈一个ACK。</p><h2 id="rdt3-0"><a href="#rdt3-0" class="headerlink" title="rdt3.0"></a>rdt3.0</h2><p>3.0同时考虑到封包遗失与资料错误的情形，除了使用ACK机制，另外在传送端多了倒数计时器，封包送出去如果超过时间仍未收到ACK或是收到不正确编号的ACK，则再送出封包一次。</p><ul><li><p>无丢包时如图：</p><p>  <img src="https://s2.loli.net/2022/05/11/gVuf8Z6kBOEeMKa.png" alt="rdt3.0无丢包.png" loading="lazy"></p></li><li><p>分组丢失时如图：</p><p>  <img src="https://s2.loli.net/2022/05/11/iNjonQRZdkmqBGy.png" alt="rdt3.0分组丢失.png" loading="lazy"></p></li><li><p>ACK丢失时如图：</p><p>  <img src="https://s2.loli.net/2022/05/11/ZDaCXKNAqHzGgsW.png" alt="rdt3.0ACK丢失.png" loading="lazy"></p></li></ul><p>（写的是些什么寄吧，我在制造文字垃圾）</p><p><img src="https://s2.loli.net/2022/05/11/d6R8QTStiHfoaFy.png" alt="rdt3.0窗口太窄_过早重传.png" loading="lazy"></p><h2 id="协议性能"><a href="#协议性能" class="headerlink" title="协议性能"></a>协议性能</h2><h3 id="停等协议"><a href="#停等协议" class="headerlink" title="停等协议"></a>停等协议</h3><p>每发送一个分组，都要等待接收方回应。</p><p><img src="https://s2.loli.net/2022/05/11/PoWLftrKmYkwyCb.png" alt="停等协议.png" loading="lazy"></p><p>记分组长度为L，信道速率为R，则传输单个分组时间为：</p><p>$$\frac{L}{R}+RTT$$</p><p>信道利用率为：</p><p>$$\frac { \frac{L}{R} } {RTT + \frac{L}{R}}$$</p><h3 id="流水线协议"><a href="#流水线协议" class="headerlink" title="流水线协议"></a>流水线协议</h3><p>序号范围增加、发送方与接收方设置缓存。</p><p>假设每次连续传输3个分组：</p><p><img src="https://s2.loli.net/2022/05/11/e4oLcUEfMnmF1jA.png" alt="流水线协议.png" loading="lazy"></p><p>信道利用率为：</p><p>$$\frac { 3\frac{L}{R} } {RTT + \frac{L}{R}}$$</p><p>是停等协议的三倍。</p><h3 id="滑动窗口协议"><a href="#滑动窗口协议" class="headerlink" title="滑动窗口协议"></a>滑动窗口协议</h3><p>为了提高效率填满管道，在发送方等待确认时，应当有多个分组正在传送中。也就是说我们需要让多个分组处于等待确认的状态，以便在发送方等待确认的同时，信道也能保持忙碌状态。</p><ul><li><p>发送方和接收方都具有一定容量的缓冲区（即窗口），允许发送方连续发送多个帧而不需要等待应答。</p></li><li><p><strong>发送窗口</strong>就是发送端允许连续发送的帧的序号表，发送端可以不等待应答而连续发送的最大帧数称为发送窗口的尺寸</p></li><li><p><strong>接收窗口</strong>是接收方允许接收的帧的序号表，凡落在接收窗口内的帧，接收方都必须处理，落在接收窗口外的帧被丢弃。接收方每次允许接收的帧数称为接收窗口的尺寸</p></li></ul><h4 id="Go-Back-N协议"><a href="#Go-Back-N协议" class="headerlink" title="Go-Back-N协议"></a>Go-Back-N协议</h4><p>返回N协议(GO-Back-N GBN)的关键是发送方能够在收到确认之前发送多个分组，但接收方只能缓存一个分组。发送方为发送出去的分组保留副本，直到来自接收方确认达到。</p><p><img src="https://s2.loli.net/2022/06/12/ViEubBfcklmW5Kg.png" alt="GBN协议.png" loading="lazy"></p><p><img src="https://s2.loli.net/2022/06/12/tSuHBL9daEJGfpU.png" alt="GBN发送窗口.png" loading="lazy"></p><ul><li><p>ACK机制：</p><p>  确认ACK(n): 确认到序列号n(包含n)的分组均已被正确接收，可能收到重复ACK。</p></li><li><p>累积确认：</p><p>  发送拥有最高序列号的、已被正确接收的分组的ACK。</p><p>  接收方不需要给收到的数据分组逐个发送确认，而是可以在收到几个数据分组后对按序到达的最后一个数据分组发送确认，ACK(n)表示序号为n及之前的所有数据分组都已经成功接收</p></li></ul><p>示例：</p><p><img src="https://img-blog.csdnimg.cn/b5d578b5330e42ceb61c9744373a87bb.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAUGFyYW5vaWTimIY=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="GBN示例" loading="lazy"></p><p>解释：窗口大小为4，发送方发送数据包0，1，2，3，然后进入等待状态，其中数据包2丢失，接收方返回Ack0，1，窗口滑动继续发送包4，5，此时包2计时超时，默认数据包2没有收到，按照GBN，发送方重新发送数据包2，3，4，5。</p><p>这里可以看出数据包重复了。</p><h4 id="选择重传-SR"><a href="#选择重传-SR" class="headerlink" title="选择重传 SR"></a>选择重传 SR</h4><p>在GBN中，使用累积确认，为整个分组中最后一个得到确认的数据包发送ACK；</p><p>而在选择重传中，为每个数据包单独发布ACK。同时发送端也为每个分组单独配置计时器，当时间结束仍未收到ACK时，单独重传该分组。</p><p><img src="https://img-blog.csdnimg.cn/b76216ad9a054af79ad4f3ddadafadef.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAUGFyYW5vaWTimIY=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="选择重传示例" loading="lazy"></p><h3 id="窗口长度选择"><a href="#窗口长度选择" class="headerlink" title="窗口长度选择"></a>窗口长度选择</h3><p>窗口长度小于等于序号空间的一半。</p><hr><h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><ul><li><p>面向连接</p></li><li><p>流量控制</p></li><li><p>拥塞控制</p></li></ul><h2 id="TCP报文结构"><a href="#TCP报文结构" class="headerlink" title="TCP报文结构"></a>TCP报文结构</h2><p><img src="https://s2.loli.net/2022/06/02/135WToLye2ju4MA.png" alt="TCP报文结构.png" loading="lazy"></p><table border="1" cellspacing="0">    <tr>        <td colspan="16" align="center"> [2字节/16位]源端口 </td>         <td colspan="16" align="center" width="50%" > [16位]目的端口 </td>     </tr>    <tr>        <td colspan="32" align="center"> [32位]序号seq </td>     </tr>    <tr>          <td colspan="32" align="center"> [32位]确认号ack </td>        </tr>    <tr>        <td rowspan="2" colspan="4" align="center"> [4位]数据偏移 </td>        <td rowspan="2" colspan="6" align="center"> [6位]保留位 </td>        <td rowspan="1" colspan="6" align="center"> [6位]tcp flags </td>        <td rowspan="2" colspan="16" align="center"> 窗口 </td>    </tr>    <tr>        <td rowspan="1" colspan="1" align="center"> URG </td>        <td rowspan="1" colspan="1" align="center"> ACK </td>        <td rowspan="1" colspan="1" align="center"> PSH </td>        <td rowspan="1" colspan="1" align="center"> RST </td>        <td rowspan="1" colspan="1" align="center"> SYN </td>        <td rowspan="1" colspan="1" align="center"> FIN </td>    </tr>    <tr>        <td colspan="16" align="center"> 检验和 </td>        <td colspan="16" align="center"> 紧急指针 </td>    </tr>    <tr>        <td colspan="32" align="center"> TCP选项 </td>    </tr>    <tr>        <td colspan="32" align="center"> 应用层数据（变长） </td>    </tr></table><p>序号：对数据字节计数（并非对报文段计数）<br>URG：紧急数据（一般不用）<br>ACK：ACK序号<br>PSH：立即提交数据（一般不用）<br>RST，SYN，FIN：连接建立（建立和拆连）<br>接收窗口：接收方允许的字节数</p><h3 id="序号和确认号"><a href="#序号和确认号" class="headerlink" title="序号和确认号"></a>序号和确认号</h3><pre class="mermaid">    sequenceDiagram    participant sender as 发送方    participant reciver as 接收方    activate sender    Note left of sender: 用户键入c        sender ->> reciver: Seq=42, ACK=79, data = ‘C’    deactivate sender    activate reciver    Note right of reciver: 主机对收到的‘C’<br/>给出确认<br/>回显 ‘C’        reciver ->> sender: Seq=79, ACK=43, data = ‘C’    deactivate reciver    activate sender    Note left of sender: 主机对收到的回显‘c’<br/>给出确认        sender ->> reciver: Seq=43, ACK=80    deactivate sender</pre><ul><li><p>序号seq</p><p>  报文段中第一个数据字节在字节流中的位置编号</p></li><li><p>确认号ack</p><p>  期望从对方收到下一个字节的序号，如果一切正常，应为对方发送过来的(seq+1)</p></li></ul><h2 id="TCP往返时延的估计与超时"><a href="#TCP往返时延的估计与超时" class="headerlink" title="TCP往返时延的估计与超时"></a>TCP往返时延的估计与超时</h2><p><strong>如何设置TCP超时值？</strong></p><ul><li><p>应大于RTT</p></li><li><p>太短：过早超时，不必要重传</p></li><li><p>太长：对报文段丢失的响应太慢，效率太低</p></li></ul><p><strong>如何估计RTT？</strong></p><ul><li><p>SampleRTT</p><ul><li><p>RTT测量值</p></li><li><p>从发送报文段到接收到ACK的测量时间</p></li></ul><p>  SampleRTT会变化 –&gt; 平均最近的测量值</p></li><li><p>EstimatedRTT</p><p>  *<br>$$ EstimatedRTT &#x3D; (1-α) * EstimatedRTT + α * SampleRTT $$<br><br>或<br><br>$$ EstimatedRTT &#x3D; EstimatedRTT + α * (SampleRTT-EstimatedRTT) $$</p><ul><li>典型 α&#x3D;0.125</li></ul></li><li><p>TimeoutInterval</p><ul><li><p>EstimtedRTT加“安全余量”</p></li><li><p>首先估算EstimtedRTT与真实RTT之间的差值</p><p>  $$ DevRTT &#x3D; (1-β) * DevRTT + β * (|SampleRTT - EstimtedRTT|) $$</p></li><li><p>最后计算TimeoutInterval</p><p>  *<br>$$ TimeoutInterval &#x3D; μ * EstimtedRTT + δ * DevRTT $$</p><ul><li><p>通常情况下，μ&#x3D;1，δ&#x3D;4，即</p><p>  $$ TimeoutInterval &#x3D; EstimtedRTT + 4*DevRTT $$</p></li></ul></li><li><p>典型地，β&#x3D;0.25</p></li></ul></li></ul><h2 id="TCP可靠数据传输"><a href="#TCP可靠数据传输" class="headerlink" title="TCP可靠数据传输"></a>TCP可靠数据传输</h2><ul><li><p>TCP在IP不可靠服务的基础上创建可靠数据传输服务</p></li><li><p>流水线发送报文段</p></li><li><p>累计确认</p></li><li><p>TCP使用单个重传计时器</p></li><li><p>重传被下列事件触发：</p><ul><li><p>超时事件</p></li><li><p>重复ACK</p></li></ul></li></ul><h3 id="TCP可靠数据传输属于滑动窗口方法"><a href="#TCP可靠数据传输属于滑动窗口方法" class="headerlink" title="TCP可靠数据传输属于滑动窗口方法"></a>TCP可靠数据传输属于滑动窗口方法</h3><ul><li><p>发送方</p><ul><li><p>收到累积ACK，窗口向右滑动</p></li><li><p>单个重传计时器，超时仅重传导致超时的报文段</p></li><li><p>快速重传：冗余ACK</p></li></ul></li><li><p>接收方</p><ul><li><p>对收到的报文段进行缓存</p></li><li><p>收到任何报文段时，均发出<strong>正确的</strong>累计确认</p><ul><li><p>即 举例：</p><p>  累计收到了1~8、11~12的报文段，则正确的累计确认为ACK&#x3D;8</p><ul><li><p>若收到4~6报文，或12~14报文，均回复ACK&#x3D;8</p></li><li><p>若收到9~10报文，则正确的累计回复为ACK&#x3D;12</p></li></ul></li></ul></li></ul></li></ul><h3 id="TCP重传情况"><a href="#TCP重传情况" class="headerlink" title="TCP重传情况"></a>TCP重传情况</h3><p><img src="https://s2.loli.net/2022/06/06/4wkRjYF8WsTGOhb.png" alt="丢失确认的情况.png" loading="lazy"></p><p><img src="https://s2.loli.net/2022/06/06/H7ZkqhEu4aA3GQY.png" alt="过早超时的情况.png" loading="lazy"></p><p><img src="https://s2.loli.net/2022/06/06/rbewyOLA6YXhP1c.png" alt="累计确认情况.png" loading="lazy"></p><h3 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h3><ul><li><p>超时间隔常常相对较长</p><ul><li>重传丢失报文段以前有长时延</li></ul></li><li><p>通过冗余ACK，检测丢失的报文段</p><ul><li><p>发送方经常一个接一个地发送报文段</p></li><li><p>如果报文段丢失，将会收到很多重复ACK</p></li></ul></li><li><p>如果发送方连续收到3个相同ACK，便可以假定被确认的报文段之后的报文段丢失了，此时即使没有达到定时器超时时间，也采取重传措施</p><ul><li>快速重传：在定时器超时之前重传</li></ul></li></ul><h2 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h2><ul><li><p>TCP接收方有1个接收缓冲区</p></li><li><p>应用进程可能从缓冲区读取数据缓慢</p></li><li><p>匹配速度服务：发送速率需要匹配接收方应用程序的提取速率</p></li></ul><p>TCP流量控制：发送方发送数据太快，导致接收方来不及接收时，需要进行流量控制</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>TCP流量控制通过<strong>接收窗口</strong>字段来实现</p><ul><li><p>接收方计算缓存区的剩余空间——即接收窗口大小</p></li><li><p>RcvWindow&#x3D; RcvBuffer-[LastByteRcvd -LastByteRead]</p></li><li><p>接收方通过TCP首部的<strong>接收窗口</strong>字段反馈给发送方</p></li><li><p>发送方根据接收窗口字段来限制发送窗口大小，以保证接收方缓存不溢出</p></li></ul><h2 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h2><p>TCP是面向连接的协议，TCP连接的建立和释放是每次TCP传输中必不可少的过程</p><p>TCP的连接传输包括三个状态</p><ul><li><p>连接建立</p></li><li><p>数据传输</p></li><li><p>连接释放</p></li></ul><h3 id="建立连接（三次握手）"><a href="#建立连接（三次握手）" class="headerlink" title="建立连接（三次握手）"></a>建立连接（三次握手）</h3><h4 id="第一次握手过程："><a href="#第一次握手过程：" class="headerlink" title="第一次握手过程："></a>第一次握手过程：</h4><pre class="mermaid">    sequenceDiagram    participant sender as 客户机    participant receiver as 服务器    Note over sender,receiver: 第一次握手：连接请求报文        sender ->> receiver: SYN=1，seq=X</pre><blockquote><p>SYN：同步序列编号<br>SEQ：序列号，表示当前数据传输字节的编号为X</p></blockquote><p>语句含义：请求建立连接</p><p>目前字节编号：X</p><p>下一次编号：X+1</p><p>SEQ&#x3D;X：身份标识</p><h4 id="第二次握手过程："><a href="#第二次握手过程：" class="headerlink" title="第二次握手过程："></a>第二次握手过程：</h4><pre class="mermaid">    sequenceDiagram    participant sender as 客户机    participant receiver as 服务器    sender ->> receiver: SYN=1，seq=X    note over sender,receiver: 第二次握手：确认报文        receiver ->> sender: SYN=1，seq=Y，ack=X+1</pre><blockquote><p>SYN：同步序列编号<br>SEQ：序列号<br>ACK：确认编号</p></blockquote><p>目前字节编号：Y</p><p>下一次编号：Y+1</p><p>SEQ&#x3D;Y：身份标识</p><h4 id="第三次握手过程"><a href="#第三次握手过程" class="headerlink" title="第三次握手过程"></a>第三次握手过程</h4><pre class="mermaid">    sequenceDiagram    participant sender as 客户机    participant receiver as 服务器    sender ->> receiver: SYN=1，seq=X    receiver ->> sender: SYN=1，ack=X+1，seq=Y    note over sender,receiver: 第三次握手：确认报文        sender ->> receiver: ack=Y+1，seq=X+1</pre><blockquote><p>SYN：同步序列编号<br>SEQ：序列号<br>ACK：确认编号</p></blockquote><h3 id="释放连接（四次挥手）"><a href="#释放连接（四次挥手）" class="headerlink" title="释放连接（四次挥手）"></a>释放连接（四次挥手）</h3><ul><li><p>第一次挥手：客户机向服务器发送FIN标识位</p></li><li><p>第二次挥手：服务器收到FIN，回复ACK，并开始等待数据传输完毕。 </p></li><li><p>第三次挥手：服务器确认所有向客户机发送的数据传输完毕，同意断开连接，发送FIN标识位 <del><a href="https://www.bilibili.com/read/cv8011528">她同意了</a></del></p></li><li><p>第四次挥手：客户机收到FIN标识位，返回ACK</p></li><li><p>第四次挥手之后：</p><ul><li><p>服务器方面：收到ACK后关闭连接</p></li><li><p>客户机方面：发出ACK后等待2MSL时间，若没有收到新的响应信号则也关闭连接</p></li></ul></li></ul><blockquote><ul><li>MSL：Maximum Segment Lifetime，报文最大生存时间。<ul><li>如果在这个时间段内，服务器没有收到ACK应答报文段，会重发FIN报文段</li><li>如果客户端收到了FIN报文段，那么2MSL的时间将会被重置。</li><li>如果在2MSL时间段内，没有收到任何数据报，客户端会进入CLOSE状态。</li></ul></li></ul></blockquote><pre class="mermaid">    sequenceDiagram    participant sender as 客户机    participant receiver as 服务器    activate sender    note left of sender: 主动方发送FIN报文<br>并置发送序号为X<br>进入FIN-WAIT-1状态        sender ->> receiver: FIN=1，seq=X，ack    deactivate sender    activate receiver    note right of receiver: 被动方发送ACK<br>并置发送序号<br>seq为Y，ack为X+1<br>服务器进入CLOSE_WAIT<br>等待关闭状态        receiver ->> sender: ACK=1，seq=Y，ack=X+1    deactivate receiver    activate receiver    note left of sender: 客户端进入FIN_WAIT_2 状态        note right of receiver: 服务器端确认所有<br>传输到客户端的数据传输完毕<br>发送[FIN,ACK]报文<br>随机生成序列号seq=Z<br>ack值不变，依然为X+1<br>服务器进入LASK_ACK<br>最后确认状态        receiver ->> sender: FIN=1，ACK=1，seq=Z，ack=X+1    deactivate receiver    activate sender    note left of sender: 客户端收到[FIN]后<br>返回ACK、seq、ack<br>seq为刚刚返回的ack<br>ack为刚刚返回的seq+1        sender ->> receiver: ACK=1，seq=X+1，ack=Z+1    deactivate sender    note right of receiver: 服务器收到ACK后关闭连接    note left of sender: 发送ACK后，客户机进入<br>TIME_WAIT时间等待状态<br>等待2MSL后关闭连接</pre><blockquote><p>注：</p><ul><li>小写ack为TCP首部中的[确认号]部分，占32位</li><li>大写ACK为TCP首部中tcp flags部分中的ACK标志位，占1位</li></ul></blockquote><p>简化版：</p><pre class="mermaid">    sequenceDiagram    participant sender as 客户机    participant receiver as 服务器    sender ->> receiver: FIN=1    receiver ->> sender: ACK=1    receiver ->> sender: FIN=1，ACK=1    sender ->> receiver: ACK=1</pre><h2 id="拥塞控制原则"><a href="#拥塞控制原则" class="headerlink" title="拥塞控制原则"></a>拥塞控制原则</h2><h3 id="拥塞控制原理"><a href="#拥塞控制原理" class="headerlink" title="拥塞控制原理"></a>拥塞控制原理</h3><ul><li><p>当大量分组进入网络，超出网络处理能力，会引起网络局部或整体性能下降，这种现象成为拥塞。不加控制的拥塞会导致整个网络瘫痪。</p></li><li><p>与流量控制不同</p><ul><li><p>流量控制是端到端的控制</p></li><li><p>拥塞控制是全局性的过程，涉及整个网络</p></li></ul></li><li><p>表现</p><ul><li><p>丢包</p></li><li><p>长时延</p></li></ul></li></ul><h3 id="拥塞控制起的作用"><a href="#拥塞控制起的作用" class="headerlink" title="拥塞控制起的作用"></a>拥塞控制起的作用</h3><p><img src="https://s2.loli.net/2022/06/06/VhzPFjCLZX6He2I.png" alt="拥塞控制起的作用.png" loading="lazy"></p><h3 id="拥塞控制的原因与开销"><a href="#拥塞控制的原因与开销" class="headerlink" title="拥塞控制的原因与开销"></a>拥塞控制的原因与开销</h3><p>参考文章：<a href="https://www.jianshu.com/p/888cb8aa16d6">TCP&#x2F;IP之拥塞控制</a></p><h4 id="情况一"><a href="#情况一" class="headerlink" title="情况一"></a>情况一</h4><p><img src="https://s2.loli.net/2022/06/07/gBTHdzvQm8l5Ct2.png" alt="拥塞原因与开销情况一.png" loading="lazy"></p><p>路由器速率有限制，故拥塞发生时，时延无限增大。</p><h4 id="情况二"><a href="#情况二" class="headerlink" title="情况二"></a>情况二</h4><p><img src="https://s2.loli.net/2022/06/06/CmFR3GNVBpWzKtj.png" alt="拥塞控制的原因与开销.png" loading="lazy"></p><ul><li><p>通常：λ<del>in</del>&#x3D;λ<del>out</del></p></li><li><p>仅当丢包时，需要“完美的”重传：λ^’^<del>in</del>&gt;λ<del>out</del></p></li><li><p>迟延的分组（而不是丢失）的重传使得λ^’^<del>in</del>比（同完美情况相比）λ<del>out</del>更大</p></li></ul><p>拥塞的“代价”:</p><ul><li><p>比额定的吞吐量做更多的工作（重传）</p></li><li><p>不必要重传：链路承载分组的多个拷贝</p></li></ul><h4 id="情况三"><a href="#情况三" class="headerlink" title="情况三"></a>情况三</h4><p><img src="https://s2.loli.net/2022/06/07/v2wFJPpz6UCW5GK.png" alt="拥塞原因与开销情况三" loading="lazy"></p><ul><li>当分组被丢失时，任何用于传输该分组的上游传输能力都被浪费</li></ul><h3 id="拥塞控制的两类方法"><a href="#拥塞控制的两类方法" class="headerlink" title="拥塞控制的两类方法"></a>拥塞控制的两类方法</h3><ul><li><p>端到端的拥塞控制</p><ul><li><p>不能从网络得到明确的反馈</p></li><li><p>从端系统根据观察到的时延和丢失现象推断出拥塞</p></li><li><p>TCP采取</p></li></ul></li><li><p>网络辅助的拥塞控制</p><ul><li><p>路由器为端系统提供反馈</p></li><li><p>一个bit指示一条链路出现拥塞</p></li><li><p>指示发送方按照一定速率发送</p></li></ul></li></ul><h3 id="案例-ATM-ABR拥塞控制"><a href="#案例-ATM-ABR拥塞控制" class="headerlink" title="案例:ATM ABR拥塞控制"></a>案例:ATM ABR拥塞控制</h3><ul><li><p>通信过程简要描述</p><ul><li><p>发送方沿（建立好连接的）路径上不断传输<strong>数据信元</strong>和<strong>管理信元</strong>，到达接收方</p></li><li><p>接收方将<strong>管理信元</strong>（内容修改调整后）研路径返回（反馈）到发送方</p></li></ul></li></ul><h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><ul><li><p>端到端控制</p></li><li><p>发送方限制传输：滑动窗口法</p></li><li><p>速率 &#x3D; $\frac{CongWin}{RTT}(Bytes&#x2F;sec)$</p></li><li><p>拥塞窗口是动态的，具有感知到网络拥塞的函数</p></li><li><p>发送方如何感知网络拥塞 ？</p><ul><li><p>丢失事件：超时或3个重复ACK</p></li><li><p>发生丢失事件后，TCP发送方降低速率（拥塞窗口）</p></li></ul></li><li><p>三个机制</p><ul><li><p>AIMD（加增倍减算法）</p></li><li><p>慢启动</p></li><li><p>超时事件后的保守机制</p></li></ul></li></ul><h3 id="TCP加减倍增-AIMD"><a href="#TCP加减倍增-AIMD" class="headerlink" title="TCP加减倍增 AIMD"></a>TCP加减倍增 AIMD</h3><ul><li>乘性减：</li></ul><p>丢包事件后，拥塞窗口值减半。</p><ul><li>加性增：</li></ul><p>如没有检测到丢包时间，每个RTT时间拥塞窗口值增加一个MSS（最大报文段长度）</p><p><img src="https://s2.loli.net/2022/06/11/GLJI49gmlTWRcdM.png" alt="AIMD.png" loading="lazy"></p><h3 id="TCP慢启动"><a href="#TCP慢启动" class="headerlink" title="TCP慢启动"></a>TCP慢启动</h3><p>概述：</p><ul><li><p>在连接开始时，拥塞窗口值 &#x3D; 1 MSS</p><ul><li><p>例如： MSS &#x3D; 500 bytes &amp; RTT &#x3D; 200 msec</p></li><li><p>初始化速率 &#x3D; 20 kbps</p></li></ul></li><li><p>可获得宽带可能 &gt;&gt; $\frac{MSS}{RTT}$</p><ul><li>希望尽快达到期待的速率</li></ul></li><li><p>当连接开始，以指数快地增加速率，直到第一个丢失事件发生</p></li></ul><p>具体：</p><ul><li><p>当连接开始的时候，速率呈指数式上升，直到第1次报文丢失事件发生为止：</p><ul><li><p>每RTT倍增拥塞窗口值</p></li><li><p>每收到ACK，增加拥塞窗口</p></li></ul></li></ul><p><img src="https://s2.loli.net/2022/06/12/jNbI5Ruqs6XiTxW.png" alt="TCP慢启动.png" loading="lazy"></p><p>总结：初始效率很低，但以指数快地增长</p><h3 id="超时后的保守机制"><a href="#超时后的保守机制" class="headerlink" title="超时后的保守机制"></a>超时后的保守机制</h3><ul><li><p><strong>基本思想</strong></p><ul><li><p>三个冗余ACK指示网络还具有某些传送报文段的能力</p></li><li><p>直接超时，则更为“严重”</p></li></ul></li><li><p>收到<ins><strong>三个冗余确认</strong></ins>后</p><ul><li><p>CongWin减半</p></li><li><p>窗口再线性增加</p></li></ul></li><li><p>但是<ins><strong>超时事件</strong></ins>以后</p><ul><li><p>CongWin值设置为1 MSS</p></li><li><p>窗口再指数增长</p></li><li><p>到达一个阈值后，再线性增长</p></li></ul></li></ul><p>如图</p><p><img src="https://s2.loli.net/2022/06/12/ITk2ZRDzJwcu5lf.png" alt="TCP拥塞控制.png" loading="lazy"></p><p>①处，慢启动<strong>达到阈值</strong>，进入拥塞避免阶段，CongWin线性增长</p><p>②处，遭遇<strong>超时事件</strong>，CongWin设为1 MSS，重新慢启动，并且将阈值设为发生事件时CongWin的一半，即12</p><p>③处，达到②中设定的阈值，开始线性增长</p><p>④处，遭遇<strong>3 ACK</strong>事件，CongWin减半，来到⑤处，并且将阈值也设为<strong>原CongWin</strong>的一半</p><p>⑤处，窗口线性增长</p><h3 id="TCP吞吐量"><a href="#TCP吞吐量" class="headerlink" title="TCP吞吐量"></a>TCP吞吐量</h3><p>TCP平均吞吐量是窗口长度和RTT的函数</p><ul><li><p>设：窗口长度为W，则$ 吞吐量 &#x3D; \frac{W}{RTT} $</p></li><li><p>当丢包发生后，窗口降为$ \frac{W}{2} $，于是吞吐量降为$ \frac{W}{2RTT} $</p></li><li><p>一个连接的平均吞吐量为$ \frac{0.75W}{RTT} $</p></li></ul><p>实际网络性能分析中TCP吞吐量是复杂函数</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分解与复用&quot;&gt;&lt;a href=&quot;#分解与复用&quot; class=&quot;headerlink&quot; title=&quot;分解与复用&quot;&gt;&lt;/a&gt;分解与复用&lt;/h1&gt;&lt;p&gt;主机使用IP地址&amp;amp;端口号将报文段导向到相应的套接字&lt;/p&gt;
&lt;p&gt;具有不同源IP地址和&amp;#x2F;或源端口号</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://sagirichan.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机网络" scheme="http://sagirichan.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="笔记" scheme="http://sagirichan.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>计网复习笔记-应用层</title>
    <link href="http://sagirichan.com/2022/05/13/computer-network-note-applicationLayer/"/>
    <id>http://sagirichan.com/2022/05/13/computer-network-note-applicationLayer/</id>
    <published>2022-05-13T12:33:05.000Z</published>
    <updated>2022-06-13T08:20:50.354Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h1><ul><li><p>在同一台主机中：两个进程使用进程间通信IPC(由操作系统定义)通信.</p></li><li><p>在不同的主机中：进程通过交换报文通信</p></li></ul><hr><h1 id="网络应用程序体系结构"><a href="#网络应用程序体系结构" class="headerlink" title="网络应用程序体系结构"></a>网络应用程序体系结构</h1><ul><li><p>客户机&#x2F;服务器</p></li><li><p>对等（P2P）</p></li><li><p>客户机&#x2F;服务器与对等（P2P）混合</p></li></ul><h2 id="C-x2F-S模式"><a href="#C-x2F-S模式" class="headerlink" title="C&#x2F;S模式"></a>C&#x2F;S模式</h2><ul><li><p>集中结构，一对多</p></li><li><p>服务器共享资源，客户机资源不共享</p></li><li><p>服务器可能负载过重</p></li><li><p>网络带宽限制</p></li></ul><h2 id="P2P模式"><a href="#P2P模式" class="headerlink" title="P2P模式"></a>P2P模式</h2><ul><li><p>非集中结构，多对多</p></li><li><p>节点具备客户与服务器双重特性</p></li><li><p>充分利用终端资源</p></li><li><p>可扩展性好</p></li></ul><h1 id="因特网运输协议服务"><a href="#因特网运输协议服务" class="headerlink" title="因特网运输协议服务"></a>因特网运输协议服务</h1><h2 id="tcp"><a href="#tcp" class="headerlink" title="tcp"></a>tcp</h2><p>面向连接: 客户机和服务器之间所需的建立</p><p>可靠传输：在发送和接收进程之间</p><p>流控制: 发送方不会淹没接收方</p><p>拥塞控制: 当网络过载时抑制发送方</p><p>并不提供: 定时，最小带宽保证</p><h2 id="udp"><a href="#udp" class="headerlink" title="udp"></a>udp</h2><p>在发送进程及接收进程之间的不可靠数据传输</p><p>不提供：建立连接建立，可靠性，流控，拥塞控制，定时或带宽保证</p><hr><h1 id="web和HTTP协议"><a href="#web和HTTP协议" class="headerlink" title="web和HTTP协议"></a>web和HTTP协议</h1><h2 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h2><ul><li><p>web的应用层协议是HTTP，超文本传输协议</p></li><li><p>Web页面由对象组成，一个基本HTML文件包含多个引用对象：图片，java小程序，视频文件等</p></li><li><p>每个对象可由URL(Uniform Resource Locator 统一资源定位符)寻址</p></li></ul><p>举例：</p><p><strong>http</strong>: &#x2F;&#x2F;<u>114.514.191.810</u>&#x2F;<em>sennpai&#x2F;suki</em><br><strong>协议</strong>    <u>主机名</u>        <em>路径</em></p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>HTTP协议运行在客户与服务器端的应用程序中。</p><ul><li><p>客户机：请求、接收、显示Web对象</p></li><li><p>服务器：Web服务器响应请求而发送对象</p></li></ul><pre class="mermaid">graph LRC[客户机] --HTTP请求--> S[服务器]S[服务器] --HTTP响应--> C[客户机]</pre><p>非持久连接与持久连接：</p><ul><li><p>非持久HTTP</p><p>  <strong>每个</strong>HTTP请求&#x2F;响应对经过一个<strong>单独TCP连接</strong>发送</p><p>  HTTP&#x2F;1.0使用非持久 </p></li><li><p>持久HTTP</p><p>  <strong>多个对象</strong>能够经过客户机和服务器之间的<strong>单个TCP连接</strong>发送</p><p>  HTTP&#x2F;1.1以默认模式使用持久连接</p></li></ul><h3 id="非持久连接"><a href="#非持久连接" class="headerlink" title="非持久连接"></a>非持久连接</h3><pre class="mermaid">graph TBA[1.HTTP客户机向HTTP服务器发起tcp连接] --> B[2.HTTP服务器接受连接并通知客户机] -->C[3.HTTP客户机发送HTTP请求报文进TCP连接套接字,向服务机要对象] -->D[4.HTTP服务器接收请求报文,形成响应报文包含请求对象,并向套接字发送报文] -->E[5.HTTP服务器关闭TCP连接] -->F[6.HTTP客户机接收包含html文件的响应报文并解析] -->G(若发现html文件中又引用了其他对象,则重复上述步骤向服务器要对象)</pre><p>响应时间估算：</p><ul><li><p>往返时间RTT的定义：从客户机到服务器发送一个小分组并返回所历经的时间.</p></li><li><p>响应时间</p><ul><li><p>建立tcp请求：RTT*1</p></li><li><p>发送HTTP请求并得到回应：RTT*1</p></li><li><p>传输文件时间</p></li></ul><p>  <img src="https://s2.loli.net/2022/05/10/wV6lM5ueNE3cxHS.png" alt="HTTP-响应时间估算.png" loading="lazy"></p><p>  总响应&#x3D; 2RTT+传输时间</p></li></ul><h3 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h3><ul><li><p>在发送响应后，保持TCP连接持续打开</p></li><li><p>后继HTTP报文通过该连接持续发送</p></li></ul><p>持久连接又可以分为无流水线与有流水线的连接</p><ul><li><p>无流水线的连接</p><ul><li><p>仅当前面的响应已经收到，客户机发出新的请求</p></li><li><p>对每个引用对象花费一个RTT</p></li></ul><p>  （半自动步枪，每次射击都要扣动扳机（这是什么奇妙的比喻×</p></li><li><p>有流水线的连接</p><ul><li><p>不必等待响应，请求接连发出</p></li><li><p>对所有引用对象花费一个RTT（略多）时间</p></li></ul><p>  （全自动步枪，不必松开扳机，可以一直扣住</p></li></ul><h3 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h3><p>分为<strong>请求报文</strong>与<strong>响应报文</strong></p><h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><p><img src="https://s2.loli.net/2022/05/10/Ut2nKwcEVqf36rT.png" alt="HTTP请求报文.png" loading="lazy"></p><ul><li><p>通用格式</p><ul><li><p>请求行：方法字段，URL字段，版本字段</p></li><li><p>首部行：一般多行</p></li><li><p>空行</p></li><li><p>实体主体：可为空</p></li></ul></li></ul><p>一个简单的例子：</p><pre><code>POST /user HTTP/1.1         //请求行Host: www.user.comContent-Type: application/x-www-form-urlencodedConnection: Keep-AliveUser-agent: Mozilla/5.0.    //以上是首部行                            //空行分割header和请求内容 name=world                  //请求体</code></pre><blockquote><p>方法类型<br>GET：最常用，请求访问网页，实体主体为空<br>POST：常用，提交表单同时请求访问网页，如使用搜索引擎，实体主体中为表单输入值<br>HEAD：少用，测试用，与GET区别在于响应中去掉请求的对象<br>PUT：很少用，向URL字段中定义的路径，上载在实体主体中文件<br>DELETE，很少用，删除在URL字段中定义的文件</p></blockquote><h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><p>响应报文与请求报文结构类似</p><ul><li><p>通用格式</p><ul><li><p>状态行：版本字段，状态码字段，短语字段</p></li><li><p>首部行：一般多行</p></li><li><p>空行</p></li><li><p>实体主体：可为空</p></li></ul></li></ul><p>一些响应码与响应短语的例子及含义</p><ul><li><p>200 OK<br>请求成功，请求的对象在这个报文后面</p></li><li><p>301 Moved Permanently<br>请求的对象已转移，新的URL在响应报文的Location:首部行中指定</p></li><li><p>400 Bad Request<br>请求报文不为服务器理解</p></li><li><p>404 Not Found<br>请求的文档没有在该服务器上发现</p></li><li><p>505 HTTP Version Not Supported</p></li></ul><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p>Cookie是一种在客户端保持HTTP状态信息的技术。</p><p>客户端访问网站时，Web服务器会查看、创建、修改Cookie资料，帮助Web站点保存访问者信息：浏览历史，购物车等。</p><p>cookie技术组成</p><ul><li><p>cookie识别码（http请求报文，http响应报文）</p></li><li><p>客户端保留cookie文件</p></li><li><p>服务器提供后端数据库</p></li></ul><p>cookie工作过程</p><p><img src="https://s2.loli.net/2022/05/10/l152vsbQLx9ESpw.png" alt="cookie.png" loading="lazy"></p><h2 id="Web缓存-代理服务器"><a href="#Web缓存-代理服务器" class="headerlink" title="Web缓存(代理服务器)"></a>Web缓存(代理服务器)</h2><ul><li><p>Web缓存器：保存最近请求过的web对象</p></li><li><p>浏览器向缓存发送所有HTTP请求</p><ul><li><p>对象在缓存中：缓存返回对象</p></li><li><p>否则缓存向起始服务器请求对象，然后向客户机返回对象</p></li></ul></li></ul><p>举例：</p><h3 id="没有缓存服务器时"><a href="#没有缓存服务器时" class="headerlink" title="没有缓存服务器时"></a>没有缓存服务器时</h3><pre class="mermaid">graph LRLAN(LAN 100Mbps)LANroute[机构路由器]A[浏览器A] --> LANrouteB[浏览器B] --> LANrouteC[浏览器C] --> LANrouteWANroute[公网路由器]LANroute -.访问链路 15Mbps.-> WANrouteWANroute --> a[起始服务器a]WANroute --> b[起始服务器b]WANroute --> c[起始服务器c]</pre><p>假定</p><ul><li><p>平均对象长度 &#x3D; 1M</p></li><li><p>来自机构的浏览器的平均请求 &#x3D; 15个&#x2F;sec</p></li><li><p>从机构路由器到任何起始服务器并返回的时延 &#x3D; 2 sec</p></li></ul><p>则</p><p>LAN端每秒发送15M请求，由于LAN信道宽度为100Mbps，访问链路信道宽度为15Mbps，故</p><ul><li><p>局域网利用率 &#x3D; 15%</p></li><li><p>访问链路利用率 &#x3D; 100%</p></li><li><p>总时延  &#x3D; LAN时延 + 访问时延 + 因特网时延 &#x3D; LAN时延 + 访问链路时延 + 2sec</p></li></ul><h3 id="有缓存服务器时"><a href="#有缓存服务器时" class="headerlink" title="有缓存服务器时"></a>有缓存服务器时</h3><pre class="mermaid">graph LRLAN(LAN 100Mbps)LANroute[机构路由器]A[浏览器A] --- LANrouteB[浏览器B] --> LANrouteC[浏览器C] --> LANrouteD((缓存服务器)) --> LANrouteWANroute[公网路由器]LANroute -.访问链路 15Mbps.-> WANrouteWANroute --> a[起始服务器a]WANroute --> b[起始服务器b]WANroute --> c[起始服务器c]</pre><p>假设命中率为0.4</p><ul><li><p>40%请求几乎立即得到满足，没有到达起始服务器的时延<br>60%请求由起始服务器满足</p></li><li><p>访问链路的利用率减少到60%</p></li></ul><p>网络平均时延大大减小</p><h2 id="条件GET"><a href="#条件GET" class="headerlink" title="条件GET"></a>条件GET</h2><p>HTTP条件Get使用的方法：</p><p>客户端向服务器发送一个包询问是否在上一次访问网站的时间后是否更改了页面</p><ul><li><p>如果服务器没有更新，不需要重新传输网页，返回304 Not Modified，客户端使用本地缓存</p></li><li><p>如果服务器对照客户端给出的时间已经更新了客户端请求的网页，则发送更新了的网页给用户。</p></li></ul><hr><h1 id="文件传输协议：FTP"><a href="#文件传输协议：FTP" class="headerlink" title="文件传输协议：FTP"></a>文件传输协议：FTP</h1><p>FTP使用双tcp连接</p><ul><li><p>第一个是控制连接，它一直持续到客户进程与服务器进程之间的会话完成为止。</p></li><li><p>另一个是数据连接，按需可以随时创建和撤消。每当一个文件传输时，就创建一个数据连接。</p></li></ul><p>控制连接被称为主连接。而数据连接被称为子连接。</p><pre class="mermaid">graph LRlocal[本地主机] --TCP控制连接 默认端口21--> remote[远程主机]remote[远程主机] --TCP数据连接 默认端口20--> local[本地主机]</pre><p>通过操作命令实现远程交互式访问。</p><hr><h1 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h1><h2 id="电子邮件系统组成"><a href="#电子邮件系统组成" class="headerlink" title="电子邮件系统组成:"></a>电子邮件系统组成:</h2><ul><li><p>用户代理</p></li><li><p>邮件服务器</p></li><li><p>简单邮件传输协议: SMTP（Simple Mail Transfer Protocol）</p></li></ul><pre class="mermaid">graph TDMSA[邮件服务器A]MSB[邮件服务器B]MSC[邮件服务器C]MSA --SMTP--> MSBMSB --SMTP---> MSCMSC --SMTP--> MSAA[用户代理] -.-> MSAB[用户代理] -.-> MSBC[用户代理] -.-> MSBMSC <-.- D[用户代理]MSC <-.- E[用户代理]MSC <-.- F[用户代理]</pre><p>Alice向Bob写信</p><ol><li>Alice<strong>使用UA写作报文</strong>并向 <a href="mailto:&#98;&#x6f;&#x62;&#64;&#x73;&#x6f;&#x6d;&#101;&#x73;&#99;&#x68;&#x6f;&#x6f;&#108;&#x2e;&#x65;&#x64;&#117;">&#98;&#x6f;&#x62;&#64;&#x73;&#x6f;&#x6d;&#101;&#x73;&#99;&#x68;&#x6f;&#x6f;&#108;&#x2e;&#x65;&#x64;&#117;</a>发送</li><li>Alice的UA向其<strong>邮件服务器</strong>发送报文；报文放置在<strong>报文队列</strong>中</li><li><strong>SMTP</strong>的客户机侧打开与Bob的邮件服务器的<strong>TCP连接</strong></li><li>SMTP通过TCP连接<strong>发送</strong>Alice的报文</li><li>Bob的邮件服务器将该报文<strong>放入Bob的邮箱</strong></li><li>Bob<strong>调用其用户代理</strong>来读报文</li></ol><pre class="mermaid">graph LRAlice === A[用户代理] --> B[邮件服务器] -.-> C[邮件服务器] --> D[用户代理] === Bob</pre><h2 id="电子邮件协议"><a href="#电子邮件协议" class="headerlink" title="电子邮件协议"></a>电子邮件协议</h2><ul><li><p>SMTP（简单邮件传输协议）：最常用的电子邮件传输协议</p></li><li><p>POP3（邮局协议）：最常用的电子邮件接收协议</p></li><li><p>IMAP4（网络邮局访问协议）：POP3的替代协议，提供邮件处理新功能</p></li></ul><p>另：HTTP协议也用于电子邮件，网页访问邮箱</p><h2 id="STMP"><a href="#STMP" class="headerlink" title="STMP"></a>STMP</h2><ul><li><p>SMTP是一个相对简单的基于文本的协议</p><ul><li><p>报文必须以7比特ASCII格式</p></li><li><p>二进值文件可通过MIME编码后再传</p></li></ul></li><li><p>SMTP服务器端使用端口号25</p></li><li><p>采用命令&#x2F;响应交互</p><ul><li><p>命令：HELO，MAIL FROM, RCPT TO, DATA, QUIT</p></li><li><p>响应：状态码及短语</p></li></ul></li><li><p>传输的三个阶段</p><p>  握手，传输，关闭</p></li></ul><h2 id="邮件报文格式"><a href="#邮件报文格式" class="headerlink" title="邮件报文格式"></a>邮件报文格式</h2><ul><li><p>首部</p><p>  头部由多个头部行构成，列出最常见的三个</p><ul><li><p>To：发给谁</p></li><li><p>From：谁发送的</p></li><li><p>Subject：邮件的主题</p></li></ul></li><li><p>空行</p></li><li><p>信体</p></li></ul><h2 id="MIME"><a href="#MIME" class="headerlink" title="MIME"></a>MIME</h2><p>多用途因特网邮件扩展不仅可以发送非英语国家字符，还可以发送其它类型的内容，例如声音、图像、图片、视频等，大大扩展了电子邮件的用途。</p><p>MIME通过添加额外的信头头部声明来实现内容的扩展。以下为一个例子：</p><p><img src="https://s2.loli.net/2022/05/10/Txz9sbuaXABdUD8.png" alt="MIME头部.png" loading="lazy"></p><pre class="mermaid">graph LR用户1 --非ASCII码--- A[MIME] --七位ASCII码--- B[SMTP] --七位ASCII码--- C[SMTP] --七位ASCII码--- D[MIME] --非ASCII码--- 用户2</pre><h2 id="邮件访问协议"><a href="#邮件访问协议" class="headerlink" title="邮件访问协议"></a>邮件访问协议</h2><p>邮件访问协议用来从邮件服务器上读取别人发来的邮件</p><pre class="mermaid">graph LR用户代理1 --SMTP--- A[邮件服务器] --SMTP--- D[邮件服务器] --邮件访问协议--- 用户代理2</pre><ul><li><p>POP3: 邮局协议 （ Post Office Protocol ）</p><p>  授权 (代理 &lt;–&gt;服务器) 并下载</p></li><li><p>IMAP4: 因特网邮件访问协议 </p><ul><li><p>更多功能</p></li><li><p>操作存储在服务器上的报文</p></li></ul></li></ul><h2 id="基于Web的电子邮件"><a href="#基于Web的电子邮件" class="headerlink" title="基于Web的电子邮件"></a>基于Web的电子邮件</h2><ul><li><p>用户代理是浏览器</p></li><li><p>使用 HTTP而不是SMTP发送到<strong>源</strong>邮件服务器</p></li><li><p>使用SMTP发送邮件到<strong>目的</strong>邮件服务器</p></li></ul><hr><h1 id="域名系统DNS"><a href="#域名系统DNS" class="headerlink" title="域名系统DNS"></a>域名系统DNS</h1><p>DNS: Domain Name System域名系统</p><p>包括DNS服务器和DNS协议</p><p>DNS完成主机名到IP地址的解析</p><ul><li><p>迭代查询</p><ul><li>客户端向本地DNS服务器发起查询:请求gaia.cs.umass.edu的IP</li><li>本地DNS向根DNS查询：.edu顶级域DNS服务器地址</li><li>根DNS回应.edu顶级域DNS服务器地址</li><li>本地DNS向.edu顶级域DNS查询.umass.edu的权威DNS服务器地址</li></ul><p>  <img src="https://s2.loli.net/2022/05/10/sMiQAPv9R25zUVa.png" alt="DNS迭代查询.png" loading="lazy"></p></li><li><p>递归查询</p><ul><li>客户端向本地DNS服务器发起查询:请求gaia.cs.umass.edu的IP</li><li>本地DNS向根DNS查询：请求gaia.cs.umass.edu的IP</li><li>根DNS向.edu顶级域DNS服务器查询：请求gaia.cs.umass.edu的IP</li><li>.edu顶级域DNS向.umass.edu的权威DNS查询：</li></ul><p>  <img src="https://s2.loli.net/2022/05/10/Ipdq7yai9YWFbgs.png" alt="DNS递归查询.png" loading="lazy"></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;进程通信&quot;&gt;&lt;a href=&quot;#进程通信&quot; class=&quot;headerlink&quot; title=&quot;进程通信&quot;&gt;&lt;/a&gt;进程通信&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在同一台主机中：两个进程使用进程间通信IPC(由操作系统定义)通信.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://sagirichan.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机网络" scheme="http://sagirichan.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="笔记" scheme="http://sagirichan.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>计网复习笔记-绪论</title>
    <link href="http://sagirichan.com/2022/05/13/computer-network-note-introduction/"/>
    <id>http://sagirichan.com/2022/05/13/computer-network-note-introduction/</id>
    <published>2022-05-13T09:27:22.000Z</published>
    <updated>2022-06-13T07:58:51.914Z</updated>
    
    <content type="html"><![CDATA[<h1 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h1><ul><li><p>预留端到端资源：端系统之间通信路径上所需要的资源 (缓存，链路带宽)。建立连接。</p></li><li><p>发送方以恒定速率向接收方传送数据。</p></li><li><p>通信双方必须先建立一个专用的连接（电路），一直维持，直到通信结束。</p></li></ul><p>每个链路可有n条电路，能够支持n条同步连接。 </p><h2 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h2><p>在一条传输链路上同时建立多条连接，分别传输数据。 </p><h4 id="频分多路复用FDM-frequency-division-multiplexing"><a href="#频分多路复用FDM-frequency-division-multiplexing" class="headerlink" title="频分多路复用FDM(frequency-division multiplexing)"></a>频分多路复用FDM(frequency-division multiplexing)</h4><p>按频率划分若干频段，每个频段专用于一个连接。</p><p>带宽bandwidth：频段的宽度。如，4kHz。</p><h3 id="时分多路复用TDM-time-division-multiplexing"><a href="#时分多路复用TDM-time-division-multiplexing" class="headerlink" title="时分多路复用TDM (time-division multiplexing)"></a>时分多路复用TDM (time-division multiplexing)</h3><p>时间划分为固定区间的帧，每帧再划分为固定数量的时隙，每一个时隙专用于一个连接，用于传输数据。</p><h1 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h1><ul><li><p>每个端到端数据流划分为分组，每个分组使用全部链路带宽。</p></li><li><p>将用户通信的数据划分成多个更小的等长数据段，在每个数据段的前面加上必要的控制信息作为数据段的首部，每个带有首部的数据段就构成了一个分组。</p></li><li><p>节点在转发前接收完整的分组</p></li></ul><p>分组交换的本质就是存储转发，它将所接受的分组暂时存储下来，在目的方向路由上排队，当它可以发送信息时，再将信息发送到相应的路由上，完成转发。</p><h2 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h2><p>传输<code>L</code>个比特，链路速率<code>R</code>bps，则时间为 $\frac{L}{R}$</p><p>在分组能向下一段链路传输前，整个分组必须到达路由器：存储转发</p><p>举例：</p><pre class="mermaid">graph LRsource[源] --R--> route((路由)) --R--> route2((路由)) --R--> destination[目的地]data(数据包L)</pre><p>时延：$\frac{3L}{R}$</p><ul><li><p>数据报网络：</p><ul><li><p>分组中的目的地址决定下一跳</p></li><li><p>在会话中路由可以变化</p></li></ul></li><li><p>虚电路网络：</p><ul><li><p>每个分组携带标签(虚电路ID)，标签决定下一跳</p></li><li><p>固定的路径在呼叫建立时决定，在呼叫期间保持不变</p></li></ul></li></ul><h1 id="带宽与时延"><a href="#带宽与时延" class="headerlink" title="带宽与时延"></a>带宽与时延</h1><h2 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h2><p>在模拟信号中的本义是指构成一信号的各种不同频率成分所占据的频率范围</p><p>现在“带宽”是数字信道所能传送的“最高数据率”的同义语。</p><h2 id="比特率"><a href="#比特率" class="headerlink" title="比特率"></a>比特率</h2><p>数字信道传送数字信号的速率，单位是比特每秒（bps）</p><p>“带宽”与“速率”：一条通信线路的“频带宽度”越宽，其所传输数据的“最高数据率”也越高。</p><h2 id="吞吐率"><a href="#吞吐率" class="headerlink" title="吞吐率"></a>吞吐率</h2><p>吞吐率表示在单位时间内通过某个网络（或信道、接口）的数据量。</p><p>更经常地用于对现实世界中的网络的一种测量</p><h2 id="延时delay"><a href="#延时delay" class="headerlink" title="延时delay"></a>延时delay</h2><p>把一个报文从网络一端传输到另一端所需的时间。</p><blockquote><p>延迟&#x3D; 处理＋排队＋发送＋传播</p></blockquote><p>处理时延：主机或路由器处理所收到的分组的时间。检查包首部、决定导向何处、比特差错检测等。</p><p>排队时延：分组在输入队列中排队等待处理，在输出队列中等待转发。等待输出链路空闲，与当时流量和排队规则有关</p><blockquote><p><em>排队时延补充</em></p><blockquote><p>L&#x3D; 分组长度 (比特)<br>a&#x3D; 平均分组到达速率<br>R&#x3D; 链路带宽 (bps)</p></blockquote><p><strong>流量强度 &#x3D; $\frac{La}{R}$</strong></p><p>$\frac{La}{R}$ ~ 0：平均排队时延小</p><p>$\frac{La}{R}$ &lt; 1：有平均排队时延</p><p>$\frac{La}{R}$ &gt; 1：数据到达速率超过链路处理能力，平均排队时延无穷大</p></blockquote><blockquote><p><em>分组丢失</em><br>结点的缓存<em>buffer</em>有限，当分组到达满的队列时，分组被丢弃(又称为lost)<br>丢失的分组可能由前面的节点或由源端系统重传，也可能不重传</p></blockquote><p>发送时延：也叫传输时延，将数据包从结点推出到链路中所用的时间。发送时延&#x3D;$\frac{数据长度(b)}{信道带宽(bps)}$</p><p>传播时延：电磁波在信道中需要传播一定的距离而花费的时间。信号传播距离d，传播速度s：传播时延&#x3D;$\frac{d}{s}$</p><h2 id="RTT-Round-Trip-Time"><a href="#RTT-Round-Trip-Time" class="headerlink" title="RTT (Round-Trip Time)"></a>RTT (Round-Trip Time)</h2><p>往返时延。表示从发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后便立即发送确认），总共经历的时延。</p><h1 id="协议层次与服务模型"><a href="#协议层次与服务模型" class="headerlink" title="协议层次与服务模型"></a>协议层次与服务模型</h1><h2 id="因特网协议栈"><a href="#因特网协议栈" class="headerlink" title="因特网协议栈"></a>因特网协议栈</h2><table><thead><tr><th>应用层</th></tr></thead><tbody><tr><td>运输层</td></tr><tr><td>网络层</td></tr><tr><td>链路层</td></tr><tr><td>物理层</td></tr></tbody></table><ul><li><p>应用：支持网络应用</p><p>  FTP,SMTP,STTP</p></li><li><p>传输：主机到主机数据传输</p><p>  TCP,UDP</p></li><li><p>网络：从源到目的地数据报的选路</p><p>  IP，选路协议</p><p>  路由器</p></li><li><p>链路：在邻近网元之间传输数据</p><p>  PPP，以太网</p><p>  交换机</p></li><li><p>物理：”在线上“的比特</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;电路交换&quot;&gt;&lt;a href=&quot;#电路交换&quot; class=&quot;headerlink&quot; title=&quot;电路交换&quot;&gt;&lt;/a&gt;电路交换&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;预留端到端资源：端系统之间通信路径上所需要的资源 (缓存，链路带宽)。建立连接。&lt;/p&gt;
&lt;/li&gt;
&lt;l</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://sagirichan.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机网络" scheme="http://sagirichan.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="笔记" scheme="http://sagirichan.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>纱雾与Y同学</title>
    <link href="http://sagirichan.com/2022/04/30/sagiri-and-Miss-Y/"/>
    <id>http://sagirichan.com/2022/04/30/sagiri-and-Miss-Y/</id>
    <published>2022-04-30T09:34:33.000Z</published>
    <updated>2022-04-30T15:53:53.445Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这个故事的灵感来源于我——一个自闭阿宅——的一个<del>有关青春期幻想的</del>梦。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这个故事的灵感来源于我——一个自闭阿宅——的一个&lt;del&gt;有关青春期幻想的&lt;/del&gt;梦。&lt;/p&gt;
&lt;/blockquote&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>如何把博客部署在云服务器上？</title>
    <link href="http://sagirichan.com/2022/04/30/blog-on-cloud/"/>
    <id>http://sagirichan.com/2022/04/30/blog-on-cloud/</id>
    <published>2022-04-30T05:20:46.000Z</published>
    <updated>2022-05-15T19:05:30.970Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前言<br>在我的另一篇文章<a href="http://sagirichan.com/2022/01/25/my-own-website/">关于我想要拥有自己的网站这件事</a>中，我搭建了一个基于<a href="https://pages.github.com/">GitHub Pages</a>的博客网站，并且备案成功，为网站迁移做好了前期准备。</p><p>本来这篇文章我是与上面那篇合在一起写的，然而，由于网上教程的不完善<del>以及我的猪鼻</del>，我搞了好久才成功把网站部署到了服务器上，期间踩了无数稀奇古怪的坑，跟随着部署过程一起写的这篇文章也随之变得冗长臃肿，于是我认为这么屑的部署过程有必要单开一帖记录。</p></blockquote><p>参考文章：</p><p><a href="https://blog.csdn.net/TyCoding/article/details/80480541">Nginx搭建基于Hexo的Blog</a></p><p><a href="https://blog.csdn.net/shuqinkissshot/article/details/123201682">基于Hexo+Nginx+Git在云服务器上搭建个人网站</a></p><p><a href="https://blog.csdn.net/kengkeng123qwe/article/details/124471586">【hexo博客搭建】将搭建好的hexo博客部署到阿里云服务器上面(下)</a></p><h1 id="讲一讲整体思路"><a href="#讲一讲整体思路" class="headerlink" title="讲一讲整体思路"></a>讲一讲整体思路</h1><p>很多教程都有个共同的问题，就是只讲要做什么，而不讲为什么做。这就导致读者读完教程后知其然而不知其所以然，甚至对于一些粗制滥造胡乱抄袭的教程，读完以后连其所以然都不知。</p><p>所以我想在我的博客的开头简单介绍一下部署的思路，让读者（如果有的话）在后续的部署过程中能明白自己在干什么，而不是如盲人摸象一般被动地跟着教程模仿，出了问题都不知道出在哪。这对我自己来说也是重新审视知识的过程。</p><p><del>当然读者也可以直接跳过这一部分，这并不会影响部署结果。</del></p><h2 id="本地要做哪些准备？"><a href="#本地要做哪些准备？" class="headerlink" title="本地要做哪些准备？"></a>本地要做哪些准备？</h2><p>在本地配置hexo并生成<code>网站静态文件</code>，生成的静态文件将通过<code>git</code>工具推送到服务器（或github等任意我们想要部署到的地方）。</p><h2 id="云端要做些什么"><a href="#云端要做些什么" class="headerlink" title="云端要做些什么"></a>云端要做些什么</h2><p>在云端我们做了两个工作：</p><ul><li><p>部署nginx，它将帮助你把网站的静态文件变成可以访问的网站。</p></li><li><p>安装git（对于云服务器来说这一步通常已经完成了），建立一个git仓库，用来接收从本地推送的网站静态文件，并利用<code>hook</code>（钩子）工具将其转移到nginx的托管目录下。</p></li></ul><h2 id="还有别的吗"><a href="#还有别的吗" class="headerlink" title="还有别的吗"></a>还有别的吗</h2><p>建立云服务器与本地的SSH连接，这样我们在使用git向服务器推送网站静态文件时就不必每次都要输入云服务器的用户密码了，可以和向github推送代码一样直接。</p><h1 id="开始干活"><a href="#开始干活" class="headerlink" title="开始干活"></a>开始干活</h1><h2 id="本地"><a href="#本地" class="headerlink" title="本地"></a>本地</h2><p><a href="http://sagirichan.com/2022/01/25/my-own-website/">关于我想要拥有自己的网站这件事</a></p><h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><h3 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h3><p>安装nginx</p><blockquote><p>apt install nginx</p></blockquote><p>查看nginx版本</p><blockquote><p>nginx -v</p></blockquote><p>启动nginx</p><blockquote><p>service nginx start</p></blockquote><p>在浏览器输入服务器的公网IP便可以看到nginx的欢迎页面。</p><p><img src="https://s2.loli.net/2022/04/29/gmZ6RErIefAU9Wo.png" alt="welcome-to-nginx.png" loading="lazy"></p><p>为nginx创建用来存放网站静态文件的文件夹</p><blockquote><p>mkdir -p &#x2F;var&#x2F;www&#x2F;hexo<br>#教程里都写这个目录，虽然不知道是否有什么深意，但还是跟着做了<br>#-p 确保目录名称存在，不存在的就建一个。</p></blockquote><p>修改目录所有者</p><blockquote><p><code>chown -R $USER:$USER /var/www/hexo</code><br>#这里的$USER填<a href="https://zhuanlan.zhihu.com/p/105482468">用户名</a><br>#这里我使用的是腾讯云服务器ubuntu实例的默认用户名<code>ubuntu</code><br>#因此这里我是这样写的：chown -R ubuntu:ubuntu &#x2F;var&#x2F;repo&#x2F;<br>#当然也有教程是建立了一个git用户，这样更规范，也推荐使用<br>#<code>-R</code>参数表示递归处理，将指定目录下的所有文件及子目录一并处理<br>#<code>USER:USER</code>中，前一个USER是指用户名，后一个USER是指用户所属的群组</p></blockquote><p>修改目录权限</p><blockquote><p>chmod -R 755 &#x2F;var&#x2F;www&#x2F;hexo<br>#chmod 755 设置用户的权限为：<br>#1.文件所有者可读可写可执行<br>#2.与文件所有者同属一个用户组的其他用户可读可执行<br>#3.其它用户组可读可执行</p></blockquote><p>修改Nginx的<code>default</code>文件使得<code>root</code>指向刚刚创建的<code>/var/www/hexo</code>目录：</p><blockquote><p>vim &#x2F;etc&#x2F;nginx&#x2F;sites-available&#x2F;default</p></blockquote><p>在server大括号中，添加如图所示的一句话：</p><blockquote><p>root &#x2F;var&#x2F;www&#x2F;hexo;</p></blockquote><p><img src="https://s2.loli.net/2022/04/30/Rw7zbuLlJ3IOK8Z.png" alt="修改nginx的default文件.png" loading="lazy"></p><p>重启nginx服务。</p><blockquote><p>service nginx restart</p></blockquote><h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><p>建立一个git仓库目录</p><blockquote><p>mkdir &#x2F;var&#x2F;repo&#x2F; </p></blockquote><p>修改目录权限</p><blockquote><p><code>chown -R $USER:$USER /var/repo/</code><br>#这里目录所有者与上文nginx静态文件目录所有者相同，我是<code>ubuntu</code>.<br>chmod -R 755 &#x2F;var&#x2F;repo&#x2F;</p></blockquote><p>将这个仓库初始化</p><blockquote><p>cd &#x2F;var&#x2F;repo<br>git init –bare hexoblog.git<br>#参考文章：<a href="https://blog.csdn.net/sinat_34349564/article/details/52487860">git init 与git init –bare</a></p></blockquote><p>配置hook（钩子）文件</p><blockquote><p>vim &#x2F;var&#x2F;repo&#x2F;myblog.git&#x2F;hooks&#x2F;post-receive<br>#git post-receive机制：这个hook是git服务器在受到push请求时，并且接受完代码提交时触发<br>#参考：<a href="https://www.imqianduan.com/git-svn/335.html">使用git hooks(post-receive)实现简单的远程自动部署</a><br>#不会用vim可以看一看简单指令-&gt;<a href="https://www.runoob.com/linux/linux-vim.html">Linux vi&#x2F;vim</a></p></blockquote><p>打开文件后在其中输入：</p><pre><code>#!/bin/bashgit --work-tree=/var/www/hexo --git-dir=/var/repo/hexoblog.git checkout -f</code></pre><blockquote><p>参考文章：<br><a href="https://www.cnblogs.com/Jerryshome/archive/2011/12/15/2289218.html">Git系列之二 — git-dir &amp; work-tree</a><br><a href="https://blog.csdn.net/weixin_44567318/article/details/110099081">git checkout 检出命令——自由切换分支&amp;恢复文件</a></p></blockquote><p>保存后修改权限</p><blockquote><p>chmod +x &#x2F;var&#x2F;repo&#x2F;myblog.git&#x2F;hooks&#x2F;post-receive<br>#参考文章：<a href="https://blog.csdn.net/yzh_1346983557/article/details/92571987">chmod +x，赋予“可执行”权限</a></p></blockquote><h2 id="本地与云端建立SSH连接"><a href="#本地与云端建立SSH连接" class="headerlink" title="本地与云端建立SSH连接"></a>本地与云端建立SSH连接</h2><ul><li><p>如果你注册过github，那你大概率曾经生成过公钥，查看（Windows）电脑是否有<code>C/Users/Administrator/.ssh/</code>文件夹，如果有的话，文件夹下<code>id_rsa.pub</code>就是你的公钥。</p><p>  P.S. Linux系统的公钥在<code>~/.ssh/id_rsa.pub</code>文件中。</p><p>  使用</p><blockquote><p>ssh-copy-id [用户名]@[云服务器IP]</p></blockquote><p>  向云服务器传送公钥。</p><p>  举个例子，假设我的云服务IP是<code>10.10.10.10</code>，我要向服务器上<code>sagiri</code>用户传送公钥，那么我就使用</p><blockquote><p>ssh-copy-id <a href="mailto:&#x73;&#x61;&#x67;&#x69;&#114;&#105;&#64;&#x31;&#x30;&#x2e;&#49;&#x30;&#46;&#49;&#48;&#x2e;&#49;&#48;">&#x73;&#x61;&#x67;&#x69;&#114;&#105;&#64;&#x31;&#x30;&#x2e;&#49;&#x30;&#46;&#49;&#48;&#x2e;&#49;&#48;</a></p></blockquote><p>  指令。</p><p>  由于我们之前配置仓库时，<code>git仓库</code>的所有者和<code>nginx静态文件目录</code>的所有者我都填了<code>ubuntu</code>，所以这里的用户名当然也是<code>ubuntu</code>.</p><p>  这里需要输入一次用户密码。</p></li><li><p>如果电脑上没有<code>C/Users/Administrator/.ssh/</code>文件夹，那么就使用</p><blockquote><p>ssh-keygen</p></blockquote><p>  指令先生成一个公钥，然后再用</p><blockquote><p>ssh-copy-id [用户名]@[云服务器IP]<br>#命令讲解见上文</p></blockquote><p>  传送公钥。</p></li></ul><h2 id="修改hexo配置文件"><a href="#修改hexo配置文件" class="headerlink" title="修改hexo配置文件"></a>修改hexo配置文件</h2><p>回到我们的本地，打开hexo文件夹下的<code>_config.yml</code>文件进行配置</p><ul><li><p>找到<code>url</code>字段，将其配置为</p><blockquote><p>url: http:&#x2F;&#x2F;[服务器IP|服务器网址]&#x2F;</p></blockquote><p>  举例：我的服务器公网IP为<code>101.33.208.50</code>，挂载在我的服务器上的域名为<code>sagirichan.com</code>，那么这里可以填</p><blockquote><p>url: <a href="http://101.33.208.50/">http://101.33.208.50/</a></p></blockquote><p>  也可以填</p><blockquote><p>url: <a href="http://sagirichan.com/">http://sagirichan.com/</a></p></blockquote></li><li><p>找到<code>deploy</code>字段，参考下图进行配置：</p><p>  <img src="https://s2.loli.net/2022/04/30/ES9At32dGJZNsjQ.png" alt="deploy配置.png" loading="lazy"></p><p>  解释：</p><ul><li><p><code>type</code>字段是推送网页文件的方式，我们用的是git，所以这里填<code>git</code>.</p></li><li><p><code>repo</code>是代码仓库的位置，格式为</p><blockquote><p><code>仓库名称</code>: <code>仓库用户名</code>@<code>仓库位置</code></p></blockquote><p>  我使用了两个仓库，一个是我本次部署在云端的仓库，另一个是我在初学搭建网站时部署在github上的仓库。</p><p>  以云端仓库为例</p><ul><li><p><code>仓库名称</code>可以随便取，我的服务器来自腾讯云，所以我取名为<code>tencentCloud</code></p></li><li><p><code>仓库用户名</code>字段，由于部署时我设置的云端<code>git仓库</code>的所有者为<code>ubuntu</code>，所以这里也是<code>ubuntu</code>.</p></li><li><p><code>仓库位置</code>字段，即是之前部署时设置的仓库位置。</p></li></ul><p>  github仓库格式同理<del>而且搭建网站的教程百分之九十九都会讲这个的</del></p></li><li><p>对于deploy字段，除了展示的关键词，还有<code>branch</code>、<code>message</code>等关键词可供选择<del>但是我嫌麻烦就没有继续深入研究了</del>。</p><p>  <img src="https://s2.loli.net/2022/05/01/URreFvp7zLquGbX.png" alt="deploy补充.png" loading="lazy"></p></li></ul></li></ul><h1 id="万事俱备"><a href="#万事俱备" class="headerlink" title="万事俱备"></a>万事俱备</h1><p>在hexo文件夹下打开终端（vscode、power shell、git bash等等任意终端），输入<code>hexo三连</code>：</p><blockquote><p>hexo clean<br>hexo g<br>hexo d<br>#g是generation，生成网页文件<br>#d是deploy，发布网站。实际上deploy命令是将网页文件推送到远程仓库中。参考<a href="https://hexo.io/zh-cn/docs/one-command-deployment#%E8%BF%99%E4%B8%80%E5%88%87%E6%98%AF%E5%A6%82%E4%BD%95%E5%8F%91%E7%94%9F%E7%9A%84%EF%BC%9F">这一切是如何发生的？</a>。</p></blockquote><p>或者也可以简化为两连：</p><blockquote><p>hexo clean<br>hexo g -d</p></blockquote><p>如果终端支持的话，还可以写进一行：</p><blockquote><p>hexo clean &amp;&amp; hexo g -d</p></blockquote><p>然后在浏览器地址栏中输入云服务器的公网IP或者绑定的域名（如果有的话），我们就可以访问到自己的网站啦。</p><p><img src="https://s2.loli.net/2022/05/01/fBLxY8jW3vz2lRi.png" alt="网站首页.png" loading="lazy"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;前言&lt;br&gt;在我的另一篇文章&lt;a href=&quot;http://sagirichan.com/2022/01/25/my-own-website/&quot;&gt;关于我想要拥有自己的网站这件事&lt;/a&gt;中，我搭建了一个基于&lt;a href=&quot;https://pages</summary>
      
    
    
    
    
    <category term="hexo" scheme="http://sagirichan.com/tags/hexo/"/>
    
    <category term="nginx" scheme="http://sagirichan.com/tags/nginx/"/>
    
    <category term="git" scheme="http://sagirichan.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>git-learning</title>
    <link href="http://sagirichan.com/2022/04/24/git-learning/"/>
    <id>http://sagirichan.com/2022/04/24/git-learning/</id>
    <published>2022-04-24T12:50:24.000Z</published>
    <updated>2022-05-15T15:50:49.214Z</updated>
    
    <content type="html"><![CDATA[<ul><li>git stash提示xx文件: needs merge</li></ul><p>使用<code>git add .</code></p><ul><li>vscode解决冲突</li></ul><p><code>Current Change</code>是新代码，<code>Incoming Change</code>是旧代码。</p><ul><li>error: The following untracked working tree files would be overwritten by merge:</li></ul><p><code>git clean -d -fx</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;git stash提示xx文件: needs merge&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用&lt;code&gt;git add .&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;vscode解决冲突&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Current Change&lt;/cod</summary>
      
    
    
    
    
    <category term="git" scheme="http://sagirichan.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Powerdesigner安装、破解、汉化</title>
    <link href="http://sagirichan.com/2022/03/20/powerdesigner-guide/"/>
    <id>http://sagirichan.com/2022/03/20/powerdesigner-guide/</id>
    <published>2022-03-20T11:20:59.000Z</published>
    <updated>2022-05-15T15:45:36.202Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>参考链接：<br>  <a href="https://www.cnblogs.com/huangting/p/12654057.html">PowerDesigner 安装+汉化+破解+使用过程</a><br>  <a href="https://zhuanlan.zhihu.com/p/179260147">PowerDesigner安装教程</a></p></blockquote><h1 id="Powerdesigner-安装"><a href="#Powerdesigner-安装" class="headerlink" title="Powerdesigner 安装"></a>Powerdesigner 安装</h1><h2 id="Powerdesigener-工具包下载"><a href="#Powerdesigener-工具包下载" class="headerlink" title="Powerdesigener 工具包下载"></a>Powerdesigener 工具包下载</h2><p>下载链接：<a href="https://pan.baidu.com/s/1qznLBQvkjiCKcmHBnsSRZg">https://pan.baidu.com/s/1qznLBQvkjiCKcmHBnsSRZg</a><br>提取码：jdt5</p><h2 id="Powerdesigener-安装"><a href="#Powerdesigener-安装" class="headerlink" title="Powerdesigener 安装"></a>Powerdesigener 安装</h2><ul><li>点击安装文件进入安装界面。</li></ul><p><img src="https://s2.loli.net/2022/03/20/DE7pWmSOFNgGqJi.png" alt="点击安装文件.png" loading="lazy"></p><p><img src="https://s2.loli.net/2022/03/20/EuvMrHRBO2fjg3p.png" alt="安装界面.png" loading="lazy"></p><ul><li>选择方框中选项（默认选项）</li></ul><p><img src="https://s2.loli.net/2022/03/20/Grn2Dg5BYM9tRiq.png" alt="licenceType.png" loading="lazy"></p><ul><li>选择国家或地区。</li></ul><p><img src="https://s2.loli.net/2022/03/20/s8kl32mDCIgynjL.png" alt="location.png" loading="lazy"></p><ul><li>同意软件使用许可证。</li></ul><p><img src="https://s2.loli.net/2022/03/20/QwUD62pZuiTq4xk.png" alt="IAgree.png" loading="lazy"></p><ul><li>选择安装位置</li></ul><p><img src="https://s2.loli.net/2022/03/20/86vdjUotm2uROEQ.png" alt="选择安装位置.png" loading="lazy"></p><ul><li>选择插件，这里保持默认设置，直接next就行。</li></ul><p><img src="https://s2.loli.net/2022/03/20/zn43ZON8WrVMF6C.png" alt="features.png" loading="lazy"></p><ul><li>这里全选。</li></ul><p><img src="https://s2.loli.net/2022/03/20/DFneVpXOAcgdxrb.png" alt="profiles.png" loading="lazy"></p><ul><li>记住文件路径，next。</li></ul><p><img src="https://s2.loli.net/2022/03/20/s9NXednp5oMhiHF.png" alt="programfolders.png" loading="lazy"></p><ul><li>检查一下自己的设置，没有问题就next。</li></ul><p><img src="https://s2.loli.net/2022/03/20/sMaJm5coHYEB3wN.png" alt="check.png" loading="lazy"></p><ul><li>等待安装</li></ul><p><img src="https://s2.loli.net/2022/03/20/bCBI5cZMTUdki3f.png" alt="installing.png" loading="lazy"></p><ul><li>安装完成</li></ul><p><img src="https://s2.loli.net/2022/03/20/pUME2GJ6TgZYjOt.png" alt="installed.png" loading="lazy"></p><h2 id="Powerdesigener-破解"><a href="#Powerdesigener-破解" class="headerlink" title="Powerdesigener 破解"></a>Powerdesigener 破解</h2><ul><li>在破解软件文件夹中找到pdflm 16.dll。</li></ul><p><img src="https://s2.loli.net/2022/03/20/bWL9yjuiaqfJnlt.png" alt="破解dll.png" loading="lazy"></p><p>将其覆盖到Powerdesigner的安装目录中</p><p><img src="https://s2.loli.net/2022/03/20/YKnRMyNdPC31aQX.png" alt="覆盖破解文件.png" loading="lazy"></p><h2 id="Powerdesigener-汉化"><a href="#Powerdesigener-汉化" class="headerlink" title="Powerdesigener 汉化"></a>Powerdesigener 汉化</h2><ul><li>打开汉化包文件夹</li></ul><p><img src="https://s2.loli.net/2022/03/20/RhvwzC5HkeAnIjr.png" alt="汉化文件.png" loading="lazy"></p><ul><li>全选并覆盖到Powerdesigner安装目录中</li></ul><p><img src="https://s2.loli.net/2022/03/20/14zZnBmMjCqJNat.png" alt="全选.png" loading="lazy"></p><p><img src="https://s2.loli.net/2022/03/20/p5TI6hOmM7ZwkSi.png" alt="覆盖汉化文件.png" loading="lazy"></p><hr><hr><p>点击PdShell16.exe即可启动软件，如果不能启动，则使用pdlegacyshell16.exe文件。</p><p><img src="https://s2.loli.net/2022/03/20/OzuANBIX1CbWeM9.png" alt="启动文件.png" loading="lazy"></p><p>为了方便，也可以在桌面上创建一个快捷方式</p><p><img src="https://s2.loli.net/2022/03/20/Bk4m7lcUSXfrb3p.png" alt="快捷方式.png" loading="lazy"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;参考链接：&lt;br&gt;  &lt;a href=&quot;https://www.cnblogs.com/huangting/p/12654057.html&quot;&gt;PowerDesigner 安装+汉化+破解+使用过程&lt;/a&gt;&lt;br&gt;  &lt;a href=&quot;https:/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>navicat v15破解版安装手册</title>
    <link href="http://sagirichan.com/2022/03/12/navicat-install-guide/"/>
    <id>http://sagirichan.com/2022/03/12/navicat-install-guide/</id>
    <published>2022-03-12T08:53:30.000Z</published>
    <updated>2022-05-15T15:46:04.783Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>参考链接：<a href="https://cloud.tencent.com/developer/article/1804255">Navicat Premium 15安装教程(完整激活版)</a></p></blockquote><h1 id="navicat下载"><a href="#navicat下载" class="headerlink" title="navicat下载"></a>navicat下载</h1><hr><ul><li><strong>navicat官网地址：<a href="https://navicat.com.cn/">https://navicat.com.cn/</a>，我们主张在力所能及的情况下支持正版。</strong></li></ul><hr><p>Navicat Premium 15与Navicat Premium 15注册机下载链接：<a href="https://pan.baidu.com/s/1DL9_UYY3agUHPn3mjoOViQ#list/path=%2F">https://pan.baidu.com/s/1DL9_UYY3agUHPn3mjoOViQ#list&#x2F;path&#x3D;%2F</a><br>提取码：0d8b</p><h1 id="navicat安装"><a href="#navicat安装" class="headerlink" title="navicat安装"></a>navicat安装</h1><ul><li>直接点击下载下来的<code>navicat150_premium_cs_x64.exe</code>文件，进入安装界面。点击<code>下一步</code>开始安装。</li></ul><p><img src="https://s2.loli.net/2022/03/12/fCXF4wtq1K7zvhU.png" alt="安装.png" loading="lazy"></p><ul><li>选择<code>我同意</code>、<code>下一步</code>。</li></ul><p><img src="https://s2.loli.net/2022/03/12/yF2zf74sMkUcwBj.png" alt="同意许可证.png" loading="lazy"></p><ul><li>自定义安装目录。</li></ul><p><img src="https://s2.loli.net/2022/03/12/zjya9TIB7VpSuDC.png" alt="安装位置.png" loading="lazy"></p><ul><li>一路点击<code>下一步</code>，直到出现“准备安装”界面，点击<code>安装</code>，等待安装完毕。</li></ul><p><img src="https://s2.loli.net/2022/03/12/rbOgUCEyZ26VNme.png" alt="快捷方式 .png" loading="lazy"></p><p><img src="https://s2.loli.net/2022/03/12/jryncoDfxYCZlS1.png" alt="创建桌面图标.png" loading="lazy"></p><p><img src="https://s2.loli.net/2022/03/12/MrNUkVaJeEOlv8w.png" alt="准备安装.png" loading="lazy"></p><p><img src="https://s2.loli.net/2022/03/12/azhtEeIixZJMXUP.png" alt="等待安装.png" loading="lazy"></p><p><img src="https://s2.loli.net/2022/03/12/QoDcbxaeAhR4BTs.png" alt="安装完成.png" loading="lazy"></p><h1 id="navicat破解"><a href="#navicat破解" class="headerlink" title="navicat破解"></a>navicat破解</h1><blockquote><p>使用注册机时建议退出杀毒软件，并且不要打开navicat。</p></blockquote><ul><li>双击注册机文件<code>Navicat Keygen Patch v5.6.0 DFoX.exe</code>运行。</li></ul><p><img src="https://s2.loli.net/2022/03/12/XmQMKJUOwoahx5b.png" alt="双击注册机文件.png" loading="lazy"></p><p><img src="https://s2.loli.net/2022/03/12/bLYw7kj96Gxidyf.png" alt="注册机.png" loading="lazy"></p><ul><li>在<code>1) Patch</code>栏选择<code>Backup</code>、<code>Host</code>、<code>Navicat v15</code>三个选项（默认也是这三个选项）并且点击<code>Patch</code>，找到在navicat安装目录下的<code>navicat.exe</code>文件。</li></ul><p><img src="https://s2.loli.net/2022/03/12/NYBtFOoZClLxX3v.png" alt="1_patch.png" loading="lazy"></p><p><img src="https://s2.loli.net/2022/03/12/23fRWTI5hcjJCxp.png" alt="patch到exe文件.png" loading="lazy"></p><p>出现下图即说明patch成功。</p><p><img src="https://s2.loli.net/2022/03/12/OJA5EZ6Kp7TCmP1.png" alt="patch成功.png" loading="lazy"></p><ul><li>在<code>2) License. Product and Language</code>中，<code>License</code>选择<code>Enterprise</code>，<code>Produce</code>选择<code>Premium</code>，<code>Languages</code>选择<code>Simplified Chinese</code>。<br>在<code>3)Resale License</code>中，<code>Resale Versions</code>选择<code>Site license</code>。<br>P.S. 以上都是默认设置。</li></ul><p><img src="https://s2.loli.net/2022/03/12/BI5hnswedxMPtaC.png" alt="2_3_.png" loading="lazy"></p><ul><li>在<code>4) Keygen / Offline Activation</code>中点击第一行右侧<code>Generate</code>按钮，在左边<code>Serial Keygen</code>栏便会生成一个许可证密钥，点击<code>Copy</code>复制。</li></ul><p><img src="https://s2.loli.net/2022/03/12/UJejSGQ9dTWa1kx.png" alt="4_keygen.png" loading="lazy"></p><ul><li>打开navicat软件，点击<code>注册</code>。</li></ul><p><img src="https://s2.loli.net/2022/03/12/p3UymZG8bjMCfAa.png" alt="点击注册.png" loading="lazy"></p><ul><li>在左侧粘贴许可证密钥，并且点击<code>激活</code>。</li></ul><p><img src="https://s2.loli.net/2022/03/12/iSnPNYxwRktUWH8.png" alt="粘贴许可证密钥.png" loading="lazy"></p><ul><li>提示激活服务器不可使用，选择手动激活。</li></ul><p><img src="https://s2.loli.net/2022/03/12/kgXuRPyIsSJAfic.png" alt="手动激活.png" loading="lazy"></p><p>产生一个请求码。</p><p><img src="https://s2.loli.net/2022/03/12/2M6PmLgu3wBS49j.png" alt="生成请求码.png" loading="lazy"></p><ul><li>将请求码填入<code>Request Code</code>中，并点击左下方<code>Activation Code</code>中的<code>Generate</code>按钮，注册机便会自动生成一个激活码并填入navicat的注册码框中。</li></ul><p><img src="https://s2.loli.net/2022/03/12/SkMTE1vjYKel7mt.png" alt="填入激活码.png" loading="lazy"></p><p>点击激活，激活成功。</p><p><img src="https://s2.loli.net/2022/03/12/E9ykxcVtsXrGWmB.png" alt="激活成功.png" loading="lazy"></p><p>如图。</p><p><img src="https://s2.loli.net/2022/03/12/2kVfx7N8ULpPTob.png" alt="激活成功2.png" loading="lazy"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;参考链接：&lt;a href=&quot;https://cloud.tencent.com/developer/article/1804255&quot;&gt;Navicat Premium 15安装教程(完整激活版)&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 i</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MySQL安装与配置（免安装版）</title>
    <link href="http://sagirichan.com/2022/03/02/MySQL-guide/"/>
    <id>http://sagirichan.com/2022/03/02/MySQL-guide/</id>
    <published>2022-03-02T06:03:43.000Z</published>
    <updated>2022-05-15T15:44:29.650Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>参考链接：<a href="https://www.cnblogs.com/winton-nfs/p/11524007.html">MySQL的安装与配置——详细教程</a></p></blockquote><h1 id="MySQL下载"><a href="#MySQL下载" class="headerlink" title="MySQL下载"></a>MySQL下载</h1><ul><li>在浏览器地址栏中输入<code>mysql.com</code>，点击回车，进入MySQL官网首页。</li></ul><p><img src="https://s2.loli.net/2022/02/28/yJNsq2behBYl5fE.png" alt="mysql官网首页.png" loading="lazy"></p><ul><li>将页面拉到最底部，寻找到<code>Downloads</code>下的<code>MySQL Community Server</code>链接，点击，进入下载页面。</li></ul><p><img src="https://s2.loli.net/2022/02/28/gFxf2ZnVzbTPGmS.png" alt="首页底部2.png" loading="lazy"></p><ul><li>操作系统选择Microsoft Windows。</li></ul><p><img src="https://s2.loli.net/2022/02/28/cJN4PXuhCMfRQ1r.png" alt="选择操作系统.png" loading="lazy"></p><ul><li>在下方选择免安装版，点击Download按钮。</li></ul><p><img src="https://s2.loli.net/2022/02/28/TPZIJkLRSY6mqlc.png" alt="选择免安装版2.png" loading="lazy"></p><ul><li>选择No thanks，当然有兴趣的话也可以使用已有的或者注册一个Oracle账户登录，笔者这里不再添足。</li></ul><p><img src="https://s2.loli.net/2022/02/28/vPiyMrnu9OYqlf5.png" alt="nothanks2.png" loading="lazy"></p><p>保存路径避免出现中文。</p><p><img src="https://s2.loli.net/2022/02/28/4prCNBZdT1i6QPI.png" alt="保存.png" loading="lazy"></p><p>下载完成后解压。</p><p><img src="https://s2.loli.net/2022/02/28/amuCRAFybBWOdPc.png" alt="解压.png" loading="lazy"></p><h1 id="MySQL安装与配置"><a href="#MySQL安装与配置" class="headerlink" title="MySQL安装与配置"></a>MySQL安装与配置</h1><h2 id="MySQL安装"><a href="#MySQL安装" class="headerlink" title="MySQL安装"></a>MySQL安装</h2><ul><li>使用<code>win+R</code>快捷键打开<code>运行</code>并输入<code>cmd</code>。</li></ul><p><img src="https://s2.loli.net/2022/02/28/Fz4oksUQiXOAvNm.png" alt="cmd.png" loading="lazy"></p><ul><li>使用<code>Ctrl+shift+Enter</code>快捷键，以管理员模式运行cmd。</li></ul><p><img src="https://s2.loli.net/2022/02/28/OfYh7BE6AvQqr21.png" alt="是否允许管理员模式.png" loading="lazy"></p><p>选择<code>是</code>即可。</p><p><img src="https://s2.loli.net/2022/02/28/bP4XHmfpDWM8cuU.png" alt="管理员cmd.png" loading="lazy"></p><ul><li>进入解压后的文件夹中的<code>bin</code>目录下。</li></ul><p><img src="https://s2.loli.net/2022/03/02/oBM1OKrj49JZPnF.png" alt="bin目录.png" loading="lazy"></p><p><img src="https://s2.loli.net/2022/03/02/xUG9ty8B5laibfr.png" alt="进入bin.png" loading="lazy"></p><ul><li>安装MySQL服务：<code>mysqld --install</code></li></ul><p><img src="https://s2.loli.net/2022/03/02/ORdBmnq3VSkiIhr.png" alt="安装MySQL服务.png" loading="lazy"></p><p>安装成功后会出现如图所示的提示<code>Service successfully installed.</code></p><ul><li>使用<code>mysqld --initialize --console</code>初始化MySQL</li></ul><p><img src="https://s2.loli.net/2022/03/02/CFLsbU7yvXfNJ3w.png" alt="初始化MySQL.png" loading="lazy"></p><p>最后一行给出了本次初始化生成的随机密码：<code>-hdJ-+c%#75_</code></p><ul><li>使用<code>net start mysql</code>启动服务</li></ul><p><img src="https://s2.loli.net/2022/03/02/Zhg1U8FGj2K6Lw9.png" alt="启动服务.png" loading="lazy"></p><ul><li>使用<code>mysql -u root -p</code>登录</li></ul><p><img src="https://s2.loli.net/2022/03/02/FLRCTbPd7mZpYvy.png" alt="登录MySQL.png" loading="lazy"></p><p>出现如上图提示则登录成功。</p><ul><li>使用指令<code>alter user &#39;root&#39;@&#39;localhost&#39; identified by &#39;xxxx&#39;;</code>修改密码。<br>上述指令中<code>xxxx</code>部分即为要修改的密码。</li></ul><p><img src="https://s2.loli.net/2022/03/02/vpRAEgGhFjqtr8S.png" alt="修改密码.png" loading="lazy"></p><ul><li>使用<code>exit</code>退出，然后重新登陆验证密码。</li></ul><p><img src="https://s2.loli.net/2022/03/02/DxZjBUy6SzsfTr2.png" alt="验证密码.png" loading="lazy"></p><h2 id="设置全局变量"><a href="#设置全局变量" class="headerlink" title="设置全局变量"></a>设置全局变量</h2><ul><li>我的电脑-右击-属性-高级系统设置-环境变量。<br>在系统变量中新建一个mysql变量，变量值为mysql安装路径。</li></ul><p><img src="https://s2.loli.net/2022/03/02/QB6F2gIU48TJEbM.png" alt="系统变量MySQL.png" loading="lazy"></p><ul><li>将该变量添加到PATH中。</li></ul><p><img src="https://s2.loli.net/2022/03/02/QTeC7KM3I6juU1z.png" alt="PATH变量.png" loading="lazy"></p><ul><li>这样，我们就可以在打开cmd后，直接登录MySQL。</li></ul><p><img src="https://s2.loli.net/2022/03/02/Shiy8wF3JQBsd76.png" alt="直接登录.png" loading="lazy"></p><hr><p>以上便是免安装版MySQL的使用指南。</p><hr><p>2022.4.8补充：</p><p>重装MySQL时报错<code>The service already exists!</code>，使用<code>mysqld -remove MySQL</code>移除MySQL服务即可。</p><p>卸载MySQL步骤：</p><ul><li><p><code>net stop mysql</code>（要在管理员模式下）</p></li><li><p>删除注册表</p></li><li><p>删除安装文件夹</p></li><li><p>删除C:\ProgramData或C:\Program Files (x86)下MySQL文件（如果有的话</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;参考链接：&lt;a href=&quot;https://www.cnblogs.com/winton-nfs/p/11524007.html&quot;&gt;MySQL的安装与配置——详细教程&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;MySQL下载&quot;&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>我的sagiri机器人</title>
    <link href="http://sagirichan.com/2022/01/27/my-sagiri-bot/"/>
    <id>http://sagirichan.com/2022/01/27/my-sagiri-bot/</id>
    <published>2022-01-27T15:53:47.000Z</published>
    <updated>2022-04-30T15:37:14.006Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>虽然本站域名叫sagiri，本文标题提到的的QQ机器人也叫sagiri，但是实际上这个机器人并不是笔者开发的，出现这种巧合单纯只是因为笔者与这个机器人的作者都喜欢sagiri<del>为什么有一种被NTR的感觉</del>。</p></blockquote><p>在另一篇博文<a href="https://ireinasan.github.io/2022/01/27/my-own-QQbot/">关于我想拥有自己的QQ机器人，及我的失败经历</a>中，我展现了我从兴致高昂地试图跟着<a href="https://docs.bot.elpsy.cn/">云游的教程</a>搭建机器人、到屡败屡战顽强不屈、最终心态大崩决定放弃的失败经历。</p><p>雄关漫道真如铁，而今迈步从头越。笔者并不是一个轻言放弃的人<del>主要还是放假太闲了</del>！在遭受了这样惨痛的失败后，依然痛定思痛，继续探索搭建QQ机器人的方法。</p><p>很幸运的是，我在GitHub上找到了这样一个利用python开发的mirai机器人：</p><p><a href="https://github.com/SAGIRI-kawaii/sagiri-bot">sagiri-bot</a></p><p>虽然我运行el-bot失败了，但是我能够成功使用mcl启动mirai-console，这让我更换机器人框架的成本大大降低。</p><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>sagiri是一个完善的、可以直接运行的QQ机器人，和el-bot一样，都是基于mirai框架；只不过el-bot用js&#x2F;ts开发，而sagiri用python开发。</p><p>故事的开始，起源于我失败的el-bot搭建经历（见上文链接）。彼时的笔者心灰意冷，并觉得云游的项目实在是太坑了，进而决定放弃通过javascrip开发mirai机器人，转而投向更热门的python方向。于是我在GitHub上搜索<code>mirai python</code>，很快发现了本文要讲述的项目。</p><h1 id="部署于本地"><a href="#部署于本地" class="headerlink" title="部署于本地"></a>部署于本地</h1><p>处于方便管理等因素，我选择的项目文件夹结构为</p><p>luka-sagiri-mirai<br>├── mcl<br>├── sagiri-bot</p><p>其中luka-sagiri-mirai为整个项目的目录，mcl为mirai框架启动目录，sagiri-bot为我克隆sagiri机器人的目录。</p><p>跟随着<a href="https://sagiri-kawaii.github.io/sagiri-bot/deployment/">官方文档</a>：</p><h2 id="启动mcl"><a href="#启动mcl" class="headerlink" title="启动mcl"></a>启动mcl</h2><p>在mcl目录中，配置好<code>mirai-api-http-v2</code>。</p><p>配置<code>mcl\config\net.mamoe.mirai-api-http\setting.yml</code>文件如下：</p><pre><code>adapters:- http- wsdebug: falseenableVerify: trueverifyKey: liuyan # 可以自己设定, 后续会用到singleMode: falsecacheSize: 4096 # 可选, 缓存大小, 默认4096. 缓存过小会导致引用回复与撤回消息失败adapterSettings:## 详情看 http adapter 使用说明 配置http:    host: localhost    port: 8080 # 端口可选，后续会用到    cors: [*]## 详情看 websocket adapter 使用说明 配置ws:    host: localhost    port: 8080 # 端口同上    reservedSyncId: -1 # 确保为 -1, 否则 WebsocketAdapt</code></pre><p>启动mcl。</p><h2 id="启动bot"><a href="#启动bot" class="headerlink" title="启动bot"></a>启动bot</h2><p>在主目录中</p><pre><code>git clone https://github.com/SAGIRI-kawaii/sagiri-bot.git sagiri-botcd sagiri-bot</code></pre><p>配置python环境<code>pip install -i https://pypi.doubanio.com/simple/ -r .\requirements.txt</code></p><p>PS. 原指令为<code>pip install -r requirements.txt</code>，而上面的指令是我在<a href="https://jq.qq.com/?_wv=1027&k=b9w1cThz">QQ群</a>中问问题时一位群友告诉我的，这里感谢群友。</p><p>PSS. 我在这一步遇到了不大不小的麻烦。我之前试图跑过<code>python-mirai</code>项目，安装了<code>graia-application-mirai</code>包（虽然最后并没有跑起来），所以在这一步，这个包让我配置的环境出了问题。后来我删除了<code>graia-application-mirai</code>包，解决问题。</p><p>在sagiri-bot文件夹下找到<code>configdemo.yaml</code>并修改如下：</p><pre><code># 必要数据及设置bot_qq: 2775446955 #bot QQhost_qq: 2937818202 #主人QQmirai_host: http://localhost:8080 #本地端口，可任意选择，但要与mcl\config\net.mamoe.mirai-api-http\setting.yml中的保持一致verify_key: liuyandb_link: sqlite+aiosqlite:///sagiribot.db #数据库链接，见项目README。web_manager_api: trueweb_manager_auto_boot: trueproxy: proxy# 路径相关image_path:setu: setusetu18: setu18 #R18real: real #三次元real_highq: real_highq #高质量三次元wallpaper: wallpaper #壁纸sketch: sketch #线稿# 功能相关functions:tencent:    secret_id: secret_id    secret_key: secret_keysaucenao_api_key: saucenao_api_keywolfram_alpha_key: wolfram_alpha_keyshadiao_app_name: shadiao_app_name# 日志相关log_related:error_retention: 14common_retention: 7# 数据相关data_related:lolicon_image_cache: true #缓存lolicon api获得图片network_data_cache: true #缓存lolicon api获取jsonautomatic_update: false #自动更新data_retention: true #退群后数据处理# 数据库相关database_related:mysql:    pool_size: 40    max_overflow: 60</code></pre><p>将<code>configdemo.yaml</code>文件更名为<code>config.yaml</code>。</p><p>注：需自行安装数据库。<a href="https://www.jianshu.com/p/424a8b143bbb">SQLite快速入门教程</a></p><p>在sagiri-bot目录下运行一次bot：<code>python main.py</code>。bot应会自动退出。</p><p>寻找<code>alembic.ini</code>文件，打开，将<code>sqlalchemy.url</code>项更换为<code>configdemo.yaml</code>中的<code>db_link</code>项。以我为例：</p><blockquote><p>sqlalchemy.url &#x3D; sqlite:&#x2F;&#x2F;&#x2F;sagiribot.db</p></blockquote><p>再次启动，成功。</p><p><img src="https://s2.loli.net/2022/01/28/wx9lFVDXnmGCyLa.png" alt="9.png" loading="lazy"></p><p>以上。</p><p>附<a href="https://sagiri-kawaii.github.io/sagiri-bot/">sagiri机器人使用文档</a>。</p><blockquote><p>bot的events代码位置：<code>sagiri_bot\handler\required_module\mirai_event\mirai_events.py</code></p></blockquote><h1 id="部署至云端"><a href="#部署至云端" class="headerlink" title="部署至云端"></a>部署至云端</h1><p>作为一个机器人，需要全天候24小时为群友服务，那么只部署在本地自然是不行的，如果我关了电脑，那机器人也将随之下线。所以我决定将机器人部署至云端。</p><p>在云端部署机器人，需要在云端复刻本地端的环境、代码、操作过程。写到这里感慨还好我记录了在本地部署机器人的步骤，否则在云端部署机器人又要麻烦半天。即使如此，由于云服务器的控制台没有图形界面，我在部署过程中依然遭遇了许多困难。</p><h2 id="向云服务器传输文件"><a href="#向云服务器传输文件" class="headerlink" title="向云服务器传输文件"></a>向云服务器传输文件</h2><p>我使用<a href="https://winscp.net/eng/docs/lang:chs">WinScp</a>来传输文件。参考文章</p><p><a href="https://cloud.tencent.com/document/product/1207/53134#.E7.99.BB.E5.BD.95-winscp">Windows 系统通过 WinSCP 上传文件到 Linux 轻量应用服务器</a></p><blockquote><p>省流：<br>        默认用户名root<br>        ubuntu实例默认ubuntu<br>        密码忘了直接重置</p></blockquote><p><a href="https://blog.csdn.net/qq_42755868/article/details/109321089">WinScp远程下载报错：无法创建文件夹 系统错误。代码：5。 拒绝访问。问题解决（亲测有效）</a></p><blockquote><p>省流：<br>        高级-环境-STFP-STFP服务器：<code>sudo usr/lib/openssh/sftp-server</code><br>        高级-环境-shell-Shell：<code>sudo -i</code></p></blockquote><p><a href="https://blog.csdn.net/bbat2008/article/details/6891381">winscp：无法初始化SFTP协议。主机是SFTP服务器吗？</a></p><blockquote><p>省流：<br>        登录界面把文件协议改为SCP</p></blockquote><h2 id="使用VNC-viewer对云服务器进行远程操作"><a href="#使用VNC-viewer对云服务器进行远程操作" class="headerlink" title="使用VNC viewer对云服务器进行远程操作"></a>使用<a href="https://www.realvnc.com/en/connect/download/viewer/">VNC viewer</a>对云服务器进行远程操作</h2><p>参考文章：</p><p><a href="https://dalewushuang.blog.csdn.net/article/details/94554206">本地Windows远程连接阿里云服务器图形界面（使用vnc viewer）</a></p><p><a href="https://blog.csdn.net/weixin_39278265/article/details/118641412">阿里云服务器Ubuntu 18.04安装图形界面（ubuntu-desktop）（以及解决困扰我多天的vnc viewer界面灰屏的问题！震惊我自己）</a></p><blockquote><p>省流：<br>        这个过程有点繁琐，省不了流</p></blockquote><hr><blockquote><p>关于VNC viewer无法粘贴的问题：<br>命令行上没有好的解决方法；文件方面可以用WinScp配合VNC viewer，在远程服务器上和本地“共享”某个文件，来回粘贴代码。</p></blockquote><hr><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>部署过程在文档中写得很详细：<a href="https://sagiri-kawaii.github.io/sagiri-bot/deployment/linux/">sagiri-bot在Linux环境中的部署</a></p><p>按照文档一步一步做就可以了！</p><p>部署成功截图：</p><p><img src="https://s2.loli.net/2022/04/26/sy5mu3qc1P9Y7eH.png" alt="部署成功.png" loading="lazy"></p><p><img src="https://s2.loli.net/2022/04/26/ztyLbu4orHBaQFd.png" alt="云服务器状态.png" loading="lazy"></p><p>我觉得很不错嘛！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;虽然本站域名叫sagiri，本文标题提到的的QQ机器人也叫sagiri，但是实际上这个机器人并不是笔者开发的，出现这种巧合单纯只是因为笔者与这个机器人的作者都喜欢sagiri&lt;del&gt;为什么有一种被NTR的感觉&lt;/del&gt;。&lt;/p&gt;
&lt;/block</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>关于我想拥有自己的QQ机器人，及我的失败经历</title>
    <link href="http://sagirichan.com/2022/01/27/my-own-QQbot/"/>
    <id>http://sagirichan.com/2022/01/27/my-own-QQbot/</id>
    <published>2022-01-27T15:47:50.000Z</published>
    <updated>2022-01-27T17:37:10.025Z</updated>
    
    <content type="html"><![CDATA[<h1 id="源起"><a href="#源起" class="headerlink" title="源起"></a>源起</h1><p>QQ机器人，嘛，最早接触到这个东西是在公主连结的游戏群里，正经的机器人是为了提供排刀报刀等会战相关服务，但是似乎群友们总是更喜欢色图功能（</p><p>在<a href="https://www.yunyoujun.cn/">云游君</a>的群里有一个可爱的机器人小云，她会贴心地回应群友的关键词、自动转发云游的博客、自动盗群友的图转发到所有群等<del>可惜没有色图功能</del>。</p><p>寒假，在家，百无聊赖！而且觉得我已经大三了，应该做点有趣的事情，我定下了如下目标：</p><ul><li>拥有自己的机器人</li><li>拥有自己的网站</li><li>把自己的机器人挂到一个云服务器上</li></ul><p>这三件事情我想做很久了，本来其实做网站是最简单的，但是由于我是第一次购买域名，我的实名信息刚提交上去还在审核，所以就先试着做机器人吧！</p><p>这是我的第一篇博客，而且在可预见的未来不会有很多人看到，所以这篇博文主要是记录自己的心路历程，行文会比较啰嗦<del>大部分内容在自嗨</del></p><h1 id="开始行动！"><a href="#开始行动！" class="headerlink" title="开始行动！"></a>开始行动！</h1><p>既然是云游的机器人引发了我的热情，那么当然要继续薅羊毛，所以我在云游的网站上找到了两篇与机器人有关的博客:</p><ul><li><a href="https://www.yunyoujun.cn/mirai-ts/">mirai-ts</a></li><li><a href="https://docs.bot.elpsy.cn/">el-bot</a></li></ul><p>嗯。。。第二篇看起来似乎开箱即用。。。</p><p>进去看看！</p><h1 id="mirai"><a href="#mirai" class="headerlink" title="mirai"></a>mirai</h1><blockquote><p><a href="https://github.com/mamoe/mirai">mirai</a> 是一个在全平台下运行，提供 QQ Android 协议支持的高效率机器人库</p><p>这个项目的名字来源于</p><p>京都动画作品《境界的彼方》的栗山未来(Kuriyama mirai)</p><p>CRYPTON以初音未来为代表的创作与活动(Magical mirai)</p><p>图标以及形象由画师DazeCake绘制</p></blockquote><p>以上内容摘自mirai的GitHub README部分。</p><p>要使用云游的机器人，我们首先需要安装mirai。</p><h2 id="mcl"><a href="#mcl" class="headerlink" title="mcl"></a>mcl</h2><p>mcl，mirai-console-loader，顾名思义，能够帮你load mirai-console，而mirai-console就是方便我们使用mirai框架的工具。</p><p>然而按照网上的教程安装mcl却不成功，于是我去了mcl的GitHub页面，又找到了一个mcl-installer工具。</p><blockquote><p>如果读者希望通过手动方式启动mcl，那么在本文的<code>el-bot</code>大标题下有相关内容可供参考。</p></blockquote><p>真是一环套一环啊~</p><h2 id="mcl-installer"><a href="#mcl-installer" class="headerlink" title="mcl installer"></a>mcl installer</h2><p>mcl-installer需要rust环境和调用cargo，绝绝子，继续装rust环境。</p><p><a href="https://www.rust-lang.org/zh-CN/tools/install">安装 Rust</a></p><p>网上教程很多，这里不再添足。</p><p>好，rust环境配好了，查看一下：</p><p><img src="https://s2.loli.net/2022/01/26/8EUkgoAG3X6D9Z2.png" alt="2.png" loading="lazy"></p><p>接下来，按照<a href="https://github.com/iTXTech/mcl-installer/releases">官方文档</a>的提示，使用mcl-installer一键启动mcl：</p><pre><code>$ git clone https://github.com/iTXTech/mcl-installer.git$ cd mcl-installer# native-tls =&gt; 使用系统的 OpenSSL，rustls =&gt; 使用 rustls。# --release 用于构建优化过的二进制文件，如需要进行调试请去除该参数。$ cargo build --features native-tls --release$ cd target/release$ strip mcl-installer # strip 可减小可执行文件大小$ upx --best --lzma mcl-installer # 使用 upx 压缩可进一步缩小可执行文件大小</code></pre><p>其实在进行到</p><blockquote><p>cargo build –features native-tls –release</p></blockquote><p>这一步就可以了。此时在文件夹下产生了一个mcl可执行文件，使用<code>./mcl</code>命令运行：</p><p><img src="https://s2.loli.net/2022/01/26/fXGZjc1YVS7n4AD.png" alt="3.png" loading="lazy"></p><p>mcl启动成功。<del>怎么感觉一键安装一点都不快捷</del>‘</p><h2 id="登录QQ"><a href="#登录QQ" class="headerlink" title="登录QQ"></a>登录QQ</h2><p>在启动了mcl的窗口，运行<code>login 账号 密码</code>：</p><p><img src="https://s2.loli.net/2022/01/26/hTIY1NBuAiS25qe.png" alt="5.png" loading="lazy"></p><p>报错并弹出如下提示框。</p><p><img src="https://s2.loli.net/2022/01/26/Da8xj7fZwEnYRgu.png" alt="4.png" loading="lazy"></p><p>我的QQ开了设备锁，要验证一下。</p><p>好，登录成功，验证一下。</p><p><img src="https://s2.loli.net/2022/01/26/crHKb1kV4awMAtz.png" alt="6.png" loading="lazy"></p><p><img src="https://s2.loli.net/2022/01/26/Iwu8Dr7OVaAgPWz.png" alt="7.png" loading="lazy"></p><p>向bot发送消息，bot接收到。</p><h1 id="el-bot"><a href="#el-bot" class="headerlink" title="el-bot"></a>el-bot</h1><p>终于结束了mirai的安装与配置，可以使用el-bot啦！</p><blockquote><p>这里出了点小状况，由于在安装mcl时，<strong>手动安装</strong>、<strong>使用mcl-installer安装</strong>后的文件夹会不同，而云游的配置文件中默认采用手动安装的目录情况，所以为了后续更好地使用云游的项目，<strong>我采用手动安装的方式，重新安装并启动了mcl</strong>，而本次登录环节出了点小问题，需要使用滑块验证。我采用的解决方法及其具体过程为：</p><ul><li>登录过程中mcl会弹出一个url和一个ticket输入框</li><li>在手机上使用<a href="https://github.com/mzdluo123/TxCaptchaHelper/releases">滑动验证助手</a>，填入url并验证后，滑动验证助手会返回一个ticket</li><li>将ticket粘贴回mcl弹出的输入框中，并关闭弹窗</li></ul></blockquote><h2 id="克隆el-bot"><a href="#克隆el-bot" class="headerlink" title="克隆el-bot"></a>克隆el-bot</h2><pre><code>git clone https://github.com/ElpsyCN/el-bot-template your-el-botcd your-el-bot#这里的your-el-bot就是用来放置项目的文件夹</code></pre><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><pre><code>npm install</code></pre><h2 id="启动mirai"><a href="#启动mirai" class="headerlink" title="启动mirai"></a>启动mirai</h2><p>把前面的mcl启动器文件夹复制到your-el-bot文件夹下，并启动mirai。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="配置mirai-api-http"><a href="#配置mirai-api-http" class="headerlink" title="配置mirai-api-http"></a>配置mirai-api-http</h3><p>下载<a href="https://github.com/project-mirai/mirai-api-http/releases">mirai-api-http Releases</a>jar包，放置在<code>your-el-bot/mcl/plugins</code>文件夹中</p><p>配置文件：<code>mcl/config/net.mamoe.mirai-api-http/setting.yml</code></p><pre><code>cors:- &quot;*&quot;host: 0.0.0.0port: 4859authKey: el-psy-congrooenableWebsocket: true#云游建议修改authKey，虽然我并不明白他的意思</code></pre><h3 id="配置bot"><a href="#配置bot" class="headerlink" title="配置bot"></a>配置bot</h3><pre><code>// el/index.jsmodule.exports = &#123;// 你登录的 QQ 号qq: 12345679,&#125;;</code></pre><blockquote><p>此外，在<code>package.json</code>中，<code>mcl.folder</code>字段默认值为<code>mcl</code>，即我的mirai启动器文件夹，这也是我在<code>el-bot</code>小节中提到的重新安装启动mcl的原因。</p></blockquote><h3 id="启动bot"><a href="#启动bot" class="headerlink" title="启动bot"></a>启动bot</h3><p>一直在报错如下：</p><p><img src="https://s2.loli.net/2022/01/27/RvhxMUZQC45pDIG.jpg" alt="1.jpg" loading="lazy"></p><p>百思不得其解，我搜了各种问题，试了各种方法，最后去群里问云游，源赖氏这个项目自己有问题。</p><p>于是云游连夜升级了项目。</p><p><img src="https://s2.loli.net/2022/01/27/yAaXTfxOVoWFLpE.png" alt="8.png" loading="lazy"></p><p>五点半还在commit项目，感谢云游强大的肝脏。</p><p>好，重新开始！</p><p>略过前述步骤，再次来到启动bot环节，启动：</p><p>依然启动失败。</p><hr><h1 id="放弃"><a href="#放弃" class="headerlink" title="放弃"></a>放弃</h1><p>经过一整天的失败，我决定放弃使用云游的el-bot，转向别的mirai机器人，我也将<a href="https://ireinasan.github.io/2022/01/27/my-sagiri-bot/">另起一篇博客</a>，重新讲述我与我的QQ机器人的故事。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;源起&quot;&gt;&lt;a href=&quot;#源起&quot; class=&quot;headerlink&quot; title=&quot;源起&quot;&gt;&lt;/a&gt;源起&lt;/h1&gt;&lt;p&gt;QQ机器人，嘛，最早接触到这个东西是在公主连结的游戏群里，正经的机器人是为了提供排刀报刀等会战相关服务，但是似乎群友们总是更喜欢色图功能（&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>关于我想要拥有自己的网站这件事</title>
    <link href="http://sagirichan.com/2022/01/25/my-own-website/"/>
    <id>http://sagirichan.com/2022/01/25/my-own-website/</id>
    <published>2022-01-25T12:41:15.000Z</published>
    <updated>2022-05-13T12:02:50.432Z</updated>
    
    <content type="html"><![CDATA[<h1 id="源起"><a href="#源起" class="headerlink" title="源起"></a>源起</h1><p>个人网站，或者叫个人博客，似乎是每个程序员都要有的酷酷的东西（</p><p>大三的时候，我报名了一个比赛，为了完成我的组内分工任务，我拥有了自己的一台云服务器，当然，是学生云。</p><p>寒假是比赛的准备时间，说是准备时间，其实也没什么好准备的，我领到的任务就一句话：在云服务器上部署算法，并实现简单交互。</p><p>就这样，我买了我的腾讯学生云服务器。</p><p>本来我真没想别的东西，但是搜服务器使用教程的时候，总是能看见“使用服务器建站”之类的字眼。。。</p><p>建站？嗯，以普遍理性而言，确实是服务器的好用处。</p><p><del>比赛？什么比赛？</del></p><p>由于这个站在未来可预见的时间内都不会有太多人会访问，所以我的文章主要是留给自己看的，基本是自嗨，十分啰里啰唆。</p><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>今天建一个个人网站应该是非常简单的事情，只要善于使用搜索工具，掌握一些基本的编程知识（甚至都可以不需要），那么每个人都可以拥有自己的站点，自己的一方小天地。</p><p>这里介绍一下我使用的建站教程<a href="https://www.yunyoujun.cn/share/how-to-build-your-site/">教你如何从零开始搭建一个属于自己的网站</a>，这位博主非常可爱，如果大家不认识他，不知道大家记不记得<a href="https://ac.yunyoujun.cn/#/">便携小空调</a>？没错，就是他做的！</p><p>云游的教程非常细致，但是像他所说的，不免有从盘古开天辟地开始讲的感觉，所以在此我去芜存菁（自我感觉hh），保留了对我来说简练精干的部分。</p><h1 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h1><p>我已经有了GitHub账号，所以可以跳过云游教程的一长串内容，直接开始hexo！</p><h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><p>打开Windows powershell（之所以使用它是因为它的语法和Linux相仿，我比较熟悉），输入<code>npm install hexo-cli -g</code></p><blockquote><p>install 自然是安装。</p><p>hexo-cli 则是 hexo 的终端工具，可以帮助你生成一些模版文件，之后再用到。</p><p>-g 代表的是全局安装。也就是在任何地方都可以使用，否则会只能在安装的目录下使用。</p><p>–摘自云游博客</p></blockquote><h2 id="建立网页文件"><a href="#建立网页文件" class="headerlink" title="建立网页文件"></a>建立网页文件</h2><p>进入用来放置网页文件的文件夹，右键，Git Bash Here</p><p>在git终端输入<code>hexo init 之前建好的仓库名</code>，在我这里即</p><p><code>hexo init ireinasan.github.io</code></p><p><del>好，经典连不上GitHub</del><br><del>重试</del></p><p>上一步完成，继续。</p><blockquote><p>cd ireinasan.github.io</p><p>npm install</p><p>hexo s</p></blockquote><p>最后一个命令打开了本地的网页服务器，此时在浏览器地址栏中输入<code>localhost:4000</code>便可查看本地博客。</p><p><img src="https://s2.loli.net/2022/01/24/WBP6qcMr8A4UfvT.png" alt="localhost:4000" title="localhost:4000" loading="lazy"></p><h2 id="使用hexo主题"><a href="#使用hexo主题" class="headerlink" title="使用hexo主题"></a>使用hexo主题</h2><p>hexo的默认主题非常丑，所以我们要换一个漂亮的主体！下面学习如何使用别人开发的hexo主题。</p><p>依然是<del>薅云游的羊毛</del>以云游的教程为例。</p><h3 id="下载hexo主题"><a href="#下载hexo主题" class="headerlink" title="下载hexo主题"></a>下载hexo主题</h3><p>在配置hexo主题时，我们可以使用宇宙第一IDE——</p><p><img src="https://s2.loli.net/2022/01/24/9b1haEJ2WOlDZVK.png" alt="正是在下" title="正是在下" loading="lazy"></p><p>（主要是为了方便修改配置文件）</p><p>在使用hexo初始化好的<code>ireinasan.github.io</code>文件夹中<code>git clone https://github.com/YunYouJun/hexo-theme-yun themes/yun</code>.</p><h3 id="编辑hexo配置"><a href="#编辑hexo配置" class="headerlink" title="编辑hexo配置"></a>编辑hexo配置</h3><p>仍然是在这个文件夹中，右击使用vscode打开，找到<code>_config.yml</code>文件并打开。</p><p>找到<code>theme</code>，将冒号右侧的<code>landscape</code>改成<code>yun</code>。</p><blockquote><p>由于我的主题使用了 pug 和 stylus，而 Hexo 自带的一般是 ejs 与 stylus，所以你可能还需要输入以下命令安装渲染器。</p><p>npm install hexo-render-pug hexo-renderer-stylus<br>#如果出问题，可以换 yarn 安装试试。</p></blockquote><p>完成上一步以后，再次<code>hexo s</code>，并在<code>localhost:4000</code>中查看效果。如果一切顺利，我们就已经用上了云游的主题。</p><h3 id="自定义主题配置"><a href="#自定义主题配置" class="headerlink" title="自定义主题配置"></a>自定义主题配置</h3><p>。。。</p><p>云游教程里随意带过的一段文字，却是我建站到现在花费时间最长的内容。这里直接放上云游的主题文档吧：<a href="https://yun.yunyoujun.cn/guide/">云游主题帮助文档</a>。</p><p>简单说几个要点：</p><ul><li><p>在博客文件夹（也就是我的ireinasan.github.io文件夹）底下建立一个<code>source/_data/yun.yml</code>文件，然后在这个yml文件中自定义自己的配置，不要动别的配置，以方便后续升级主题。</p></li><li><p>进入帮助文档以后随便扫一扫<code>使用指南</code>中的内容，帮助不是很大，重点都在第二个大标题<code>主题配置</code>中。</p></li><li><p><code>页面配置</code>中也有一些可看的东西，比如点击头像的about页面等（这个地方一度让我感到非常困扰）。</p></li></ul><h1 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h1><h2 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h2><p>右上角<code>+</code>-&gt;<code>New repository</code>新建仓库</p><p><img src="https://s2.loli.net/2022/01/24/mobtwd43l6C9c1q.png" alt="新建仓库" title="new repository" loading="lazy"></p><p>仓库名称格式为：</p><p><code>用户名.github.io</code></p><p>Create repository.</p><h2 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h2><p>在博客文件夹下：</p><blockquote><p>hexo clean #清除缓存<br>hexo g #generate简写为g</p></blockquote><p>此时文件夹目录下出现一个public目录，里边就是我的站点的静态文件。</p><h2 id="与远程仓库建立关联"><a href="#与远程仓库建立关联" class="headerlink" title="与远程仓库建立关联"></a>与远程仓库建立关联</h2><blockquote><p>git init<br>git checkout -b hexo #创建一个分支 </p></blockquote><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>hexo有三种部署方法，云游详细介绍的、以及我采用的是<a href="https://hexo.io/zh-cn/docs/one-command-deployment">一键部署</a>。</p><p>安装<code>hexo-deployer-git</code>插件</p><blockquote><p>npm install hexo-deployer-git</p></blockquote><p>在<code>ireinasan.github.io/_config.yml</code>中配置：</p><pre><code>deploy:  type: git  repo: git@github.com:Ireinasan/ireinasan.github.io.git   # 自己的仓库地址，由于上一条type是git类型，所以此处填写的是SSH的地址    branch: master # 默认使用 master 分支  message: Update Hexo Static Content # 你可以自定义此次部署更新的说明</code></pre><p>然后在地址栏输入<code>ireinasan.github.io/</code>就可以看到我的网站啦！</p><p>一键部署会将<code>生成静态文件</code>步骤中产生的public文件夹中的内容（即网页静态文件）推送到我们的GitHub仓库中，<strong>而不是我们的网站源代码</strong>。因此，如果有需要，应再建一个专门存储代码的仓库。</p><h1 id="绑定个人域名"><a href="#绑定个人域名" class="headerlink" title="绑定个人域名"></a>绑定个人域名</h1><p>这里云游的教程比较简略，我又搜了一些补充内容。</p><ul><li>在腾讯云的控制台为域名添加解析</li></ul><p><img src="https://s2.loli.net/2022/01/25/LS5B3T6yJAxnXIM.png" alt="建立解析.png" loading="lazy"></p><p>IPv4地址为ping出的<code>ireinasan.github.io</code>服务器IP</p><ul><li>在GitHub的<code>ireinasan.github.io</code>仓库，<code>Settings</code>-<code>Pages</code>-<code>Custom domain</code>中填入域名<code>sagirichan.com</code>，<code>Save</code></li></ul><p><em>这一步要等一会，因为域名解析需要时间。</em></p><p>完成后，仓库中会自动生成一个CNAME文件，文件里边就是我们要绑定的域名<code>sairichan.com</code></p><p>如果觉得有必要，也可以在本地文件夹中<code>ireinasan.github.io\source</code>路径下建一个同样的CNAME文件。</p><p><del>如果按照我的步骤出了什么问题还是自行百度⑧，每个人的问题都不一样</del></p><h1 id="网站备案"><a href="#网站备案" class="headerlink" title="网站备案"></a>网站备案</h1><p>绑定域名后，我使用的仍然是GitHub的服务器，而由于GitHub在国内访问不是很稳定，所以连带着我的网站访问也不是很稳定。于是我决定尝试把我的网站部署到自己的服务器上。</p><p>然鹅，原本以为万事俱备，只欠东风的网站备案，居然真的就像诸葛亮借东风那样麻烦2333</p><p><del>我不保证这一部分能写下去</del></p><p>由于我是在腾讯云上买的域名，所以我就直接在腾讯云上进行网站备案。</p><p>搜索网站备案、进入备案主页、阅读注意事项<del>其实并没有</del>，开始备案。</p><h2 id="验证备案类型"><a href="#验证备案类型" class="headerlink" title="验证备案类型"></a>验证备案类型</h2><p>由于我是首次备案，所以我来到了<code>首次备案</code>页面（废话文学），草草扫描了一下注意事项，下一步：<code>验证备案类型</code> 。</p><p>填写<code>主办单位信息</code>。<code>备案省份</code>（划重点，要考）、<code>主办单位性质</code>，由于我的主办单位性质是个人，所以我接下来要上传身份证的正反两面。</p><p><del>愣着干嘛，拍照片啊</del></p><p>填入我购买的域名、我购买的云服务器的公网IP。</p><p>立即验证！</p><p>网站弹出了一个<del>严重警告</del>温馨提示！</p><p><img src="https://s2.loli.net/2022/01/24/2nA1vwH9JWf7ROK.png" alt="温馨提示" title="温馨提示" loading="lazy"></p><p>网站提示我们，要再次核对<code>备案省份</code>、主办单位信息。</p><p>如果你觉得自己填写的信息没有问题，进入下一步。</p><h2 id="备案小程序"><a href="#备案小程序" class="headerlink" title="备案小程序"></a>备案小程序</h2><p>在上一步的<code>温馨提示</code>中，点击下一步，会弹出一个警告书，不用多看，继续下一步，在备案小程序中进行网站负责人身份验证。</p><p><img src="https://s2.loli.net/2022/01/24/AlnSMQ7N4zW8XvL.jpg" alt="小程序截图" title="tencentVideoCheck" loading="lazy"></p><p>继续拍照。。。</p><p>在第三步，上传视频核身中，小程序会获取你的地理位置，你的地理位置需要与上一步 <strong><code>验证备案类型</code></strong> 中填写的备案省份相符。</p><p><strong>在我的第一次尝试中，就由于我人在江苏而备案主体省份填写了湖南，导致信息不符，无法采集视频核身，而警告有告诉我们，备案省份无法更改，所以。。。我只能放弃本次备案，重新开始。</strong></p><p><img src="https://s2.loli.net/2022/01/24/5O2NYvfk4ViqIHD.jpg" alt="呜，苦露西" title="呜，苦露西" loading="lazy"></p><p>好，我放弃了本次备案，重新开始了我的备案之路，并且在第二次备案中顺利地完成了备案小程序的视频身份核验，进入下一步，主体信息。</p><h2 id="主体信息"><a href="#主体信息" class="headerlink" title="主体信息"></a>主体信息</h2><p>主体信息第一条就是江苏，果然是无法更改的。</p><p><img src="https://s2.loli.net/2022/01/24/rqGypFfIkz9lmD1.png" alt="主体信息" title="主体信息" loading="lazy"></p><p>填写个人信息ing…</p><p>通信地址原来也是根据身份证地址定好的，没法改成我的大学地址。。。</p><p>验证手机号，填写邮箱。下一步，<code>网站信息</code>。</p><h2 id="网站信息"><a href="#网站信息" class="headerlink" title="网站信息"></a>网站信息</h2><p>填写网站名称，取一个好听或自己喜欢的名称。</p><p>我的网站名称来源于我很喜欢的一部小说《宰执天下》<del>是主角穿越后第一炮的章节名</del>。</p><p>云资源，我购买的服务器类型及公网IP。</p><p>域名，我购买的域名。</p><p>备注，随便写一写。</p><p>网站负责人信息，在上一步<code>主体信息</code>中已经填过了，这里可以不用再麻烦一遍。</p><p>备案信息填写完成在望，我已经开始开香槟了。</p><blockquote><p>网站补充材料，网站备案信息真实性责任告知书、网站备案信息真实性承诺书、网站负责人承诺视频，简单！</p></blockquote><p><code>网站备案信息真实性责任告知书</code>下载链接————下载————上传。</p><p>emmm，怎么只能上传图片格式的？百度一下。</p><p>哦，源赖氏，要把这份PDF文件打印出来，亲笔签字，然后再拍照片or扫描，再传上去，<code>网站备案信息真实性承诺书</code>也一样。</p><p>可我家里没有打印机啊。。。这大半夜的，外边打印店都关门了。</p><p>好吧，只能等第二天了。</p><p>还是看看第三个吧，<code>网站负责人承诺视频</code>，点开，又是扫码进入小程序，行吧。</p><p>面对屏幕读文字，上传。</p><p>返回网页端，我留了个心眼，看了一下我的视频效果。。。果然又有问题了。</p><blockquote><p>我真是个铸币，我在备案的时候，公主连结正在打公会战，我把模拟器开着放后台，同时备案。结果上传承诺视频的时候，模拟器的声音没关，被录进去了，视频里全是会战界面的BGM，根本听不清说话，这要传上去那审核铁定不通过。</p></blockquote><p>没办法，关了模拟器声音，重录吧，这次行了。</p><p>保存备案草稿，上床睡觉，明天最后练一次科目三，后天要考试了。</p><hr><p>第二天————</p><p>练科目三累死了，早上六点半就起床，中午午饭也是在外边解决的。</p><p>回家到小区门口，找了个打印店，打印了两份补充材料，借了打印店的笔填好，拍照，传给电脑。回家，打开电脑，上传照片，完成！保存当前网站！</p><blockquote><p>域名 sagirichan.com 实名认证时间为 2022-01-23 00:09:44 ，距离现在未满 72 小时，无法备案，请您在 2022-01-26 00:09:44 之后再进行备案</p></blockquote><p><img src="https://s2.loli.net/2022/01/24/YXCwJOjIzEyniNq.jpg" alt="tnnd" title="tnnd" loading="lazy"></p><hr><p>ただいま~</p><p>科目三考完了，通过力~我的网站也可以继续备案了。登录腾讯云，网站备案——保存当前网站—— <del>上传补充材料，由于我没有要补充的材料，所以跳过这一步</del> ——提交审核！</p><h2 id="静等审核通知！"><a href="#静等审核通知！" class="headerlink" title="静等审核通知！"></a>静等审核通知！</h2><hr><p>腾讯初审把我驳回了，主要三个问题，一个是我身份证拍的照片背景不一样（实际上只是相机白平衡出了问题，手机背大锅）；第二个是域名没有备案不许访问，所以我之前私自给GitHub Page绑定了个人域名，要删除解析记录（悲）；第三个是网站负责人承诺视频，我没有手持承诺书，我说啊，拍视频的时候又没有提示我要手持承诺书，现在以这个理由驳回来了，这不是搞我心态吗？</p><p>总之吧，我按照要求一一解决了，希望第二次申请能给我通过。</p><hr><p>腾讯初审速度很快，一个多小时就好了；提交工信部终审也很快，嘿嘿，成功在望！</p><hr><p>2022.2.22，今天普京把军队开进了乌克兰东部的两个州，工信部把我的网站sagirichan.com审核通过了。而此时距离我提交申请已经过去了将近一个月😭</p><p>不管怎么说，我的网站备案是下来了，总算可以部署到我自己的服务器上啦。</p><h1 id="部署到自己的服务器上"><a href="#部署到自己的服务器上" class="headerlink" title="部署到自己的服务器上"></a>部署到自己的服务器上</h1><p>这个坑太大了，见我的另一篇文章：</p><p><a href="http://101.33.208.50/2022/04/30/blog-on-cloud/">如何把博客部署在云服务器上？</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;源起&quot;&gt;&lt;a href=&quot;#源起&quot; class=&quot;headerlink&quot; title=&quot;源起&quot;&gt;&lt;/a&gt;源起&lt;/h1&gt;&lt;p&gt;个人网站，或者叫个人博客，似乎是每个程序员都要有的酷酷的东西（&lt;/p&gt;
&lt;p&gt;大三的时候，我报名了一个比赛，为了完成我的组内分工任务，我拥有</summary>
      
    
    
    
    
  </entry>
  
</feed>
